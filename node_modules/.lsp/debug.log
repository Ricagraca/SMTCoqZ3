Hello - from /Users/ricardociriacodagraca/.vscode/extensions/jaredly.reason-vscode-1.7.13/bin.native
Previous log location: /var/folders/yl/6wwzy54d02sdj7gd_61591s80000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtForm\nopen SmtAtom\nopen SmtTrace\nopen SmtCertif\n\n\nlet euf_checker_modules = [ [\"SMTCoq\";\"Trace\";\"Euf_Checker\"] ]\nlet certif_ops args = CoqTerms.make_certif_ops euf_checker_modules args\nlet cCertif = gen_constant euf_checker_modules \"Certif\"\nlet ccertif = gen_constant euf_checker_modules \"certif\"\nlet cchecker = gen_constant euf_checker_modules \"checker\"\nlet cchecker_correct = gen_constant euf_checker_modules \"checker_correct\"\nlet cchecker_b_correct =\n  gen_constant euf_checker_modules \"checker_b_correct\"\nlet cchecker_b = gen_constant euf_checker_modules \"checker_b\"\nlet cchecker_eq_correct =\n  gen_constant euf_checker_modules \"checker_eq_correct\"\nlet cchecker_eq = gen_constant euf_checker_modules \"checker_eq\"\n(* let csetup_checker_step_debug =\n *   gen_constant euf_checker_modules \"setup_checker_step_debug\" *)\n(* let cchecker_step_debug = gen_constant euf_checker_modules \"checker_step_debug\" *)\n(* let cstep = gen_constant euf_checker_modules \"step\" *)\nlet cchecker_debug = gen_constant euf_checker_modules \"checker_debug\"\n\nlet cname_step = gen_constant euf_checker_modules \"name_step\"\n\nlet cName_Res = gen_constant euf_checker_modules \"Name_Res\"\nlet cName_Weaken= gen_constant euf_checker_modules \"Name_Weaken\"\nlet cName_ImmFlatten= gen_constant euf_checker_modules \"Name_ImmFlatten\"\nlet cName_CTrue= gen_constant euf_checker_modules \"Name_CTrue\"\nlet cName_CFalse = gen_constant euf_checker_modules \"Name_CFalse\"\nlet cName_BuildDef= gen_constant euf_checker_modules \"Name_BuildDef\"\nlet cName_BuildDef2= gen_constant euf_checker_modules \"Name_BuildDef2\"\nlet cName_BuildProj = gen_constant euf_checker_modules \"Name_BuildProj\"\nlet cName_ImmBuildDef= gen_constant euf_checker_modules \"Name_ImmBuildDef\"\nlet cName_ImmBuildDef2= gen_constant euf_checker_modules \"Name_ImmBuildDef2\"\nlet cName_ImmBuildProj = gen_constant euf_checker_modules \"Name_ImmBuildProj\"\nlet cName_EqTr = gen_constant euf_checker_modules \"Name_EqTr\"\nlet cName_EqCgr = gen_constant euf_checker_modules \"Name_EqCgr\"\nlet cName_EqCgrP= gen_constant euf_checker_modules \"Name_EqCgrP\"\nlet cName_LiaMicromega = gen_constant euf_checker_modules \"Name_LiaMicromega\"\nlet cName_LiaDiseq= gen_constant euf_checker_modules \"Name_LiaDiseq\"\nlet cName_SplArith= gen_constant euf_checker_modules \"Name_SplArith\"\nlet cName_SplDistinctElim = gen_constant euf_checker_modules \"Name_SplDistinctElim\"\nlet cName_BBVar= gen_constant euf_checker_modules \"Name_BBVar\"\nlet cName_BBConst= gen_constant euf_checker_modules \"Name_BBConst\"\nlet cName_BBOp= gen_constant euf_checker_modules \"Name_BBOp\"\nlet cName_BBNot= gen_constant euf_checker_modules \"Name_BBNot\"\nlet cName_BBNeg= gen_constant euf_checker_modules \"Name_BBNeg\"\nlet cName_BBAdd= gen_constant euf_checker_modules \"Name_BBAdd\"\nlet cName_BBConcat= gen_constant euf_checker_modules \"Name_BBConcat\"\nlet cName_BBMul= gen_constant euf_checker_modules \"Name_BBMul\"\nlet cName_BBUlt= gen_constant euf_checker_modules \"Name_BBUlt\"\nlet cName_BBSlt= gen_constant euf_checker_modules \"Name_BBSlt\"\nlet cName_BBEq= gen_constant euf_checker_modules \"Name_BBEq\"\nlet cName_BBDiseq= gen_constant euf_checker_modules \"Name_BBDiseq\"\nlet cName_BBExtract= gen_constant euf_checker_modules \"Name_BBExtract\"\nlet cName_BBZextend= gen_constant euf_checker_modules \"Name_BBZextend\"\nlet cName_BBSextend= gen_constant euf_checker_modules \"Name_BBSextend\"\nlet cName_BBShl= gen_constant euf_checker_modules \"Name_BBShl\"\nlet cName_BBShr= gen_constant euf_checker_modules \"Name_BBShr\"\nlet cName_RowEq= gen_constant euf_checker_modules \"Name_RowEq\"\nlet cName_RowNeq= gen_constant euf_checker_modules \"Name_RowNeq\"\nlet cName_Ext= gen_constant euf_checker_modules \"Name_Ext\"\nlet cName_Hole= gen_constant euf_checker_modules \"Name_Hole\"\n\n(* Given an SMT-LIB2 file and a certif, build the corresponding objects *)\n\nlet compute_roots roots last_root =\n  let r = ref last_root in\n  while (has_prev !r) do\n    r := prev !r\n  done;\n\n  let rec find_root i root = function\n    | [] -> assert false\n    | t::q -> if Form.equal t root then i else find_root (i+1) root q in\n\n  let rec used_roots acc r =\n    if isRoot r.kind then\n      match r.value with\n        | Some [root] ->\n           let j = find_root 0 root roots in\n           used_roots (j::acc) (next r)\n        | _ -> assert false\n    else acc\n  in\n\n  used_roots [] !r\n\n\nlet interp_uf t_i ta tf c =\n  let rec interp = function\n    | [] -> Lazy.force cfalse\n    | [l] -> Form.interp_to_coq (Atom.interp_to_coq t_i ta) tf l\n    | l::c -> mklApp corb [|Form.interp_to_coq (Atom.interp_to_coq t_i ta) tf l; interp c|] in\n  interp c\n\nlet interp_conseq_uf t_i (prem, concl) =\n  let ta = Hashtbl.create 17 in\n  let tf = Hashtbl.create 17 in\n  let rec interp = function\n    | [] -> mklApp cis_true [|interp_uf t_i ta tf concl|]\n    | c::prem -> Term.mkArrow (mklApp cis_true [|interp_uf t_i ta tf c|]) (interp prem) in\n  interp prem\n\n\nlet print_assm ty =\n  Format.printf \"WARNING: assuming the following hypothesis:\\n%s\\n@.\"\n    (string_coq_constr ty)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace (rt, ro, ra, rf, roots, max_id, confl) =\n\n  let t_i' = make_t_i rt in\n  let ce5 = Structures.mkUConst t_i' in\n  let ct_i = Structures.mkConst (Structures.declare_constant t_i ce5) in\n\n  let t_func' = make_t_func ro ct_i in\n  let ce6 = Structures.mkUConst t_func' in\n  let ct_func = Structures.mkConst (Structures.declare_constant t_func ce6) in\n\n  let t_atom' = Atom.interp_tbl ra in\n  let ce1 = Structures.mkUConst t_atom' in\n  let ct_atom = Structures.mkConst (Structures.declare_constant t_atom ce1) in\n\n  let t_form' = snd (Form.interp_tbl rf) in\n  let ce2 = Structures.mkUConst t_form' in\n  let ct_form = Structures.mkConst (Structures.declare_constant t_form ce2) in\n\n  (* EMPTY LEMMA LIST *)\n  let (tres, last_root, cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf ct_i) (certif_ops (Some [|ct_i; ct_func; ct_atom; ct_form|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let used_roots = compute_roots roots last_root in\n  let roots =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n  let used_roots =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|]; Structures.mkArray (Lazy.force cint, res)|] in\n  let ce3 = Structures.mkUConst roots in\n  let _ = Structures.declare_constant root ce3 in\n  let ce3' = Structures.mkUConst used_roots in\n  let _ = Structures.declare_constant used_root ce3' in\n\n  let certif =\n    mklApp cCertif [|ct_i; ct_func; ct_atom; ct_form; mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n  let ce4 = Structures.mkUConst certif in\n  let _ = Structures.declare_constant trace ce4 in\n\n  ()\n\n\n(* Given an SMT-LIB2 file and a certif, build the corresponding theorem *)\n\nlet interp_roots t_i roots =\n  let interp = Form.interp_to_coq (Atom.interp_to_coq t_i (Hashtbl.create 17)) (Hashtbl.create 17) in\n  match roots with\n    | [] -> Lazy.force ctrue\n    | f::roots -> List.fold_left (fun acc f -> mklApp candb [|acc; interp f|]) (interp f) roots\n\nlet theorem name (rt, ro, ra, rf, roots, max_id, confl) =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n  let nused_roots = Structures.mkName \"used_roots\" in\n  let nd = Structures.mkName \"d\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = make_t_func ro (v 1 (*t_i*)) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n\n  (* EMPTY LEMMA LIST *)\n  let (tres,last_root,cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *)|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let certif =\n    mklApp cCertif [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *); mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|]; Structures.mkArray (Lazy.force cint, res)|] in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n\n  let theorem_concl = mklApp cnot [|mklApp cis_true [|interp_roots t_i roots|]|] in\n  let theorem_proof_cast =\n    Structures.mkCast (\n        Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n        Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n        Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n        Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n        Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n        Structures.mkLetIn (nused_roots, used_rootsCstr, mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n        Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n        mklApp cchecker_correct\n               [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*);\n\t         vm_cast_true_no_check\n\t           (mklApp cchecker [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|])|]))))))),\n        Structures.vmcast,\n        theorem_concl)\n  in\n  let theorem_proof_nocast =\n        Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n        Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n        Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n        Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n        Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n        Structures.mkLetIn (nused_roots, used_rootsCstr, mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n        Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n        mklApp cchecker_correct\n               [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|])))))))\n  in\n\n  let ce = Structures.mkTConst theorem_proof_cast theorem_proof_nocast theorem_concl in\n  let _ = Structures.declare_constant name ce in\n  ()\n\n\n(* Given an SMT-LIB2 file and a certif, call the checker *)\n\nlet checker (rt, ro, ra, rf, roots, max_id, confl) =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n  let nused_roots = Structures.mkName \"used_roots\" in\n  let nd = Structures.mkName \"d\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = make_t_func ro (v 1 (*t_i*)) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n\n  (* EMPTY LEMMA LIST *)\n  let (tres,last_root,cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *)|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let certif =\n    mklApp cCertif [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *); mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|]; Structures.mkArray (Lazy.force cint, res)|] in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n\n  let tm =\n   Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n   Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n   Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n   Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n   Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n   Structures.mkLetIn (nused_roots, used_rootsCstr, mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n   Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n   mklApp cchecker [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|]))))))) in\n\n  let res = Structures.cbv_vm (Global.env ()) tm (Lazy.force CoqTerms.cbool) in\n  Format.eprintf \"     = %s\\n     : bool@.\"\n    (if Structures.eq_constr res (Lazy.force CoqTerms.ctrue) then\n        \"true\" else \"false\")\n\nlet count_used confl =\n  let cpt = ref 0 in\n  let rec count c =\n    incr cpt;\n    (* if c.used = 1 then incr cpt; *)\n    match c.prev with\n    | None -> !cpt\n    | Some c -> count c\n  in\n  count confl\n\n\nlet checker_debug (rt, ro, ra, rf, roots, max_id, confl) =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n  let nused_roots = Structures.mkName \"used_roots\" in\n  let nd = Structures.mkName \"d\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = make_t_func ro (v 1 (*t_i*)) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n\n  let (tres,last_root,cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4(*t_i*); v 3(*t_func*);\n                          v 2(*t_atom*); v 1(* t_form *)|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let certif =\n    mklApp cCertif [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *);\n                     mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|];\n                   Structures.mkArray (Lazy.force cint, res)|] in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n\n  let tm =\n   Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n   Structures.mkLetIn (ntfunc, t_func,\n                 mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n   Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n   Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n   Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*);\n                                              v 2 (*t_atom*); v 1 (*t_form*)|],\n   Structures.mkLetIn (nused_roots, used_rootsCstr,\n                 mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n   Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n   mklApp cchecker_debug [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*);\n       v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|]))))))) in\n\n  let res = Structures.cbv_vm (Global.env ()) tm\n      (mklApp coption\n         [|mklApp cprod\n             [|Lazy.force cnat; Lazy.force cname_step|]|]) in\n\n  match Structures.decompose_app res with\n  | c, _ when Structures.eq_constr c (Lazy.force cNone) ->\n    Structures.error (\"Debug checker is only meant to be used for certificates \\\n                       that fail to be checked by SMTCoq.\")\n  | c, [_; n] when Structures.eq_constr c (Lazy.force cSome) ->\n    (match Structures.decompose_app n with\n     | c, [_; _; cnb; cn] when Structures.eq_constr c (Lazy.force cpair) ->\n       let n = fst (Structures.decompose_app cn) in\n       let name =\n         if Structures.eq_constr n (Lazy.force cName_Res ) then \"Res\"\n         else if Structures.eq_constr n (Lazy.force cName_Weaken) then \"Weaken\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmFlatten) then \"ImmFlatten\"\n         else if Structures.eq_constr n (Lazy.force cName_CTrue) then \"CTrue\"\n         else if Structures.eq_constr n (Lazy.force cName_CFalse ) then \"CFalse\"\n         else if Structures.eq_constr n (Lazy.force cName_BuildDef) then \"BuildDef\"\n         else if Structures.eq_constr n (Lazy.force cName_BuildDef2) then \"BuildDef2\"\n         else if Structures.eq_constr n (Lazy.force cName_BuildProj ) then \"BuildProj\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmBuildDef) then \"ImmBuildDef\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmBuildDef2) then \"ImmBuildDef2\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmBuildProj ) then \"ImmBuildProj\"\n         else if Structures.eq_constr n (Lazy.force cName_EqTr ) then \"EqTr\"\n         else if Structures.eq_constr n (Lazy.force cName_EqCgr ) then \"EqCgr\"\n         else if Structures.eq_constr n (Lazy.force cName_EqCgrP) then \"EqCgrP\"\n         else if Structures.eq_constr n (Lazy.force cName_LiaMicromega ) then \"LiaMicromega\"\n         else if Structures.eq_constr n (Lazy.force cName_LiaDiseq) then \"LiaDiseq\"\n         else if Structures.eq_constr n (Lazy.force cName_SplArith) then \"SplArith\"\n         else if Structures.eq_constr n (Lazy.force cName_SplDistinctElim ) then \"SplDistinctElim\"\n         else if Structures.eq_constr n (Lazy.force cName_BBVar) then \"BBVar\"\n         else if Structures.eq_constr n (Lazy.force cName_BBConst) then \"BBConst\"\n         else if Structures.eq_constr n (Lazy.force cName_BBOp) then \"BBOp\"\n         else if Structures.eq_constr n (Lazy.force cName_BBNot) then \"BBNot\"\n         else if Structures.eq_constr n (Lazy.force cName_BBNeg) then \"BBNeg\"\n         else if Structures.eq_constr n (Lazy.force cName_BBAdd) then \"BBAdd\"\n         else if Structures.eq_constr n (Lazy.force cName_BBConcat) then \"BBConcat\"\n         else if Structures.eq_constr n (Lazy.force cName_BBMul) then \"BBMul\"\n         else if Structures.eq_constr n (Lazy.force cName_BBUlt) then \"BBUlt\"\n         else if Structures.eq_constr n (Lazy.force cName_BBSlt) then \"BBSlt\"\n         else if Structures.eq_constr n (Lazy.force cName_BBEq) then \"BBEq\"\n         else if Structures.eq_constr n (Lazy.force cName_BBDiseq) then \"BBDiseq\"\n         else if Structures.eq_constr n (Lazy.force cName_BBExtract) then \"BBExtract\"\n         else if Structures.eq_constr n (Lazy.force cName_BBZextend) then \"BBZextend\"\n         else if Structures.eq_constr n (Lazy.force cName_BBSextend) then \"BBSextend\"\n         else if Structures.eq_constr n (Lazy.force cName_BBShl) then \"BBShl\"\n         else if Structures.eq_constr n (Lazy.force cName_BBShr) then \"BBShr\"\n         else if Structures.eq_constr n (Lazy.force cName_RowEq) then \"RowEq\"\n         else if Structures.eq_constr n (Lazy.force cName_RowNeq) then \"RowNeq\"\n         else if Structures.eq_constr n (Lazy.force cName_Ext) then \"Ext\"\n         else if Structures.eq_constr n (Lazy.force cName_Hole) then \"Hole\"\n         else string_coq_constr n\n       in\n       let nb = mk_nat cnb + List.length roots + (confl.id + 1 - count_used confl) in\n       Structures.error (\"Step number \" ^ string_of_int nb ^\n                         \" (\" ^ name ^ \") of the certificate likely failed.\")\n     | _ -> assert false\n    )\n  | _ -> assert false\n\n\n\n(* let rec of_coq_list cl =\n *   match Structures.decompose_app cl with\n *   | c, _ when Structures.eq_constr c (Lazy.force cnil) -> []\n *   | c, [_; x; cr] when Structures.eq_constr c (Lazy.force ccons) ->\n *     x :: of_coq_list cr\n *   | _ -> assert false *)\n\n\n(* let checker_debug_step t_i t_func t_atom t_form root used_root trace\n *     (rt, ro, ra, rf, roots, max_id, confl) =\n * \n *   let t_i' = make_t_i rt in\n *   let ce5 = Structures.mkUConst t_i' in\n *   let ct_i = Structures.mkConst (Structures.declare_constant t_i ce5) in\n * \n *   let t_func' = make_t_func ro ct_i in\n *   let ce6 = Structures.mkUConst t_func' in\n *   let ct_func =\n *     Structures.mkConst (Structures.declare_constant t_func ce6) in\n * \n *   let t_atom' = Atom.interp_tbl ra in\n *   let ce1 = Structures.mkUConst t_atom' in\n *   let ct_atom =\n *     Structures.mkConst (Structures.declare_constant t_atom ce1) in\n * \n *   let t_form' = snd (Form.interp_tbl rf) in\n *   let ce2 = Structures.mkUConst t_form' in\n *   let ct_form =\n *     Structures.mkConst (Structures.declare_constant t_form ce2) in\n * \n *   let (tres, last_root, cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n *       (interp_conseq_uf ct_i)\n *       (certif_ops (Some [|ct_i; ct_func; ct_atom; ct_form|])) confl None in\n *   List.iter (fun (v,ty) ->\n *     let _ = Structures.declare_new_variable v ty in\n *     print_assm ty\n *   ) cuts;\n * \n *   let used_roots = compute_roots roots last_root in\n *   let croots =\n *     let res = Array.make (List.length roots + 1) (mkInt 0) in\n *     let i = ref 0 in\n *     List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n *     Structures.mkArray (Lazy.force cint, res) in\n *   let cused_roots =\n *     let l = List.length used_roots in\n *     let res = Array.make (l + 1) (mkInt 0) in\n *     let i = ref (l-1) in\n *     List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n *     mklApp cSome [|mklApp carray [|Lazy.force cint|];\n *                    Structures.mkArray (Lazy.force cint, res)|] in\n *   let ce3 = Structures.mkUConst croots in\n *   let _ = Structures.declare_constant root ce3 in\n *   let ce3' = Structures.mkUConst cused_roots in\n *   let _ = Structures.declare_constant used_root ce3' in\n * \n *   let certif =\n *     mklApp cCertif [|ct_i; ct_func; ct_atom; ct_form; mkInt (max_id + 1);\n *                      tres;mkInt (get_pos confl)|] in\n *   let ce4 = Structures.mkUConst certif in\n *   let _ = Structures.declare_constant trace ce4 in\n * \n *   let setup =\n *    mklApp csetup_checker_step_debug\n *      [| ct_i; ct_func; ct_atom; ct_form; croots; cused_roots; certif |] in\n * \n *   let setup = Structures.cbv_vm (Global.env ()) setup\n *       (mklApp cprod\n *          [|Lazy.force cState_S_t;\n *            mklApp clist [|mklApp cstep\n *                             [|ct_i; ct_func; ct_atom; ct_form|]|]|]) in\n * \n *   let s, steps = match Structures.decompose_app setup with\n *     | c, [_; _; s; csteps] when Structures.eq_constr c (Lazy.force cpair) ->\n *       s, of_coq_list csteps\n *     | _ -> assert false\n *   in\n * \n *   let cpt = ref (List.length roots) in\n *   let debug_step s step =\n *     incr cpt;\n *     Format.eprintf \"%d@.\" !cpt;\n *     let tm =\n *       mklApp cchecker_step_debug\n *         [| ct_i; ct_func; ct_atom; ct_form; s; step |] in\n * \n *     let res =\n *       Structures.cbv_vm (Global.env ()) tm\n *           (mklApp cprod [|Lazy.force cState_S_t; Lazy.force cbool|]) in\n * \n *     match Structures.decompose_app res with\n *     | c, [_; _; s; cbad] when Structures.eq_constr c (Lazy.force cpair) ->\n *       if not (mk_bool cbad) then s\n *       else Structures.error (\"Step number \" ^ string_of_int !cpt ^\n *                              \" (\" ^ string_coq_constr\n *                                (fst (Structures.decompose_app step)) ^ \")\" ^\n *                              \" of the certificate likely failed.\" )\n *     | _ -> assert false\n *   in\n * \n *   List.fold_left debug_step s steps |> ignore;\n * \n *   Structures.error (\"Debug checker is only meant to be used for certificates \\\n *                      that fail to be checked by SMTCoq.\") *)\n\n\n\n(* Tactic *)\n\nlet build_body rt ro ra rf l b (max_id, confl) vm_cast find =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = Structures.lift 1 (make_t_func ro (v 0 (*t_i - 1*))) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n  let (tres,_,cuts) = SmtTrace.to_coq Form.to_coq\n      (interp_conseq_uf t_i)\n      (certif_ops\n         (Some [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|]))\n      confl find\n  in\n  let certif =\n    mklApp cCertif\n      [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*);\n        mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let add_lets t =\n    Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n    Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(*t_i*)|]|],\n    Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n    Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n    Structures.mkLetIn (nc, certif, mklApp ccertif\n             [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n    t))))) in\n\n  let cbc =\n    add_lets\n      (mklApp cchecker_b [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*);\n                           v 2 (*t_form*); l; b; v 1 (*certif*)|])\n    |> vm_cast\n  in\n\n  let proof_cast =\n    add_lets\n      (mklApp cchecker_b_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l; b; v 1 (*certif*); cbc |]) in\n\n  let proof_nocast =\n    add_lets\n      (mklApp cchecker_b_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l; b; v 1 (*certif*)|]) in\n\n  (proof_cast, proof_nocast, cuts)\n\n\nlet build_body_eq rt ro ra rf l1 l2 l (max_id, confl) vm_cast find =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = Structures.lift 1 (make_t_func ro (v 0 (*t_i*))) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n  let (tres,_,cuts) = SmtTrace.to_coq Form.to_coq\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|])) confl find in\n  let certif =\n    mklApp cCertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*); mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let add_lets t =\n    Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n    Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(*t_i*)|]|],\n    Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n    Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n    Structures.mkLetIn (nc, certif, mklApp ccertif\n             [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n    t))))) in\n\n  let ceqc =\n    add_lets\n      (mklApp cchecker_eq [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*);\n                            v 2 (*t_form*); l1; l2; l; v 1 (*certif*)|])\n      |> vm_cast\n  in\n\n  let proof_cast =\n    add_lets\n      (mklApp cchecker_eq_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l1; l2; l; v 1 (*certif*); ceqc|])\n  in\n  let proof_nocast =\n    add_lets\n      (mklApp cchecker_eq_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l1; l2; l; v 1 (*certif*)|])\n  in\n\n  (proof_cast, proof_nocast, cuts)\n\n\nlet get_arguments concl =\n  let f, args = Structures.decompose_app concl in\n  match args with\n  | [ty;a;b] when (Structures.eq_constr f (Lazy.force ceq)) && (Structures.eq_constr ty (Lazy.force cbool)) -> a, b\n  | [a] when (Structures.eq_constr f (Lazy.force cis_true)) -> a, Lazy.force ctrue\n  | _ -> failwith (\"Verit.tactic: can only deal with equality over bool\")\n\n\nlet make_proof call_solver env rt ro ra_quant rf_quant l ls_smtc =\n  let root = SmtTrace.mkRootV [l] in\n  call_solver env rt ro ra_quant rf_quant (root,l) ls_smtc\n(* TODO: not generic anymore, the \"lemma\" part is currently specific to veriT *)\n\n(* <of_coq_lemma> reifies the given coq lemma, so we can then easily print it in a\n .smt2 file. We need the reify tables to correctly recognize free variables\n of the lemma. We also need to make sure to leave unchanged the tables because\n the new objects may contain bound (by forall of the lemma) variables. *)\n\n(* Bound variables are given fresh names to avoid variable capture *)\nlet gen_rel_name =\n  let num = ref (-1) in\n  fun () -> incr num; \"SMTCoqRelName\"^(string_of_int !num)\n\nlet of_coq_lemma rt ro ra_quant rf_quant env sigma solver_logic clemma =\n  let warn () =\n    Structures.warning \"Lemma\" (\"Discarding the following lemma (unsupported): \"^(Pp.string_of_ppcmds (Ppconstr.pr_constr_expr (Structures.extern_constr clemma))));\n    None\n  in\n\n  let rel_context, qf_lemma = Term.decompose_prod_assum clemma in\n  (* Bound variables are given fresh names to avoid variable capture *)\n  let rel_context = List.map (fun rel -> Context.Rel.Declaration.set_name (Names.Name.mk_name (Names.Id.of_string (gen_rel_name ()))) rel) rel_context in\n\n  let env_lemma = Environ.push_rel_context rel_context env in\n  let f, args = Structures.decompose_app qf_lemma in\n  let core_f =\n    if Structures.eq_constr f (Lazy.force cis_true) then\n      match args with\n      | [a] -> Some a\n      | _ -> warn ()\n    else if Structures.eq_constr f (Lazy.force ceq) then\n      match args with\n      | [ty; arg1; arg2] when Structures.eq_constr ty (Lazy.force cbool) &&\n                                Structures.eq_constr arg2 (Lazy.force ctrue) ->\n         Some arg1\n      | _ -> warn ()\n    else warn () in\n  let core_smt =\n    match core_f with\n      | Some core_f ->\n         (try\n            Some (Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env_lemma sigma) rf_quant core_f)\n          with\n            | Atom.UnknownUnderForall -> warn ()\n         )\n      | None -> None\n  in\n  let forall_args =\n    let fmap r = let n, t = Structures.destruct_rel_decl r in\n                 Structures.string_of_name n, SmtBtype.of_coq rt solver_logic t in\n    List.map fmap rel_context\n  in\n  match forall_args with\n    | [] -> core_smt\n    | _ ->\n       (match core_smt with\n          | Some core_smt -> Some (Form.get rf_quant (Fapp (Fforall forall_args, [|core_smt|])))\n          | None -> None)\n\nlet core_tactic call_solver solver_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl env sigma concl =\n  let a, b = get_arguments concl in\n\n  let tlcepl = List.map (Structures.interp_constr env sigma) lcepl in\n  let lcpl = lcpl @ tlcepl in\n\n  let create_lemma l =\n    let cl = Structures.retyping_get_type_of env sigma l in\n    match of_coq_lemma rt ro ra_quant rf_quant env sigma solver_logic cl with\n      | Some smt -> Some ((cl, l), smt)\n      | None -> None\n  in\n  let l_pl_ls = SmtMisc.filter_map create_lemma lcpl in\n  let lsmt = List.map snd l_pl_ls in\n\n  let lem_tbl : (int, Structures.constr * Structures.constr) Hashtbl.t =\n    Hashtbl.create 100 in\n  let new_ref ((l, pl), ls) =\n    Hashtbl.add lem_tbl (Form.index ls) (l, pl) in\n\n  List.iter new_ref l_pl_ls;\n\n  let find_lemma cl =\n    let re_hash hf = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant hf in\n    match cl.value with\n    | Some [l] ->\n       let hl = re_hash l in\n       begin try Hashtbl.find lem_tbl (Form.index hl)\n             with Not_found ->\n               let oc = open_out \"/tmp/find_lemma.log\" in\n               let fmt = Format.formatter_of_out_channel oc in\n               List.iter (fun u -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) u) lsmt;\n               Format.fprintf fmt \"\\n%a\\n\" (Form.to_smt ~debug:true) hl;\n               flush oc; close_out oc; failwith \"find_lemma\" end\n      | _ -> failwith \"unexpected form of root\" in\n\n  let (body_cast, body_nocast, cuts) =\n    if ((Structures.eq_constr b (Lazy.force ctrue)) ||\n        (Structures.eq_constr b (Lazy.force cfalse))) then (\n      let l = Form.of_coq (Atom.of_coq rt ro ra solver_logic env sigma) rf a in\n      let _ = Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env sigma) rf_quant a in\n      let nl = if (Structures.eq_constr b (Lazy.force ctrue)) then Form.neg l else l in\n      let lsmt = Form.flatten rf nl :: lsmt in\n      let max_id_confl = make_proof call_solver env rt ro ra_quant rf_quant nl lsmt in\n      build_body rt ro ra rf (Form.to_coq l) b max_id_confl (vm_cast env) (Some find_lemma)\n    ) else (\n      let l1 = Form.of_coq (Atom.of_coq rt ro ra solver_logic env sigma) rf a in\n      let _ = Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env sigma) rf_quant a in\n      let l2 = Form.of_coq (Atom.of_coq rt ro ra solver_logic env sigma) rf b in\n      let _ = Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env sigma) rf_quant b in\n      let l = Form.get rf (Fapp(Fiff,[|l1;l2|])) in\n      let nl = Form.neg l in\n      let lsmt = Form.flatten rf nl :: lsmt in\n      let max_id_confl = make_proof call_solver env rt ro ra_quant rf_quant nl lsmt in\n      build_body_eq rt ro ra rf (Form.to_coq l1) (Form.to_coq l2)\n        (Form.to_coq nl) max_id_confl (vm_cast env) (Some find_lemma) ) in\n\n      let cuts = (SmtBtype.get_cuts rt) @ cuts in\n\n  List.fold_right (fun (eqn, eqt) tac ->\n      Structures.tclTHENLAST\n        (Structures.assert_before (Structures.name_of_id eqn) eqt)\n        tac\n    ) cuts\n    (Structures.tclTHEN\n       (Structures.set_evars_tac body_nocast)\n       (Structures.vm_cast_no_check body_cast))\n\n\nlet tactic call_solver solver_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl =\n  Structures.tclTHEN\n    Tactics.intros\n    (Structures.mk_tactic (core_tactic call_solver solver_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl))\n\n\n(**********************************************)\n(* Show solver models as Coq counter-examples *)\n(**********************************************)\n\n\nopen SExpr\nopen Smtlib2_genConstr\nopen Format\n\n\nlet string_index_of_constr env i cf =\n  try\n    let s = string_coq_constr cf in\n    let nc = Environ.named_context env in\n    let nd = Environ.lookup_named (Structures.mkId s) env in\n    let cpt = ref 0 in\n    (try List.iter (fun n -> incr cpt; if n == nd then raise Exit) nc\n     with Exit -> ());\n    s, !cpt\n  with _ -> string_coq_constr cf, -i\n\n\nlet vstring_i env i =\n  let cf = SmtAtom.Atom.get_coq_term_op i in\n  if Structures.isRel cf then\n    let dbi = Structures.destRel cf in\n    let s =\n      Environ.lookup_rel dbi env\n      |> Structures.get_rel_dec_name\n      |> SmtMisc.string_of_name_def \"?\"\n    in\n    s, dbi\n  else\n    string_index_of_constr env i cf\n\n\nlet sstring_i env i v =\n  let tf = SmtBtype.get_coq_type_op i in\n  let (s, idx) = string_index_of_constr env i tf in\n  (s^\"#\"^v, idx)\n\n\nlet smt2_id_to_coq_string env t_i ra rf name =\n  try\n    let l = String.split_on_char '_' name in\n    match l with\n      | [\"op\"; i] -> vstring_i env (int_of_string i)\n      | [\"@uc\"; \"Tindex\"; i; j] -> sstring_i env (int_of_string i) j\n      | _ -> raise Not_found\n  with _ -> (name, 0)\n\n\nlet op_to_coq_string op = match op with\n  | \"=\" | \"+\" | \"-\" | \"*\" | \"/\" -> op\n  | \"or\" -> \"||\"\n  | \"and\" -> \"&&\"\n  | \"xor\" -> \"xorb\"\n  | \"=>\" -> \"implb\"\n  | _ -> op\n\n\nlet coq_bv_string s =\n  let rec aux acc = function\n    | true :: r -> aux (acc ^ \"|1\") r\n    | false :: r -> aux (acc ^ \"|0\") r\n    | [] -> \"#b\" ^ acc ^ \"|\"\n  in\n  if String.length s < 3 ||\n     not (s.[0] = '#' && s.[1] = 'b') then failwith \"not bv\";\n  aux \"\" (parse_smt2bv s)\n\n\nlet is_bvint bs =\n  try Scanf.sscanf bs \"bv%s\" (fun s ->\n      try ignore (Big_int.big_int_of_string s); true\n      with _ -> false)\n  with _ -> false\n\n\nlet rec smt2_sexpr_to_coq_string env t_i ra rf =\n  let open SExpr in function\n  | Atom \"true\" -> \"true\"\n  | Atom \"false\" -> \"false\"\n  | Atom s ->\n    (try ignore (int_of_string s); s\n     with Failure _ ->\n     try coq_bv_string s\n     with Failure _ ->\n     try fst (smt2_id_to_coq_string env t_i ra rf s)\n     with _ -> s)\n  | List [Atom \"as\"; Atom \"const\"; _] -> \"const_farray\"\n  | List [Atom \"as\"; s; _] -> smt2_sexpr_to_coq_string env t_i ra rf s\n  | List [Atom \"_\"; Atom bs; Atom s] when is_bvint bs ->\n    Scanf.sscanf bs \"bv%s\" (fun i ->\n        coq_bv_string (bigint_bv (Big_int.big_int_of_string i)\n                         (int_of_string s)))\n  | List [Atom \"-\"; Atom _ as s] ->\n    sprintf \"-%s\"\n      (smt2_sexpr_to_coq_string env t_i ra rf s)\n  | List [Atom \"-\"; s] ->\n    sprintf \"(- %s)\"\n      (smt2_sexpr_to_coq_string env t_i ra rf s)\n  | List [Atom ((\"+\"|\"-\"|\"*\"|\"/\"|\"or\"|\"and\"|\"=\") as op); s1; s2] ->\n    sprintf \"%s %s %s\"\n      (smt2_sexpr_to_coq_string env t_i ra rf s1)\n      (op_to_coq_string op)\n      (smt2_sexpr_to_coq_string env t_i ra rf s2)\n  | List [Atom ((\"xor\"|\"=>\"|\"\") as op); s1; s2] ->\n    sprintf \"(%s %s %s)\"\n      (op_to_coq_string op)\n      (smt2_sexpr_to_coq_string env t_i ra rf s1)\n      (smt2_sexpr_to_coq_string env t_i ra rf s2)\n  | List [Atom \"select\"; a; i] ->\n    sprintf \"%s[%s]\"\n      (smt2_sexpr_to_coq_string env t_i ra rf a)\n      (smt2_sexpr_to_coq_string env t_i ra rf i)\n  | List [Atom \"store\"; a; i; v] ->\n    sprintf \"%s[%s <- %s]\"\n      (smt2_sexpr_to_coq_string env t_i ra rf a)\n      (smt2_sexpr_to_coq_string env t_i ra rf i)\n      (smt2_sexpr_to_coq_string env t_i ra rf v)\n  | List [Atom \"ite\"; c; s1; s2] ->\n    sprintf \"if %s then %s else %s\"\n      (smt2_sexpr_to_coq_string env t_i ra rf c)\n      (smt2_sexpr_to_coq_string env t_i ra rf s1)\n      (smt2_sexpr_to_coq_string env t_i ra rf s2)\n  | List l ->\n    sprintf \"(%s)\"\n      (String.concat \" \" (List.map (smt2_sexpr_to_coq_string env t_i ra rf) l))\n\n\nlet str_contains s1 s2 =\n  let re = Str.regexp_string s2 in\n  try ignore (Str.search_forward re s1 0); true\n  with Not_found -> false\n\nlet lambda_to_coq_string l s =\n  Format.sprintf \"fun %s => %s\"\n    (String.concat \" \"\n       (List.map (function\n            | List [Atom v; _] ->\n              if str_contains s v then v else \"_\"\n            | _ -> assert false) l))\n    s\n\ntype model =\n  | Fun of ((string * int) * string)\n  | Sort\n\nlet model_item env rt ro ra rf =\n  let t_i = make_t_i rt in\n  function\n  | List [Atom \"define-fun\"; Atom n; List []; _; expr] ->\n     Fun (smt2_id_to_coq_string env t_i ra rf n,\n           smt2_sexpr_to_coq_string env t_i ra rf expr)\n\n  | List [Atom \"define-fun\"; Atom n; List l; _; expr] ->\n     Fun (smt2_id_to_coq_string env t_i ra rf n,\n           lambda_to_coq_string l\n             (smt2_sexpr_to_coq_string env t_i ra rf expr))\n\n  | List [Atom \"declare-sort\"; Atom n; _] ->\n     Sort\n\n  | l ->\n     (* let out = open_out_gen [Open_append] 700 \"/tmp/test.log\" in\n      * let outf = Format.formatter_of_out_channel out in\n      * SExpr.print outf l; pp_print_flush outf ();\n      * close_out out; *)\n     Structures.error (\"Could not reconstruct model\")\n\n\nlet model env rt ro ra rf = function\n  | List (Atom \"model\" :: l) ->\n     List.fold_left (fun acc m -> match model_item env rt ro ra rf m with Fun m -> m::acc | Sort -> acc) [] l\n     |> List.sort (fun ((_ ,i1), _) ((_, i2), _) -> i2 - i1)\n  | _ -> Structures.error (\"No model\")\n\n\nlet model_string env rt ro ra rf s =\n  String.concat \"\\n\"\n    (List.map (fun ((x, _) ,v) -> Format.sprintf \"%s := %s\" x v)\n       (model env rt ro ra rf s))\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":260,"character":0},"end":{"line":316,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":185,"character":28},"end":{"line":185,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00309944152832ms
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 7, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":177,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":179,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.00715255737305ms
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Coqlib\nopen SmtMisc\n\n\nlet gen_constant = Structures.gen_constant\n\n\n(* Int63 *)\nlet cint = Structures.cint\nlet ceq63 = gen_constant Structures.int63_modules \"eqb\"\n\n(* PArray *)\nlet carray = gen_constant Structures.parray_modules \"array\"\n\n(* is_true *)\nlet cis_true = gen_constant init_modules \"is_true\"\n\n(* nat *)\nlet cnat = gen_constant init_modules \"nat\"\nlet cO = gen_constant init_modules \"O\"\nlet cS = gen_constant init_modules \"S\"\n\n(* Positive *)\nlet positive_modules = [[\"Coq\";\"Numbers\";\"BinNums\"];\n                        [\"Coq\";\"PArith\";\"BinPosDef\";\"Pos\"]]\n\nlet cpositive = gen_constant positive_modules \"positive\"\nlet cxI = gen_constant positive_modules \"xI\"\nlet cxO = gen_constant positive_modules \"xO\"\nlet cxH = gen_constant positive_modules \"xH\"\nlet ceqbP = gen_constant positive_modules \"eqb\"\n\n(* N *)\nlet n_modules = [[\"Coq\";\"NArith\";\"BinNat\";\"N\"]]\n\nlet cN = gen_constant positive_modules \"N\"\nlet cN0 = gen_constant positive_modules \"N0\"\nlet cNpos = gen_constant positive_modules \"Npos\"\n\nlet cof_nat = gen_constant n_modules \"of_nat\"\n\n\n(* Z *)\nlet z_modules = [[\"Coq\";\"Numbers\";\"BinNums\"];\n                 [\"Coq\";\"ZArith\";\"BinInt\"];\n                 [\"Coq\";\"ZArith\";\"BinInt\";\"Z\"]]\n\nlet cZ = gen_constant z_modules \"Z\"\nlet cZ0 = gen_constant z_modules \"Z0\"\nlet cZpos = gen_constant z_modules \"Zpos\"\nlet cZneg = gen_constant z_modules \"Zneg\"\nlet copp = gen_constant z_modules \"opp\"\nlet cadd = gen_constant z_modules \"add\"\nlet csub = gen_constant z_modules \"sub\"\nlet cmul = gen_constant z_modules \"mul\"\nlet cltb = gen_constant z_modules \"ltb\"\nlet cleb = gen_constant z_modules \"leb\"\nlet cgeb = gen_constant z_modules \"geb\"\nlet cgtb = gen_constant z_modules \"gtb\"\nlet ceqbZ = gen_constant z_modules \"eqb\"\n(* let cZeqbsym = gen_constant z_modules \"eqb_sym\" *)\n\n(* Booleans *)\nlet bool_modules = [[\"Coq\";\"Bool\";\"Bool\"]]\n\nlet cbool = gen_constant init_modules \"bool\"\nlet ctrue = gen_constant init_modules \"true\"\nlet cfalse = gen_constant init_modules \"false\"\nlet candb = gen_constant init_modules \"andb\"\nlet corb = gen_constant init_modules \"orb\"\nlet cxorb = gen_constant init_modules \"xorb\"\nlet cnegb = gen_constant init_modules \"negb\"\nlet cimplb = gen_constant init_modules \"implb\"\nlet ceqb = gen_constant  bool_modules \"eqb\"\nlet cifb = gen_constant bool_modules \"ifb\"\nlet ciff = gen_constant init_modules \"iff\"\nlet creflect = gen_constant bool_modules \"reflect\"\n\n(* Lists *)\nlet clist = gen_constant init_modules \"list\"\nlet cnil = gen_constant init_modules \"nil\"\nlet ccons = gen_constant init_modules \"cons\"\nlet clength = gen_constant init_modules \"length\"\n\n(* Option *)\nlet coption = gen_constant init_modules \"option\"\nlet cSome = gen_constant init_modules \"Some\"\nlet cNone = gen_constant init_modules \"None\"\n\n(* Pairs *)\nlet cpair = gen_constant init_modules \"pair\"\nlet cprod = gen_constant init_modules \"prod\"\n\n(* Dependent pairs *)\nlet csigT = gen_constant init_modules \"sigT\"\n(* let cprojT1 = gen_constant init_modules \"projT1\" *)\n(* let cprojT2 = gen_constant init_modules \"projT2\" *)\n(* let cprojT3 = gen_constant init_modules \"projT3\" *)\n\n(* let csigT2 = gen_constant init_modules \"sigT2\" *)\n(* let csigT_of_sigT2 = gen_constant init_modules \"sigT_of_sigT2\" *)\n\n(* Logical Operators *)\nlet cnot = gen_constant init_modules \"not\"\nlet ceq = gen_constant init_modules \"eq\"\nlet crefl_equal = gen_constant init_modules \"eq_refl\"\nlet cconj = gen_constant init_modules \"conj\"\nlet cand = gen_constant init_modules \"and\"\n\n(* Bit vectors *)\nlet bv_modules = [[\"SMTCoq\";\"bva\";\"BVList\";\"BITVECTOR_LIST\"]]\nlet cbitvector = gen_constant bv_modules \"bitvector\"\nlet cof_bits = gen_constant bv_modules \"of_bits\"\n(* let c_of_bits = gen_constant bv_modules \"_of_bits\" *)\nlet cbitOf = gen_constant bv_modules \"bitOf\"\nlet cbv_eq = gen_constant bv_modules \"bv_eq\"\nlet cbv_not = gen_constant bv_modules \"bv_not\"\nlet cbv_neg = gen_constant bv_modules \"bv_neg\"\nlet cbv_and = gen_constant bv_modules \"bv_and\"\nlet cbv_or = gen_constant bv_modules \"bv_or\"\nlet cbv_xor = gen_constant bv_modules \"bv_xor\"\nlet cbv_add = gen_constant bv_modules \"bv_add\"\nlet cbv_mult = gen_constant bv_modules \"bv_mult\"\nlet cbv_ult = gen_constant bv_modules \"bv_ult\"\nlet cbv_slt = gen_constant bv_modules \"bv_slt\"\nlet cbv_concat = gen_constant bv_modules \"bv_concat\"\nlet cbv_extr = gen_constant bv_modules \"bv_extr\"\nlet cbv_zextn = gen_constant bv_modules \"bv_zextn\"\nlet cbv_sextn = gen_constant bv_modules \"bv_sextn\"\nlet cbv_shl = gen_constant bv_modules \"bv_shl\"\nlet cbv_shr = gen_constant bv_modules \"bv_shr\"\n\n\n(* Arrays *)\nlet array_modules = [[\"SMTCoq\";\"array\";\"FArray\"]]\nlet cfarray = gen_constant array_modules \"FArray.farray\"\nlet cselect = gen_constant array_modules \"select\"\nlet cstore = gen_constant array_modules \"store\"\nlet cdiff = gen_constant array_modules \"diff\"\nlet cequalarray = gen_constant array_modules \"FArray.equal\"\n\n(* OrderedType *)\n(* let cOrderedTypeCompare =\n *   gen_constant [[\"Coq\";\"Structures\";\"OrderedType\"]] \"Compare\" *)\n\n(* SMT_terms *)\nlet smt_modules = [ [\"SMTCoq\";\"Misc\"];\n\t\t    [\"SMTCoq\";\"State\"];\n\t\t    [\"SMTCoq\";\"SMT_terms\"];\n\t\t    [\"SMTCoq\";\"SMT_terms\";\"Typ\"];\n\t\t    [\"SMTCoq\";\"SMT_terms\";\"Form\"];\n\t\t    [\"SMTCoq\";\"SMT_terms\";\"Atom\"]\n\t\t  ]\n\nlet cState_C_t = gen_constant [[\"SMTCoq\";\"State\";\"C\"]] \"t\"\nlet cState_S_t = gen_constant [[\"SMTCoq\";\"State\";\"S\"]] \"t\"\n\nlet cdistinct = gen_constant smt_modules \"distinct\"\n\nlet ctype = gen_constant smt_modules \"type\"\nlet cTZ = gen_constant smt_modules \"TZ\"\nlet cTbool = gen_constant smt_modules \"Tbool\"\nlet cTpositive = gen_constant smt_modules \"Tpositive\"\nlet cTBV = gen_constant smt_modules \"TBV\"\nlet cTFArray = gen_constant smt_modules \"TFArray\"\nlet cTindex = gen_constant smt_modules \"Tindex\"\n\n(* let ct_i = gen_constant smt_modules \"t_i\" *)\nlet cinterp_t = gen_constant smt_modules \"Typ.interp\"\nlet cdec_interp = gen_constant smt_modules \"dec_interp\"\nlet cord_interp = gen_constant smt_modules \"ord_interp\"\nlet ccomp_interp = gen_constant smt_modules \"comp_interp\"\nlet cinh_interp = gen_constant smt_modules \"inh_interp\"\n\nlet cinterp_eqb = gen_constant smt_modules \"i_eqb\"\n(* let cinterp_eqb_eqb = gen_constant smt_modules \"i_eqb_eqb\" *)\n\nlet classes_modules = [[\"SMTCoq\";\"classes\";\"SMT_classes\"];\n                       [\"SMTCoq\";\"classes\";\"SMT_classes_instances\"]]\n\nlet ctyp_compdec = gen_constant classes_modules \"typ_compdec\"\nlet cTyp_compdec = gen_constant classes_modules \"Typ_compdec\"\n(* let ctyp_compdec_from = gen_constant classes_modules \"typ_compdec_from\" *)\nlet cunit_typ_compdec = gen_constant classes_modules \"unit_typ_compdec\"\nlet cte_carrier = gen_constant classes_modules \"te_carrier\"\nlet cte_compdec = gen_constant classes_modules \"te_compdec\"\nlet ceqb_of_compdec = gen_constant classes_modules \"eqb_of_compdec\"\nlet cCompDec = gen_constant classes_modules \"CompDec\"\n\nlet cbool_compdec = gen_constant classes_modules \"bool_compdec\"\nlet cZ_compdec = gen_constant classes_modules \"Z_compdec\"\nlet cPositive_compdec = gen_constant classes_modules \"Positive_compdec\"\nlet cBV_compdec = gen_constant classes_modules \"BV_compdec\"\nlet cFArray_compdec = gen_constant classes_modules \"FArray_compdec\"\n\nlet ctval =  gen_constant smt_modules \"tval\"\nlet cTval =  gen_constant smt_modules \"Tval\"\n\nlet cCO_xH = gen_constant smt_modules \"CO_xH\"\nlet cCO_Z0 = gen_constant smt_modules \"CO_Z0\"\nlet cCO_BV = gen_constant smt_modules \"CO_BV\"\n\nlet cUO_xO = gen_constant smt_modules \"UO_xO\"\nlet cUO_xI = gen_constant smt_modules \"UO_xI\"\nlet cUO_Zpos = gen_constant smt_modules \"UO_Zpos\"\nlet cUO_Zneg = gen_constant smt_modules \"UO_Zneg\"\nlet cUO_Zopp = gen_constant smt_modules \"UO_Zopp\"\nlet cUO_BVbitOf = gen_constant smt_modules \"UO_BVbitOf\"\nlet cUO_BVnot = gen_constant smt_modules \"UO_BVnot\"\nlet cUO_BVneg = gen_constant smt_modules \"UO_BVneg\"\nlet cUO_BVextr = gen_constant smt_modules \"UO_BVextr\"\nlet cUO_BVzextn = gen_constant smt_modules \"UO_BVzextn\"\nlet cUO_BVsextn = gen_constant smt_modules \"UO_BVsextn\"\n\nlet cBO_Zplus = gen_constant smt_modules \"BO_Zplus\"\nlet cBO_Zminus = gen_constant smt_modules \"BO_Zminus\"\nlet cBO_Zmult = gen_constant smt_modules \"BO_Zmult\"\nlet cBO_Zlt = gen_constant smt_modules \"BO_Zlt\"\nlet cBO_Zle = gen_constant smt_modules \"BO_Zle\"\nlet cBO_Zge = gen_constant smt_modules \"BO_Zge\"\nlet cBO_Zgt = gen_constant smt_modules \"BO_Zgt\"\nlet cBO_eq = gen_constant smt_modules \"BO_eq\"\nlet cBO_BVand = gen_constant smt_modules \"BO_BVand\"\nlet cBO_BVor = gen_constant smt_modules \"BO_BVor\"\nlet cBO_BVxor = gen_constant smt_modules \"BO_BVxor\"\nlet cBO_BVadd = gen_constant smt_modules \"BO_BVadd\"\nlet cBO_BVmult = gen_constant smt_modules \"BO_BVmult\"\nlet cBO_BVult = gen_constant smt_modules \"BO_BVult\"\nlet cBO_BVslt = gen_constant smt_modules \"BO_BVslt\"\nlet cBO_BVconcat = gen_constant smt_modules \"BO_BVconcat\"\nlet cBO_BVshl = gen_constant smt_modules \"BO_BVshl\"\nlet cBO_BVshr = gen_constant smt_modules \"BO_BVshr\"\nlet cBO_select = gen_constant smt_modules \"BO_select\"\nlet cBO_diffarray = gen_constant smt_modules \"BO_diffarray\"\n\nlet cTO_store = gen_constant smt_modules \"TO_store\"\n\nlet cNO_distinct = gen_constant smt_modules \"NO_distinct\"\n\nlet catom = gen_constant smt_modules \"atom\"\nlet cAcop = gen_constant smt_modules \"Acop\"\nlet cAuop = gen_constant smt_modules \"Auop\"\nlet cAbop = gen_constant smt_modules \"Abop\"\nlet cAtop = gen_constant smt_modules \"Atop\"\nlet cAnop = gen_constant smt_modules \"Anop\"\nlet cAapp = gen_constant smt_modules \"Aapp\"\n\nlet cform  = gen_constant smt_modules \"form\"\nlet cFatom = gen_constant smt_modules \"Fatom\"\nlet cFtrue = gen_constant smt_modules \"Ftrue\"\nlet cFfalse = gen_constant smt_modules \"Ffalse\"\nlet cFnot2 = gen_constant smt_modules \"Fnot2\"\nlet cFand = gen_constant smt_modules \"Fand\"\nlet cFor = gen_constant smt_modules \"For\"\nlet cFxor = gen_constant smt_modules \"Fxor\"\nlet cFimp = gen_constant smt_modules \"Fimp\"\nlet cFiff = gen_constant smt_modules \"Fiff\"\nlet cFite = gen_constant smt_modules \"Fite\"\nlet cFbbT = gen_constant smt_modules \"FbbT\"\n\nlet cvalid_sat_checker = gen_constant [[\"SMTCoq\";\"Trace\";\"Sat_Checker\"]] \"valid\"\nlet cinterp_var_sat_checker = gen_constant [[\"SMTCoq\";\"Trace\";\"Sat_Checker\"]] \"interp_var\"\n\nlet make_certif_ops modules args =\n  let gen_constant c =\n    match args with\n      | Some args -> lazy (mklApp (gen_constant modules c) args)\n      | None -> gen_constant modules c in\n (gen_constant \"step\",\n  gen_constant \"Res\", gen_constant \"Weaken\", gen_constant \"ImmFlatten\",\n  gen_constant \"CTrue\", gen_constant \"CFalse\",\n  gen_constant \"BuildDef\", gen_constant \"BuildDef2\",\n  gen_constant \"BuildProj\",\n  gen_constant \"ImmBuildProj\", gen_constant\"ImmBuildDef\",\n  gen_constant\"ImmBuildDef2\",\n  gen_constant \"EqTr\", gen_constant \"EqCgr\", gen_constant \"EqCgrP\",\n  gen_constant \"LiaMicromega\", gen_constant \"LiaDiseq\",\n  gen_constant \"SplArith\", gen_constant \"SplDistinctElim\",\n  gen_constant \"BBVar\", gen_constant \"BBConst\",\n  gen_constant \"BBOp\", gen_constant \"BBNot\", gen_constant \"BBEq\",\n  gen_constant \"BBDiseq\",\n  gen_constant \"BBNeg\", gen_constant \"BBAdd\", gen_constant \"BBMul\",\n  gen_constant \"BBUlt\", gen_constant \"BBSlt\", gen_constant \"BBConcat\",\n  gen_constant \"BBExtract\", gen_constant \"BBZextend\", gen_constant \"BBSextend\",\n  gen_constant \"BBShl\", gen_constant \"BBShr\",\n  gen_constant \"RowEq\", gen_constant \"RowNeq\", gen_constant \"Ext\",\n  gen_constant \"Hole\", gen_constant \"ForallInst\")\n\n\n(** Useful constructions *)\n\nlet ceq_refl_true =\n  lazy (mklApp crefl_equal [|Lazy.force cbool;Lazy.force ctrue|])\n\nlet eq_refl_true () = Lazy.force ceq_refl_true\n\nlet vm_cast_true_no_check t =\n  Structures.mkCast(eq_refl_true (),\n              Structures.vmcast,\n              mklApp ceq [|Lazy.force cbool; t; Lazy.force ctrue|])\n\n(* This version checks convertibility right away instead of delaying it at\n   Qed. This allows to report issues to the user as soon as he/she runs one of\n   SMTCoq's tactics. *)\nlet vm_cast_true env t =\n  try\n    Structures.vm_conv Reduction.CUMUL env\n      (mklApp ceq\n         [|Lazy.force cbool; Lazy.force ctrue; Lazy.force ctrue|])\n      (mklApp ceq [|Lazy.force cbool; t; Lazy.force ctrue|]);\n    vm_cast_true_no_check t\n  with Reduction.NotConvertible ->\n    Structures.error (\"SMTCoq was not able to check the proof certificate.\")\n\n\n(* Compute a nat *)\nlet rec mkNat = function\n  | 0 -> Lazy.force cO\n  | i -> mklApp cS [|mkNat (i-1)|]\n\n(* Compute a positive *)\nlet rec mkPositive = function\n  | 1 -> Lazy.force cxH\n  | i ->\n     let c = if (i mod 2) = 0 then cxO else cxI in\n     mklApp c [|mkPositive (i / 2)|]\n\n(* Compute a N *)\nlet mkN = function\n  | 0 -> Lazy.force cN0\n  | i -> mklApp cNpos [|mkPositive i|]\n\n(* Compute a Boolean *)\nlet mkBool = function\n  | true -> Lazy.force ctrue\n  | false -> Lazy.force cfalse\n\n(* Compute a Boolean list *)\nlet rec mk_bv_list = function\n  | [] -> mklApp cnil [|Lazy.force cbool|]\n  | b :: bv ->\n    mklApp ccons [|Lazy.force cbool; mkBool b; mk_bv_list bv|]\n\n\n(* Reification *)\nlet mk_bool b =\n  let c, args = Structures.decompose_app b in\n  if Structures.eq_constr c (Lazy.force ctrue) then true\n  else if Structures.eq_constr c (Lazy.force cfalse) then false\n  else assert false\n\nlet rec mk_bool_list bs =\n  let c, args = Structures.decompose_app bs in\n  if Structures.eq_constr c (Lazy.force cnil) then []\n  else if Structures.eq_constr c (Lazy.force ccons) then\n    match args with\n    | [_; b; bs] -> mk_bool b :: mk_bool_list bs\n    | _ -> assert false\n  else assert false\n\nlet rec mk_nat n =\n  let c, args = Structures.decompose_app n in\n  if Structures.eq_constr c (Lazy.force cO) then\n    0\n  else if Structures.eq_constr c (Lazy.force cS) then\n    match args with\n    | [n] -> (mk_nat n) + 1\n    | _ -> assert false\n  else assert false\n\nlet rec mk_positive n =\n  let c, args = Structures.decompose_app n in\n  if Structures.eq_constr c (Lazy.force cxH) then\n    1\n  else if Structures.eq_constr c (Lazy.force cxO) then\n    match args with\n    | [n] -> 2 * (mk_positive n)\n    | _ -> assert false\n  else if Structures.eq_constr c (Lazy.force cxI) then\n    match args with\n    | [n] -> 2 * (mk_positive n) + 1\n    | _ -> assert false\n  else assert false\n\n\nlet mk_N n =\n  let c, args = Structures.decompose_app n in\n  if Structures.eq_constr c (Lazy.force cN0) then\n    0\n  else if Structures.eq_constr c (Lazy.force cNpos) then\n    match args with\n    | [n] -> mk_positive n\n    | _ -> assert false\n  else assert false\n\n\nlet mk_Z n =\n  let c, args = Structures.decompose_app n in\n  if Structures.eq_constr c (Lazy.force cZ0) then 0\n  else if Structures.eq_constr c (Lazy.force cZpos) then\n    match args with\n    | [n] -> mk_positive n\n    | _ -> assert false\n  else if Structures.eq_constr c (Lazy.force cZneg) then\n    match args with\n    | [n] -> - mk_positive n\n    | _ -> assert false\n  else assert false\n\n\n(* size of bivectors are either N.of_nat (length l) or an N *)\nlet mk_bvsize n =\n  let c, args = Structures.decompose_app n in\n  if Structures.eq_constr c (Lazy.force cof_nat) then\n    match args with\n    | [nl] ->\n      let c, args = Structures.decompose_app nl in\n      if Structures.eq_constr c (Lazy.force clength) then\n        match args with\n        | [_; l] -> List.length (mk_bool_list l)\n        | _ -> assert false\n      else assert false\n    | _ -> assert false\n  else mk_N n\n\n(** Switches between constr and OCaml *)\n(* Transform a option constr into a constr option *)\nlet option_of_constr_option co =\n  let c, args = Structures.decompose_app co in\n  if c = Lazy.force cSome then\n    match args with\n      | [_;c] -> Some c\n      | _ -> assert false\n  else\n    None\n\n(* Transform a tuple of constr into a (reversed) list of constr *)\nlet list_of_constr_tuple =\n  let rec list_of_constr_tuple acc t =\n    let c, args = Structures.decompose_app t in\n    if c = Lazy.force cpair then\n      match args with\n        | [_;_;t1;t2] ->\n           let acc' = list_of_constr_tuple acc t1 in\n           list_of_constr_tuple acc' t2\n        | _ -> assert false\n    else\n      t::acc\n  in\n  list_of_constr_tuple []\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 12, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/satAtom.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\n\nmodule Atom = \n  struct \n\n    type t = int \n\n    let index a = a\n\n    let equal a1 a2 = a1 == a2\n\n    let is_bool_type a = true\n    let is_bv_type a = false\n\n    type reify_tbl =\n        { mutable count : int;\n\t          tbl : (Structures.constr, int) Hashtbl.t\n\t}\n\n    let create () = \n      { count = 0;\n\ttbl =  Hashtbl.create 17 }\n\n    let declare reify a = \n      let res = reify.count in\n      Hashtbl.add reify.tbl a res;\n      reify.count <- res + 1;\n      res\n\n    let get reify a =\n      try Hashtbl.find reify.tbl a \n      with Not_found -> declare reify a\n\n    let atom_tbl reify =\n      let t = Array.make (reify.count + 1) (Lazy.force ctrue) in\n      let set c i = t.(i) <- c in\n      Hashtbl.iter set reify.tbl;\n      t\n\n    let interp_tbl reify =\n      Structures.mkArray (Lazy.force cbool, atom_tbl reify)\n\n    let logic _ = SL.empty\n\n    let to_smt = Format.pp_print_int\n    \n  end\n\nmodule Form = SmtForm.Make(Atom)\nmodule Trace = SmtTrace.MakeOpt(Form)\nmodule Cnf = SmtCnf.MakeCnf(Form)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/satAtom.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/satAtom.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/satAtom.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 15, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/satAtom.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.046968460083ms
Sending response {"id": 16, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/satAtom.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval gen_constant : string list list -> string -> Structures.constr lazy_t\n\n(* Int63 *)\nval cint : Structures.constr lazy_t\nval ceq63 : Structures.constr lazy_t\n\n(* PArray *)\nval carray : Structures.constr lazy_t\n\n(* nat *)\nval cnat : Structures.constr lazy_t\nval cO : Structures.constr lazy_t\nval cS : Structures.constr lazy_t\n\n(* Positive *)\nval cpositive : Structures.constr lazy_t\nval cxI : Structures.constr lazy_t\nval cxO : Structures.constr lazy_t\nval cxH : Structures.constr lazy_t\nval ceqbP : Structures.constr lazy_t\n\n(* N *)\nval cN : Structures.constr lazy_t\nval cN0 : Structures.constr lazy_t\nval cNpos : Structures.constr lazy_t\nval cof_nat : Structures.constr lazy_t\n\n(* Z *)\nval cZ : Structures.constr lazy_t\nval cZ0 : Structures.constr lazy_t\nval cZpos : Structures.constr lazy_t\nval cZneg : Structures.constr lazy_t\nval copp : Structures.constr lazy_t\nval cadd : Structures.constr lazy_t\nval csub : Structures.constr lazy_t\nval cmul : Structures.constr lazy_t\nval cltb : Structures.constr lazy_t\nval cleb : Structures.constr lazy_t\nval cgeb : Structures.constr lazy_t\nval cgtb : Structures.constr lazy_t\nval ceqbZ : Structures.constr lazy_t\n\n(* Booleans *)\nval cbool : Structures.constr lazy_t\nval ctrue : Structures.constr lazy_t\nval cfalse : Structures.constr lazy_t\nval candb : Structures.constr lazy_t\nval corb : Structures.constr lazy_t\nval cxorb : Structures.constr lazy_t\nval cnegb : Structures.constr lazy_t\nval cimplb : Structures.constr lazy_t\nval ceqb : Structures.constr lazy_t\nval cifb : Structures.constr lazy_t\nval ciff : Structures.constr lazy_t\nval creflect : Structures.constr lazy_t\n\n(* Lists *)\nval clist : Structures.constr lazy_t\nval cnil : Structures.constr lazy_t\nval ccons : Structures.constr lazy_t\nval clength : Structures.constr lazy_t\n\n(* Option *)\nval coption : Structures.constr lazy_t\nval cSome : Structures.constr lazy_t\nval cNone : Structures.constr lazy_t\n\n(* Pairs *)\nval cpair : Structures.constr lazy_t\nval cprod : Structures.constr lazy_t\n\n(* Dependent pairs *)\nval csigT : Structures.constr lazy_t\n\n(* Logical Operators *)\nval cnot : Structures.constr lazy_t\nval ceq : Structures.constr lazy_t\nval crefl_equal : Structures.constr lazy_t\nval cconj : Structures.constr lazy_t\nval cand : Structures.constr lazy_t\n\n(* Bit vectors *)\nval cbitvector : Structures.constr lazy_t\nval cof_bits : Structures.constr lazy_t\nval cbitOf : Structures.constr lazy_t\nval cbv_eq : Structures.constr lazy_t\nval cbv_not : Structures.constr lazy_t\nval cbv_neg : Structures.constr lazy_t\nval cbv_and : Structures.constr lazy_t\nval cbv_or : Structures.constr lazy_t\nval cbv_xor : Structures.constr lazy_t\nval cbv_add : Structures.constr lazy_t\nval cbv_mult : Structures.constr lazy_t\nval cbv_ult : Structures.constr lazy_t\nval cbv_slt : Structures.constr lazy_t\nval cbv_concat : Structures.constr lazy_t\nval cbv_extr : Structures.constr lazy_t\nval cbv_zextn : Structures.constr lazy_t\nval cbv_sextn : Structures.constr lazy_t\nval cbv_shl : Structures.constr lazy_t\nval cbv_shr : Structures.constr lazy_t\n\n(* Arrays *)\nval cfarray : Structures.constr lazy_t\nval cselect : Structures.constr lazy_t\nval cstore : Structures.constr lazy_t\nval cdiff : Structures.constr lazy_t\nval cequalarray : Structures.constr lazy_t\n\n(* OrderedType *)\n\n(* SMT_terms *)\nval cState_C_t : Structures.constr lazy_t\nval cState_S_t : Structures.constr lazy_t\n\nval cdistinct : Structures.constr lazy_t\n\nval ctype : Structures.constr lazy_t\nval cTZ : Structures.constr lazy_t\nval cTbool : Structures.constr lazy_t\nval cTpositive : Structures.constr lazy_t\nval cTBV : Structures.constr lazy_t\nval cTFArray : Structures.constr lazy_t\nval cTindex : Structures.constr lazy_t\n\nval cinterp_t : Structures.constr lazy_t\nval cdec_interp : Structures.constr lazy_t\nval cord_interp : Structures.constr lazy_t\nval ccomp_interp : Structures.constr lazy_t\nval cinh_interp : Structures.constr lazy_t\n\nval cinterp_eqb : Structures.constr lazy_t\n\nval ctyp_compdec : Structures.constr lazy_t\nval cTyp_compdec : Structures.constr lazy_t\nval cunit_typ_compdec : Structures.constr lazy_t\nval cte_carrier : Structures.constr lazy_t\nval cte_compdec : Structures.constr lazy_t\nval ceqb_of_compdec : Structures.constr lazy_t\nval cCompDec : Structures.constr lazy_t\n\nval cbool_compdec : Structures.constr lazy_t\nval cZ_compdec : Structures.constr lazy_t\nval cPositive_compdec : Structures.constr lazy_t\nval cBV_compdec : Structures.constr lazy_t\nval cFArray_compdec : Structures.constr lazy_t\n\nval ctval : Structures.constr lazy_t\nval cTval : Structures.constr lazy_t\n\nval cCO_xH : Structures.constr lazy_t\nval cCO_Z0 : Structures.constr lazy_t\nval cCO_BV : Structures.constr lazy_t\n\nval cUO_xO : Structures.constr lazy_t\nval cUO_xI : Structures.constr lazy_t\nval cUO_Zpos : Structures.constr lazy_t\nval cUO_Zneg : Structures.constr lazy_t\nval cUO_Zopp : Structures.constr lazy_t\nval cUO_BVbitOf : Structures.constr lazy_t\nval cUO_BVnot : Structures.constr lazy_t\nval cUO_BVneg : Structures.constr lazy_t\nval cUO_BVextr : Structures.constr lazy_t\nval cUO_BVzextn : Structures.constr lazy_t\nval cUO_BVsextn : Structures.constr lazy_t\n\nval cBO_Zplus : Structures.constr lazy_t\nval cBO_Zminus : Structures.constr lazy_t\nval cBO_Zmult : Structures.constr lazy_t\nval cBO_Zlt : Structures.constr lazy_t\nval cBO_Zle : Structures.constr lazy_t\nval cBO_Zge : Structures.constr lazy_t\nval cBO_Zgt : Structures.constr lazy_t\nval cBO_eq : Structures.constr lazy_t\nval cBO_BVand : Structures.constr lazy_t\nval cBO_BVor : Structures.constr lazy_t\nval cBO_BVxor : Structures.constr lazy_t\nval cBO_BVadd : Structures.constr lazy_t\nval cBO_BVmult : Structures.constr lazy_t\nval cBO_BVult : Structures.constr lazy_t\nval cBO_BVslt : Structures.constr lazy_t\nval cBO_BVconcat : Structures.constr lazy_t\nval cBO_BVshl : Structures.constr lazy_t\nval cBO_BVshr : Structures.constr lazy_t\nval cBO_select : Structures.constr lazy_t\nval cBO_diffarray : Structures.constr lazy_t\n\nval cTO_store : Structures.constr lazy_t\n\nval cNO_distinct : Structures.constr lazy_t\n\nval catom : Structures.constr lazy_t\nval cAcop : Structures.constr lazy_t\nval cAuop : Structures.constr lazy_t\nval cAbop : Structures.constr lazy_t\nval cAtop : Structures.constr lazy_t\nval cAnop : Structures.constr lazy_t\nval cAapp : Structures.constr lazy_t\n\nval cform : Structures.constr lazy_t\nval cFatom : Structures.constr lazy_t\nval cFtrue : Structures.constr lazy_t\nval cFfalse : Structures.constr lazy_t\nval cFnot2 : Structures.constr lazy_t\nval cFand : Structures.constr lazy_t\nval cFor : Structures.constr lazy_t\nval cFxor : Structures.constr lazy_t\nval cFimp : Structures.constr lazy_t\nval cFiff : Structures.constr lazy_t\nval cFite : Structures.constr lazy_t\nval cFbbT : Structures.constr lazy_t\n\nval cis_true : Structures.constr lazy_t\n\nval cvalid_sat_checker : Structures.constr lazy_t\nval cinterp_var_sat_checker : Structures.constr lazy_t\n\nval make_certif_ops :\n           string list list ->\n           Structures.constr array option ->\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t * Structures.constr lazy_t *\n           Structures.constr lazy_t * Structures.constr lazy_t\n\n(* Some constructions *)\nval ceq_refl_true : Structures.constr lazy_t\nval eq_refl_true : unit -> Structures.constr\nval vm_cast_true_no_check : Structures.constr -> Structures.constr\nval vm_cast_true : Environ.env -> Structures.constr -> Structures.constr\nval mkNat : int -> Structures.constr\nval mkN : int -> Structures.constr\nval mk_bv_list : bool list -> Structures.constr\n\n(* Reification *)\nval mk_bool : Structures.constr -> bool\nval mk_bool_list : Structures.constr -> bool list\nval mk_nat : Structures.constr -> int\nval mk_N : Structures.constr -> int\nval mk_Z : Structures.constr -> int\nval mk_bvsize : Structures.constr -> int\n\n(* Switches between constr and OCaml *)\nval option_of_constr_option : Structures.constr -> Structures.constr option\nval list_of_constr_tuple : Structures.constr -> Structures.constr list\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 19, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/coqTerms.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 22, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":128,"character":14},"end":{"line":128,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 26, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"verit/veritLexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open VeritParser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"verit/veritLexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"verit/veritLexer.mll\"\n                               ( token lexbuf )\n# 791 \"verit/veritLexer.ml\"\n\n  | 1 ->\n# 164 \"verit/veritLexer.mll\"\n                               ( EOL )\n# 796 \"verit/veritLexer.ml\"\n\n  | 2 ->\n# 166 \"verit/veritLexer.mll\"\n                               ( COLON )\n# 801 \"verit/veritLexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"verit/veritLexer.mll\"\n                i\n# 807 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"verit/veritLexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"verit/veritLexer.ml\"\n\n  | 4 ->\n# 169 \"verit/veritLexer.mll\"\n                               ( LPAR )\n# 816 \"verit/veritLexer.ml\"\n\n  | 5 ->\n# 170 \"verit/veritLexer.mll\"\n                               ( RPAR )\n# 821 \"verit/veritLexer.ml\"\n\n  | 6 ->\n# 172 \"verit/veritLexer.mll\"\n                               ( LBRACKET )\n# 826 \"verit/veritLexer.ml\"\n\n  | 7 ->\n# 173 \"verit/veritLexer.mll\"\n                               ( RBRACKET )\n# 831 \"verit/veritLexer.ml\"\n\n  | 8 ->\n# 175 \"verit/veritLexer.mll\"\n                               ( EQ )\n# 836 \"verit/veritLexer.ml\"\n\n  | 9 ->\n# 176 \"verit/veritLexer.mll\"\n                               ( LT )\n# 841 \"verit/veritLexer.ml\"\n\n  | 10 ->\n# 177 \"verit/veritLexer.mll\"\n                               ( LEQ )\n# 846 \"verit/veritLexer.ml\"\n\n  | 11 ->\n# 178 \"verit/veritLexer.mll\"\n                               ( GT )\n# 851 \"verit/veritLexer.ml\"\n\n  | 12 ->\n# 179 \"verit/veritLexer.mll\"\n                               ( GEQ )\n# 856 \"verit/veritLexer.ml\"\n\n  | 13 ->\n# 180 \"verit/veritLexer.mll\"\n                               ( PLUS )\n# 861 \"verit/veritLexer.ml\"\n\n  | 14 ->\n# 181 \"verit/veritLexer.mll\"\n                               ( MINUS )\n# 866 \"verit/veritLexer.ml\"\n\n  | 15 ->\n# 182 \"verit/veritLexer.mll\"\n                               ( OPP )\n# 871 \"verit/veritLexer.ml\"\n\n  | 16 ->\n# 183 \"verit/veritLexer.mll\"\n                               ( MULT )\n# 876 \"verit/veritLexer.ml\"\n\n  | 17 ->\n# 184 \"verit/veritLexer.mll\"\n                               ( IMP )\n# 881 \"verit/veritLexer.ml\"\n\n  | 18 ->\n# 186 \"verit/veritLexer.mll\"\n                               ( SAT )\n# 886 \"verit/veritLexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"verit/veritLexer.mll\"\n                      i\n# 892 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"verit/veritLexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"verit/veritLexer.ml\"\n\n  | 20 ->\n# 189 \"verit/veritLexer.mll\"\n                             ( TINT )\n# 901 \"verit/veritLexer.ml\"\n\n  | 21 ->\n# 190 \"verit/veritLexer.mll\"\n                   ( TBOOL )\n# 906 \"verit/veritLexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"verit/veritLexer.mll\"\n            i\n# 912 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"verit/veritLexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"verit/veritLexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"verit/veritLexer.mll\"\n                 bv\n# 924 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"verit/veritLexer.mll\"\n                               ( BITV bv )\n# 928 \"verit/veritLexer.ml\"\n\n  | 24 ->\n# 195 \"verit/veritLexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"verit/veritLexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"verit/veritLexer.mll\"\n               v\n# 941 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"verit/veritLexer.mll\"\n                               ( BINDVAR v )\n# 945 \"verit/veritLexer.ml\"\n\n  | 26 ->\n# 200 \"verit/veritLexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"verit/veritLexer.ml\"\n\n  | 27 ->\n# 202 \"verit/veritLexer.mll\"\n                               ( raise Eof )\n# 955 \"verit/veritLexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 29, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 32, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Sending response {"id": 33, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 35, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":185,"character":28},"end":{"line":185,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":156,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":113,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 38, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":41,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 41, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":42,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":22,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0360012054443ms
Sending response {"id": 42, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":43,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":16,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.375032424927ms
Sending response {"id": 43, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":44,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 44, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":45,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":16,"character":9},"end":{"line":16,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 45, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":46,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":16,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 46, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
Read message 
{"jsonrpc":"2.0","id":47,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 47, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":48,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 48, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":49,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 49, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":50,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":185,"character":28},"end":{"line":185,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 50, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":51,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 51, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":52,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 52, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":53,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 53, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":54,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":185,"character":28},"end":{"line":185,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 54, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":55,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 55, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":56,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":104,"character":4},"end":{"line":104,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 56, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":57,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":127,"character":4},"end":{"line":127,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 57, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":58,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":127,"character":4},"end":{"line":127,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 58, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":59,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":127,"character":4},"end":{"line":127,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 59, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":60,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":127,"character":4},"end":{"line":127,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 60, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":61,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":128,"character":14},"end":{"line":128,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0290870666504ms
Sending response {"id": 61, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":62,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":133,"character":4},"end":{"line":133,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 62, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":63,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":128,"character":26}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 63, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":64,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":130,"character":25}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 64, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":65,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 65, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":66,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":115,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 66, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":67,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":22}}}
[server] Got a method textDocument/hover
[server] processing took 0.0238418579102ms
Sending response {"id": 67, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":68,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":119,"character":20}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 68, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":69,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":119,"character":20},"end":{"line":119,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 69, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":70,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 70, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":71,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":114,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 71, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":72,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":114,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 72, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":73,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":114,"character":11},"end":{"line":114,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 73, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":74,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":123,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 74, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":75,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":123,"character":4},"end":{"line":123,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 75, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":76,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":123,"character":14}}}
[server] Got a method textDocument/definition
[server] processing took 0.0100135803223ms
Sending response {"id": 76, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":77,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":123,"character":16}}}
[server] Got a method textDocument/definition
[server] processing took 0.0259876251221ms
Sending response {"id": 77, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":78,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":124,"character":14},"end":{"line":124,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 78, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":79,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":123,"character":4},"end":{"line":123,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 79, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":80,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":124,"character":14},"end":{"line":124,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 80, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":81,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":123,"character":4},"end":{"line":123,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 81, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":82,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":133,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.179052352905ms
Sending response {"id": 82, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":83,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 83, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":84,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":27}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Sending response {"id": 84, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":85,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":134,"character":23},"end":{"line":134,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 85, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":86,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":33}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 86, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":87,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":120,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 87, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":88,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":117,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 88, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":89,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":113,"character":1}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 89, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":90,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 90, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":91,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 91, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":92,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 92, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":93,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":22,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.018835067749ms
Sending response {"id": 93, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":94,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":29,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0178813934326ms
Sending response {"id": 94, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":95,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":29,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 95, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":96,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 96, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":97,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":29,"character":13},"end":{"line":29,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 97, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":98,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 98, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":99,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":570,"character":15},"end":{"line":570,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 99, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":100,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 100, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":101,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":14}}}
[server] Got a method textDocument/definition
[server] processing took 0.00500679016113ms
Sending response {"id": 101, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":102,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":577,"character":7},"end":{"line":577,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 102, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":103,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":581,"character":7},"end":{"line":581,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 103, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":104,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":563,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 104, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":105,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 105, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":106,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 106, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":107,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":134,"character":23},"end":{"line":134,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 107, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":108,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 108, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":109,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":106,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 109, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":110,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":112,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 110, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":111,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":114,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 111, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":112,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":114,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Sending response {"id": 112, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":113,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":114,"character":11},"end":{"line":114,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 113, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":114,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":114,"character":11},"end":{"line":114,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 114, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":115,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":114,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 115, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":116,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":110,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 116, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":117,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 117, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":118,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 118, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":119,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":581,"character":7},"end":{"line":581,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 119, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":120,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 120, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":121,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":555,"character":18}}}
[server] Got a method textDocument/definition
[server] processing took 0.00905990600586ms
Sending response {"id": 121, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":122,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":556,"character":18}}}
[server] Got a method textDocument/definition
[server] processing took 0.0200271606445ms
Sending response {"id": 122, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":123,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":556,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 123, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":124,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":570,"character":0},"end":{"line":570,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 124, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":125,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":559,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 125, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":126,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":562,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 126, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":127,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":567,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 127, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":128,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":572,"character":27}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 128, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":129,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":17}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 129, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":130,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":570,"character":17},"end":{"line":570,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 130, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":131,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.00619888305664ms
Sending response {"id": 131, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":132,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":570,"character":11},"end":{"line":570,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 132, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":133,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":570,"character":14},"end":{"line":570,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 133, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":134,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":17}}}
[server] Got a method textDocument/definition
[server] processing took 0.00691413879395ms
Sending response {"id": 134, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":135,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":5}}}
[server] Got a method textDocument/definition
[server] processing took 0.00500679016113ms
Sending response {"id": 135, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":136,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Sending response {"id": 136, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":137,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":5}}}
[server] Got a method textDocument/definition
[server] processing took 0.00810623168945ms
Sending response {"id": 137, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":138,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":575,"character":61},"end":{"line":575,"character":67}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 138, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":139,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":572,"character":1}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 139, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":140,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":570,"character":12}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 140, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":141,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":570,"character":9},"end":{"line":570,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 141, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":142,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":572,"character":15},"end":{"line":572,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0510215759277ms
Sending response {"id": 142, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":143,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":575,"character":26},"end":{"line":575,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 143, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":144,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":586,"character":2},"end":{"line":586,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 144, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":145,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":588,"character":2},"end":{"line":588,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 145, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":146,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":12,"character":8},"end":{"line":12,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 146, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":147,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":30,"character":5},"end":{"line":30,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 147, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":148,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":31,"character":12},"end":{"line":31,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 148, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":149,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":31,"character":17},"end":{"line":31,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 149, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":150,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":38,"character":5},"end":{"line":38,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 150, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":151,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":43,"character":5},"end":{"line":43,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 151, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":152,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":31,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 152, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":153,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":221,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Sending response {"id": 153, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":154,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":264,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 154, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":155,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.399827957153ms
Sending response {"id": 155, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":156,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 156, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":157,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 157, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":158,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":114,"character":11},"end":{"line":114,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 158, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":159,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Sending response {"id": 159, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":160,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":117,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 160, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":161,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 161, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":162,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":115,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 162, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":163,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":115,"character":19}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 163, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":164,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 164, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":165,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":115,"character":11},"end":{"line":115,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 165, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":166,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":115,"character":23},"end":{"line":115,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 166, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":167,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0159740447998ms
Sending response {"id": 167, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":168,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":116,"character":17},"end":{"line":116,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 168, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":169,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":116,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.00715255737305ms
Sending response {"id": 169, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":170,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":116,"character":29},"end":{"line":116,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 170, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":171,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":117,"character":31}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 171, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":172,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":117,"character":29},"end":{"line":117,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 172, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":173,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":119,"character":31}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Sending response {"id": 173, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":174,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":119,"character":24},"end":{"line":119,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 174, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":175,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":114,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.00977516174316ms
Sending response {"id": 175, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":176,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":112,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Sending response {"id": 176, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":177,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":112,"character":20},"end":{"line":112,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 177, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":178,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":112,"character":11},"end":{"line":112,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 178, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":179,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":112,"character":20},"end":{"line":112,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 179, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":180,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":111,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 180, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":181,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":111,"character":9}}}
[server] Got a method textDocument/definition
[server] processing took 0.00596046447754ms
Sending response {"id": 181, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":182,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":111,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 182, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":183,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":111,"character":9}}}
[server] Got a method textDocument/definition
[server] processing took 0.00882148742676ms
Sending response {"id": 183, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":184,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":111,"character":9},"end":{"line":111,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 184, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":185,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":111,"character":2},"end":{"line":111,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 185, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":186,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":230,"character":2},"end":{"line":230,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 186, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":187,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":104,"character":4},"end":{"line":104,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 187, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":188,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":99,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.00619888305664ms
Sending response {"id": 188, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":189,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":101,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 189, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":190,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":104,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0228881835938ms
Sending response {"id": 190, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":191,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":106,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 191, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":192,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":107,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0889301300049ms
Sending response {"id": 192, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":193,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":107,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 193, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":194,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":107,"character":11}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 194, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":195,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 195, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":196,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 196, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":197,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 197, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":198,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 198, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":199,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":43,"character":5},"end":{"line":43,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 199, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":200,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":356,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 200, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":201,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 201, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":202,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":217,"character":31},"end":{"line":217,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 202, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":203,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":224,"character":4},"end":{"line":224,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 203, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":204,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":224,"character":27},"end":{"line":224,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 204, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":205,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":530,"character":4},"end":{"line":530,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 205, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":206,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":530,"character":30},"end":{"line":530,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 206, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":207,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":536,"character":4},"end":{"line":536,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 207, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":208,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":536,"character":28},"end":{"line":536,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 208, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":209,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":577,"character":4},"end":{"line":577,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 209, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":210,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":579,"character":2},"end":{"line":579,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 210, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":211,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":581,"character":4},"end":{"line":581,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 211, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":212,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":581,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 212, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":213,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":579,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 213, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":214,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 214, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":215,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 215, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":216,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 216, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":217,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 217, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":218,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 218, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":219,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 219, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":220,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 220, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":221,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":16,"character":9},"end":{"line":16,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 221, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":222,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":17,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 222, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":223,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":17,"character":12}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 223, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":224,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 224, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":225,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":17,"character":12},"end":{"line":17,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 225, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":226,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":19,"character":17},"end":{"line":19,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 226, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":227,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":20,"character":3}}}
[server] Got a method textDocument/hover
[server] processing took 0.0271797180176ms
Sending response {"id": 227, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":228,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":22,"character":1}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 228, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":229,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":21,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 229, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":230,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":21,"character":9},"end":{"line":21,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 230, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":231,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":21,"character":4},"end":{"line":21,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 231, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":232,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":22,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 232, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":233,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":22,"character":4},"end":{"line":22,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 233, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":234,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 234, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":235,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 235, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":236,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 236, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":234}}
Read message 
{"jsonrpc":"2.0","id":237,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":21,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 237, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":238,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 238, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":239,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":21,"character":4},"end":{"line":21,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 239, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":240,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":20,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Sending response {"id": 240, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":241,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":20,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 241, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":242,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":20,"character":4},"end":{"line":20,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 242, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":243,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":19,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 243, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":244,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":19,"character":10}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 244, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":245,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":19,"character":10},"end":{"line":19,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 245, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":246,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":18,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 246, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":247,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":18,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Sending response {"id": 247, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":248,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":18,"character":4},"end":{"line":18,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 248, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":249,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":19,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 249, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":250,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":19,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 250, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":249}}
Read message 
{"jsonrpc":"2.0","id":251,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":19,"character":4},"end":{"line":19,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 251, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":252,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":21,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Sending response {"id": 252, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":253,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":21,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 253, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":254,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":21,"character":4},"end":{"line":21,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 254, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":255,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 255, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":256,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":18,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 256, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":257,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":18,"character":24},"end":{"line":18,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 257, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":258,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":18,"character":17}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 258, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":259,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":18,"character":14},"end":{"line":18,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 259, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":260,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":20,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 260, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":261,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":20,"character":8},"end":{"line":20,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 261, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":262,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":20,"character":8}}}
[server] Got a method textDocument/definition
[server] processing took 0.0321865081787ms
Sending response {"id": 262, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":263,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"position":{"line":20,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 263, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":264,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0312328338623ms
Sending response {"id": 264, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":265,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 265, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":266,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 266, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":267,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 267, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":268,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":13,"character":13}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 268, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":269,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 269, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":270,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":13,"character":13},"end":{"line":13,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 270, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":271,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":20,"character":3},"end":{"line":20,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 271, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":272,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":127,"character":0},"end":{"line":127,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 272, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":273,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":127,"character":0},"end":{"line":127,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 273, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":274,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":133,"character":0},"end":{"line":133,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 274, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":275,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":130,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 275, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":276,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":133,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 276, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":277,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.00715255737305ms
Sending response {"id": 277, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":278,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 278, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":279,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 279, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":280,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":134,"character":14},"end":{"line":134,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 280, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":281,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 281, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":282,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":134,"character":13},"end":{"line":134,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 282, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":283,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":128,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 283, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":284,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":134,"character":2},"end":{"line":134,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 284, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":285,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":10}}}
[server] Got a method textDocument/definition
[server] processing took 0.00905990600586ms
Sending response {"id": 285, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":286,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"position":{"line":134,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0250339508057ms
Sending response {"id": 286, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":287,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 287, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":288,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 288, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":289,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 289, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":290,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":124,"character":2},"end":{"line":124,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 290, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen SmtCertif\nopen SmtCommands\nopen SmtForm\nopen SmtAtom\nopen SmtTrace\nopen Verit\nopen Smtlib2_ast\nopen Smtlib2_genConstr\n(* open Smt_checker *)\n\n\nmodule Mc = Structures.Micromega_plugin_Certificate.Mc\n\n\nlet mkInt = ExtrNative.of_int\nlet mkArray = ExtrNative.of_array\n\n\nlet rec dump_nat x =\n  match x with\n    | Mc.O -> Smt_checker.O\n    | Mc.S p -> Smt_checker.S (dump_nat p)\n\n\nlet rec dump_positive x =\n  match x with\n    | Mc.XH -> Smt_checker.XH\n    | Mc.XO p -> Smt_checker.XO (dump_positive p)\n    | Mc.XI p -> Smt_checker.XI (dump_positive p)\n\n\nlet dump_z x =\n  match x with\n    | Mc.Z0 -> Smt_checker.Z0\n    | Mc.Zpos p -> Smt_checker.Zpos (dump_positive p)\n    | Mc.Zneg p -> Smt_checker.Zneg (dump_positive p)\n\n\nlet dump_pol e =\n  let rec dump_pol e =\n    match e with\n      | Mc.Pc n -> Smt_checker.Pc (dump_z n)\n      | Mc.Pinj(p,pol) -> Smt_checker.Pinj (dump_positive p, dump_pol pol)\n      | Mc.PX(pol1,p,pol2) -> Smt_checker.PX (dump_pol pol1, dump_positive p, dump_pol pol2) in\n  dump_pol e\n\n\nlet dump_psatz e =\n  let rec dump_cone e =\n    match e with\n      | Mc.PsatzIn n -> Smt_checker.PsatzIn (dump_nat n)\n      | Mc.PsatzMulC(e,c) -> Smt_checker.PsatzMulC (dump_pol e, dump_cone c)\n      | Mc.PsatzSquare e -> Smt_checker.PsatzSquare (dump_pol e)\n      | Mc.PsatzAdd(e1,e2) -> Smt_checker.PsatzAdd (dump_cone e1, dump_cone e2)\n      | Mc.PsatzMulE(e1,e2) -> Smt_checker.PsatzMulE (dump_cone e1, dump_cone e2)\n      | Mc.PsatzC p -> Smt_checker.PsatzC (dump_z p)\n      | Mc.PsatzZ -> Smt_checker.PsatzZ in\n  dump_cone e\n\n\nlet rec dump_list dump_elt l =\n  match l with\n    | [] -> Smt_checker.Nil\n    | e :: l -> Smt_checker.Cons (dump_elt e, dump_list dump_elt l)\n\n\nlet rec dump_proof_term = function\n  | Micromega.DoneProof -> Smt_checker.DoneProof\n  | Micromega.RatProof(cone,rst) ->\n    Smt_checker.RatProof (dump_psatz cone, dump_proof_term rst)\n  | Micromega.CutProof(cone,prf) ->\n    Smt_checker.CutProof (dump_psatz cone, dump_proof_term prf)\n  | Micromega.EnumProof(c1,c2,prfs) ->\n    Smt_checker.EnumProof (dump_psatz c1, dump_psatz c2, dump_list dump_proof_term prfs)\n\n\n\nlet to_coq to_lit confl =\n  let out_f f = to_lit f in\n  let out_c c = mkInt (get_pos c) in\n  let step_to_coq c =\n    match c.kind with\n    | Res res ->\n\tlet size = List.length res.rtail + 3 in\n\tlet args = Array.make size (mkInt 0) in\n\targs.(0) <- mkInt (get_pos res.rc1);\n\targs.(1) <- mkInt (get_pos res.rc2);\n\tlet l = ref res.rtail in\n\tfor i = 2 to size - 2 do\n\t  match !l with\n\t  | c::tl ->\n\t      args.(i) <- mkInt (get_pos c);\n\t      l := tl\n\t  | _ -> assert false\n\tdone;\n\tSmt_checker.Euf_Checker.Res (mkInt (get_pos c), mkArray args)\n    | Other other ->\n\tbegin match other with\n\t| ImmFlatten (c',f) -> Smt_checker.Euf_Checker.ImmFlatten (out_c c, out_c c', out_f f)\n        | True -> Smt_checker.Euf_Checker.CTrue (out_c c)\n\t| False -> Smt_checker.Euf_Checker.CFalse (out_c c)\n\t| BuildDef f -> Smt_checker.Euf_Checker.BuildDef (out_c c, out_f f)\n\t| BuildDef2 f -> Smt_checker.Euf_Checker.BuildDef2 (out_c c, out_f f)\n\t| BuildProj (f, i) -> Smt_checker.Euf_Checker.BuildProj (out_c c, out_f f, mkInt i)\n\t| ImmBuildDef c' -> Smt_checker.Euf_Checker.ImmBuildDef (out_c c, out_c c')\n\t| ImmBuildDef2 c' -> Smt_checker.Euf_Checker.ImmBuildDef2 (out_c c, out_c c')\n\t| ImmBuildProj(c', i) -> Smt_checker.Euf_Checker.ImmBuildProj (out_c c, out_c c',mkInt i)\n        | EqTr (f, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons (out_f f, l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqTr (out_c c, out_f f, res)\n        | EqCgr (f, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons ((match f with | Some f -> Smt_checker.Some (out_f f) | None -> Smt_checker.None), l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqCgr (out_c c, out_f f, res)\n        | EqCgrP (f1, f2, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons ((match f with | Some f -> Smt_checker.Some (out_f f) | None -> Smt_checker.None), l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqCgrP (out_c c, out_f f1, out_f f2, res)\n\t| LiaMicromega (cl,d) ->\n          let cl' = List.fold_right (fun f l -> Smt_checker.Cons (out_f f, l)) cl Smt_checker.Nil in\n          let c' = List.fold_right (fun f l -> Smt_checker.Cons (dump_proof_term f, l)) d Smt_checker.Nil in\n          Smt_checker.Euf_Checker.LiaMicromega (out_c c, cl', c')\n        | LiaDiseq l -> Smt_checker.Euf_Checker.LiaDiseq (out_c c, out_f l)\n        | SplArith (orig,res,l) ->\n          let res' = out_f res in\n          let l' = List.fold_right (fun f l -> Smt_checker.Cons (dump_proof_term f, l)) l Smt_checker.Nil in\n          Smt_checker.Euf_Checker.SplArith (out_c c, out_c orig, res', l')\n\t| SplDistinctElim (c',f) -> Smt_checker.Euf_Checker.SplDistinctElim (out_c c, out_c c', out_f f)\n\tend\n    | _ -> assert false in\n  let def_step =\n    Smt_checker.Euf_Checker.Res (mkInt 0, mkArray [|mkInt 0|]) in\n  let r = ref confl in\n  let nc = ref 0 in\n  while not (isRoot !r.kind) do r := prev !r; incr nc done;\n  let last_root = !r in\n  let size = !nc in\n  let max = (Parray.trunc_size (Uint63.of_int 4194303)) - 1 in\n  let q,r1 = size / max, size mod max in\n\n  let trace =\n    let len = if r1 = 0 then q + 1 else q + 2 in\n    Array.make len (mkArray [|def_step|]) in\n  for j = 0 to q - 1 do\n    let tracej = Array.make (Parray.trunc_size (Uint63.of_int 4194303)) def_step in\n    for i = 0 to max - 1 do\n      r := next !r;\n      tracej.(i) <- step_to_coq !r;\n    done;\n    trace.(j) <- mkArray tracej\n  done;\n  if r1 <> 0 then begin\n    let traceq = Array.make (r1 + 1) def_step in\n    for i = 0 to r1-1 do\n    r := next !r;\n    traceq.(i) <- step_to_coq !r;\n    done;\n    trace.(q) <- mkArray traceq\n  end;\n\n  (mkArray trace, last_root)\n\n\nlet btype_to_coq = function\n  | TZ ->        Smt_checker.Typ.TZ\n  | Tbool ->     Smt_checker.Typ.Tbool\n  | Tpositive -> Smt_checker.Typ.Tpositive\n  | Tindex i ->  Smt_checker.Typ.Tindex (mkInt (SmtAtom.indexed_type_index i))\n\n\nlet c_to_coq = function\n  | CO_xH -> Smt_checker.Atom.CO_xH\n  | CO_Z0 -> Smt_checker.Atom.CO_Z0\n\n\nlet u_to_coq = function\n  | UO_xO ->   Smt_checker.Atom.UO_xO\n  | UO_xI ->   Smt_checker.Atom.UO_xI\n  | UO_Zpos -> Smt_checker.Atom.UO_Zpos\n  | UO_Zneg -> Smt_checker.Atom.UO_Zneg\n  | UO_Zopp -> Smt_checker.Atom.UO_Zopp\n\n\nlet b_to_coq = function\n  | BO_Zplus ->  Smt_checker.Atom.BO_Zplus\n  | BO_Zminus -> Smt_checker.Atom.BO_Zminus\n  | BO_Zmult ->  Smt_checker.Atom.BO_Zmult\n  | BO_Zlt ->    Smt_checker.Atom.BO_Zlt\n  | BO_Zle ->    Smt_checker.Atom.BO_Zle\n  | BO_Zge ->    Smt_checker.Atom.BO_Zge\n  | BO_Zgt ->    Smt_checker.Atom.BO_Zgt\n  | BO_eq t ->   Smt_checker.Atom.BO_eq (btype_to_coq t)\n\n\nlet n_to_coq = function\n  | NO_distinct t -> btype_to_coq t\n\n\nlet i_to_coq i = mkInt (SmtAtom.indexed_op_index i)\n\n\nlet a_to_coq a =\n  let to_coq h = mkInt (Atom.index h) in\n  match a with\n    | Acop op -> Smt_checker.Atom.Acop (c_to_coq op)\n    | Auop (op,h) -> Smt_checker.Atom.Auop (u_to_coq op, to_coq h)\n    | Abop (op,h1,h2) ->\n      Smt_checker.Atom.Abop (b_to_coq op, to_coq h1, to_coq h2)\n    | Anop (op,ha) ->\n      let cop = n_to_coq op in\n      let cargs = Array.fold_right (fun h l -> Smt_checker.Cons (to_coq h, l)) ha Smt_checker.Nil in\n      Smt_checker.Atom.Anop (cop, cargs)\n    | Aapp (op,args) ->\n      let cop = i_to_coq op in\n      let cargs = Array.fold_right (fun h l -> Smt_checker.Cons (to_coq h, l)) args Smt_checker.Nil in\n      Smt_checker.Atom.Aapp (cop, cargs)\n\n\nlet atom_interp_tbl reify =\n  let t = Atom.to_array reify (Smt_checker.Atom.Acop Smt_checker.Atom.CO_xH) a_to_coq in\n  mkArray t\n\n\nlet form_to_coq hf = mkInt (Form.to_lit hf)\n\nlet args_to_coq args =\n  let cargs = Array.make (Array.length args + 1) (mkInt 0) in\n  Array.iteri (fun i hf -> cargs.(i) <- form_to_coq hf) args;\n  mkArray cargs\n\nlet pf_to_coq = function\n  | Fatom a -> Smt_checker.Form.Fatom (mkInt (Atom.index a))\n  | Fapp(op,args) ->\n    match op with\n      | Ftrue -> Smt_checker.Form.Ftrue\n      | Ffalse -> Smt_checker.Form.Ffalse\n      | Fand -> Smt_checker.Form.Fand (args_to_coq args)\n      | For  -> Smt_checker.Form.For (args_to_coq args)\n      | Fimp -> Smt_checker.Form.Fimp (args_to_coq args)\n      | Fxor -> if Array.length args = 2 then Smt_checker.Form.Fxor (form_to_coq args.(0), form_to_coq args.(1)) else assert false\n      | Fiff -> if Array.length args = 2 then Smt_checker.Form.Fiff (form_to_coq args.(0), form_to_coq args.(1)) else assert false\n      | Fite -> if Array.length args = 3 then Smt_checker.Form.Fite (form_to_coq args.(0), form_to_coq args.(1), form_to_coq args.(2)) else assert false\n      | Fnot2 i -> Smt_checker.Form.Fnot2 (mkInt i, form_to_coq args.(0))\n\n\nlet form_interp_tbl reify =\n  let (_,t) = Form.to_array reify Smt_checker.Form.Ftrue pf_to_coq in\n  mkArray t\n\n\n(* Importing from SMT-LIB v.2 without generating section variables *)\n\nlet count_btype = ref 0\nlet count_op = ref 0\n\n\nlet declare_sort sym =\n  let s = string_of_symbol sym in\n  let res = Tindex (dummy_indexed_type !count_btype) in\n  incr count_btype;\n  VeritSyntax.add_btype s res;\n  res\n\n\nlet declare_fun sym arg cod =\n  let s = string_of_symbol sym in\n  let tyl = List.map sort_of_sort arg in\n  let ty = sort_of_sort cod in\n  let op = dummy_indexed_op !count_op (Array.of_list (List.map fst tyl)) (fst ty) in\n  incr count_op;\n  VeritSyntax.add_fun s op;\n  op\n\n\nlet declare_commands ra rf acc = function\n  | CDeclareSort (_,sym,_) -> let _ = declare_sort sym in acc\n  | CDeclareFun (_,sym, (_, arg), cod) -> let _ = declare_fun sym arg cod in acc\n  | CAssert (_, t) -> (make_root ra rf t)::acc\n  | _ -> acc\n\n\nlet import_smtlib2 ra rf filename =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let commands = Smtlib2_parse.main Smtlib2_lex.token lexbuf in\n  close_in chan;\n  match commands with\n    | None -> []\n    | Some (Smtlib2_ast.Commands (_,(_,res))) ->\n      List.rev (List.fold_left (declare_commands ra rf) [] res)\n\n\n(* The final checker *)\n\nlet this_clear_all () =\n  Verit.clear_all ();\n  count_btype := 0;\n  count_op := 0\n\n\nlet checker fsmt fproof =\n  this_clear_all ();\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let roots = import_smtlib2 ra rf fsmt in\n  let (max_id, confl) = import_trace fproof None in\n  let (tres,last_root) = to_coq (fun i -> mkInt (SmtAtom.Form.to_lit i)) confl in\n  let certif =\n    Smt_checker.Euf_Checker.Certif (mkInt (max_id + 1), tres, mkInt (get_pos confl)) in\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    Smt_checker.Some (mkArray res) in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (SmtAtom.Form.to_lit j); incr i) roots;\n    mkArray res in\n\n  let t_atom = atom_interp_tbl ra in\n  let t_form = form_interp_tbl rf in\n\n  Smt_checker.Euf_Checker.checker_ext t_atom t_form rootsCstr used_rootsCstr certif\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":291,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 291, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":292,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00286102294922ms
Sending response {"id": 292, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":293,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 293, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":294,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":14,"character":5},"end":{"line":14,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 294, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtForm\nopen SmtAtom\nopen SmtTrace\nopen SmtCertif\n\n\nlet euf_checker_modules = [ [\"SMTCoq\";\"Trace\";\"Euf_Checker\"] ]\nlet certif_ops args = CoqTerms.make_certif_ops euf_checker_modules args\nlet cCertif = gen_constant euf_checker_modules \"Certif\"\nlet ccertif = gen_constant euf_checker_modules \"certif\"\nlet cchecker = gen_constant euf_checker_modules \"checker\"\nlet cchecker_correct = gen_constant euf_checker_modules \"checker_correct\"\nlet cchecker_b_correct =\n  gen_constant euf_checker_modules \"checker_b_correct\"\nlet cchecker_b = gen_constant euf_checker_modules \"checker_b\"\nlet cchecker_eq_correct =\n  gen_constant euf_checker_modules \"checker_eq_correct\"\nlet cchecker_eq = gen_constant euf_checker_modules \"checker_eq\"\n(* let csetup_checker_step_debug =\n *   gen_constant euf_checker_modules \"setup_checker_step_debug\" *)\n(* let cchecker_step_debug = gen_constant euf_checker_modules \"checker_step_debug\" *)\n(* let cstep = gen_constant euf_checker_modules \"step\" *)\nlet cchecker_debug = gen_constant euf_checker_modules \"checker_debug\"\n\nlet cname_step = gen_constant euf_checker_modules \"name_step\"\n\nlet cName_Res = gen_constant euf_checker_modules \"Name_Res\"\nlet cName_Weaken= gen_constant euf_checker_modules \"Name_Weaken\"\nlet cName_ImmFlatten= gen_constant euf_checker_modules \"Name_ImmFlatten\"\nlet cName_CTrue= gen_constant euf_checker_modules \"Name_CTrue\"\nlet cName_CFalse = gen_constant euf_checker_modules \"Name_CFalse\"\nlet cName_BuildDef= gen_constant euf_checker_modules \"Name_BuildDef\"\nlet cName_BuildDef2= gen_constant euf_checker_modules \"Name_BuildDef2\"\nlet cName_BuildProj = gen_constant euf_checker_modules \"Name_BuildProj\"\nlet cName_ImmBuildDef= gen_constant euf_checker_modules \"Name_ImmBuildDef\"\nlet cName_ImmBuildDef2= gen_constant euf_checker_modules \"Name_ImmBuildDef2\"\nlet cName_ImmBuildProj = gen_constant euf_checker_modules \"Name_ImmBuildProj\"\nlet cName_EqTr = gen_constant euf_checker_modules \"Name_EqTr\"\nlet cName_EqCgr = gen_constant euf_checker_modules \"Name_EqCgr\"\nlet cName_EqCgrP= gen_constant euf_checker_modules \"Name_EqCgrP\"\nlet cName_LiaMicromega = gen_constant euf_checker_modules \"Name_LiaMicromega\"\nlet cName_LiaDiseq= gen_constant euf_checker_modules \"Name_LiaDiseq\"\nlet cName_SplArith= gen_constant euf_checker_modules \"Name_SplArith\"\nlet cName_SplDistinctElim = gen_constant euf_checker_modules \"Name_SplDistinctElim\"\nlet cName_BBVar= gen_constant euf_checker_modules \"Name_BBVar\"\nlet cName_BBConst= gen_constant euf_checker_modules \"Name_BBConst\"\nlet cName_BBOp= gen_constant euf_checker_modules \"Name_BBOp\"\nlet cName_BBNot= gen_constant euf_checker_modules \"Name_BBNot\"\nlet cName_BBNeg= gen_constant euf_checker_modules \"Name_BBNeg\"\nlet cName_BBAdd= gen_constant euf_checker_modules \"Name_BBAdd\"\nlet cName_BBConcat= gen_constant euf_checker_modules \"Name_BBConcat\"\nlet cName_BBMul= gen_constant euf_checker_modules \"Name_BBMul\"\nlet cName_BBUlt= gen_constant euf_checker_modules \"Name_BBUlt\"\nlet cName_BBSlt= gen_constant euf_checker_modules \"Name_BBSlt\"\nlet cName_BBEq= gen_constant euf_checker_modules \"Name_BBEq\"\nlet cName_BBDiseq= gen_constant euf_checker_modules \"Name_BBDiseq\"\nlet cName_BBExtract= gen_constant euf_checker_modules \"Name_BBExtract\"\nlet cName_BBZextend= gen_constant euf_checker_modules \"Name_BBZextend\"\nlet cName_BBSextend= gen_constant euf_checker_modules \"Name_BBSextend\"\nlet cName_BBShl= gen_constant euf_checker_modules \"Name_BBShl\"\nlet cName_BBShr= gen_constant euf_checker_modules \"Name_BBShr\"\nlet cName_RowEq= gen_constant euf_checker_modules \"Name_RowEq\"\nlet cName_RowNeq= gen_constant euf_checker_modules \"Name_RowNeq\"\nlet cName_Ext= gen_constant euf_checker_modules \"Name_Ext\"\nlet cName_Hole= gen_constant euf_checker_modules \"Name_Hole\"\n\n(* Given an SMT-LIB2 file and a certif, build the corresponding objects *)\n\nlet compute_roots roots last_root =\n  let r = ref last_root in\n  while (has_prev !r) do\n    r := prev !r\n  done;\n\n  let rec find_root i root = function\n    | [] -> assert false\n    | t::q -> if Form.equal t root then i else find_root (i+1) root q in\n\n  let rec used_roots acc r =\n    if isRoot r.kind then\n      match r.value with\n        | Some [root] ->\n           let j = find_root 0 root roots in\n           used_roots (j::acc) (next r)\n        | _ -> assert false\n    else acc\n  in\n\n  used_roots [] !r\n\n\nlet interp_uf t_i ta tf c =\n  let rec interp = function\n    | [] -> Lazy.force cfalse\n    | [l] -> Form.interp_to_coq (Atom.interp_to_coq t_i ta) tf l\n    | l::c -> mklApp corb [|Form.interp_to_coq (Atom.interp_to_coq t_i ta) tf l; interp c|] in\n  interp c\n\nlet interp_conseq_uf t_i (prem, concl) =\n  let ta = Hashtbl.create 17 in\n  let tf = Hashtbl.create 17 in\n  let rec interp = function\n    | [] -> mklApp cis_true [|interp_uf t_i ta tf concl|]\n    | c::prem -> Term.mkArrow (mklApp cis_true [|interp_uf t_i ta tf c|]) (interp prem) in\n  interp prem\n\n\nlet print_assm ty =\n  Format.printf \"WARNING: assuming the following hypothesis:\\n%s\\n@.\"\n    (string_coq_constr ty)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace (rt, ro, ra, rf, roots, max_id, confl) =\n\n  let t_i' = make_t_i rt in\n  let ce5 = Structures.mkUConst t_i' in\n  let ct_i = Structures.mkConst (Structures.declare_constant t_i ce5) in\n\n  let t_func' = make_t_func ro ct_i in\n  let ce6 = Structures.mkUConst t_func' in\n  let ct_func = Structures.mkConst (Structures.declare_constant t_func ce6) in\n\n  let t_atom' = Atom.interp_tbl ra in\n  let ce1 = Structures.mkUConst t_atom' in\n  let ct_atom = Structures.mkConst (Structures.declare_constant t_atom ce1) in\n\n  let t_form' = snd (Form.interp_tbl rf) in\n  let ce2 = Structures.mkUConst t_form' in\n  let ct_form = Structures.mkConst (Structures.declare_constant t_form ce2) in\n\n  (* EMPTY LEMMA LIST *)\n  let (tres, last_root, cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf ct_i) (certif_ops (Some [|ct_i; ct_func; ct_atom; ct_form|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let used_roots = compute_roots roots last_root in\n  let roots =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n  let used_roots =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|]; Structures.mkArray (Lazy.force cint, res)|] in\n  let ce3 = Structures.mkUConst roots in\n  let _ = Structures.declare_constant root ce3 in\n  let ce3' = Structures.mkUConst used_roots in\n  let _ = Structures.declare_constant used_root ce3' in\n\n  let certif =\n    mklApp cCertif [|ct_i; ct_func; ct_atom; ct_form; mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n  let ce4 = Structures.mkUConst certif in\n  let _ = Structures.declare_constant trace ce4 in\n\n  ()\n\n\n(* Given an SMT-LIB2 file and a certif, build the corresponding theorem *)\n\nlet interp_roots t_i roots =\n  let interp = Form.interp_to_coq (Atom.interp_to_coq t_i (Hashtbl.create 17)) (Hashtbl.create 17) in\n  match roots with\n    | [] -> Lazy.force ctrue\n    | f::roots -> List.fold_left (fun acc f -> mklApp candb [|acc; interp f|]) (interp f) roots\n\nlet theorem name (rt, ro, ra, rf, roots, max_id, confl) =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n  let nused_roots = Structures.mkName \"used_roots\" in\n  let nd = Structures.mkName \"d\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = make_t_func ro (v 1 (*t_i*)) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n\n  (* EMPTY LEMMA LIST *)\n  let (tres,last_root,cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *)|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let certif =\n    mklApp cCertif [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *); mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|]; Structures.mkArray (Lazy.force cint, res)|] in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n\n  let theorem_concl = mklApp cnot [|mklApp cis_true [|interp_roots t_i roots|]|] in\n  let theorem_proof_cast =\n    Structures.mkCast (\n        Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n        Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n        Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n        Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n        Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n        Structures.mkLetIn (nused_roots, used_rootsCstr, mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n        Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n        mklApp cchecker_correct\n               [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*);\n\t         vm_cast_true_no_check\n\t           (mklApp cchecker [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|])|]))))))),\n        Structures.vmcast,\n        theorem_concl)\n  in\n  let theorem_proof_nocast =\n        Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n        Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n        Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n        Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n        Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n        Structures.mkLetIn (nused_roots, used_rootsCstr, mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n        Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n        mklApp cchecker_correct\n               [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|])))))))\n  in\n\n  let ce = Structures.mkTConst theorem_proof_cast theorem_proof_nocast theorem_concl in\n  let _ = Structures.declare_constant name ce in\n  ()\n\n\n(* Given an SMT-LIB2 file and a certif, call the checker *)\n\nlet checker (rt, ro, ra, rf, roots, max_id, confl) =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n  let nused_roots = Structures.mkName \"used_roots\" in\n  let nd = Structures.mkName \"d\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = make_t_func ro (v 1 (*t_i*)) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n\n  (* EMPTY LEMMA LIST *)\n  let (tres,last_root,cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *)|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let certif =\n    mklApp cCertif [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *); mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|]; Structures.mkArray (Lazy.force cint, res)|] in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n\n  let tm =\n   Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n   Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n   Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n   Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n   Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n   Structures.mkLetIn (nused_roots, used_rootsCstr, mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n   Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n   mklApp cchecker [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*); v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|]))))))) in\n\n  let res = Structures.cbv_vm (Global.env ()) tm (Lazy.force CoqTerms.cbool) in\n  Format.eprintf \"     = %s\\n     : bool@.\"\n    (if Structures.eq_constr res (Lazy.force CoqTerms.ctrue) then\n        \"true\" else \"false\")\n\nlet count_used confl =\n  let cpt = ref 0 in\n  let rec count c =\n    incr cpt;\n    (* if c.used = 1 then incr cpt; *)\n    match c.prev with\n    | None -> !cpt\n    | Some c -> count c\n  in\n  count confl\n\n\nlet checker_debug (rt, ro, ra, rf, roots, max_id, confl) =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n  let nused_roots = Structures.mkName \"used_roots\" in\n  let nd = Structures.mkName \"d\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = make_t_func ro (v 1 (*t_i*)) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n\n  let (tres,last_root,cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4(*t_i*); v 3(*t_func*);\n                          v 2(*t_atom*); v 1(* t_form *)|])) confl None in\n  List.iter (fun (v,ty) ->\n    let _ = Structures.declare_new_variable v ty in\n    print_assm ty\n  ) cuts;\n\n  let certif =\n    mklApp cCertif [|v 4(*t_i*); v 3(*t_func*); v 2(*t_atom*); v 1(* t_form *);\n                     mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    mklApp cSome [|mklApp carray [|Lazy.force cint|];\n                   Structures.mkArray (Lazy.force cint, res)|] in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n    Structures.mkArray (Lazy.force cint, res) in\n\n  let tm =\n   Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n   Structures.mkLetIn (ntfunc, t_func,\n                 mklApp carray [|mklApp ctval [|v 1(* t_i *)|]|],\n   Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n   Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n   Structures.mkLetIn (nc, certif, mklApp ccertif [|v 4 (*t_i*); v 3 (*t_func*);\n                                              v 2 (*t_atom*); v 1 (*t_form*)|],\n   Structures.mkLetIn (nused_roots, used_rootsCstr,\n                 mklApp coption [|mklApp carray [|Lazy.force cint|]|],\n   Structures.mkLetIn (nd, rootsCstr, mklApp carray [|Lazy.force cint|],\n   mklApp cchecker_debug [|v 7 (*t_i*); v 6 (*t_func*); v 5 (*t_atom*);\n       v 4 (*t_form*); v 1 (*d*); v 2 (*used_roots*); v 3 (*c*)|]))))))) in\n\n  let res = Structures.cbv_vm (Global.env ()) tm\n      (mklApp coption\n         [|mklApp cprod\n             [|Lazy.force cnat; Lazy.force cname_step|]|]) in\n\n  match Structures.decompose_app res with\n  | c, _ when Structures.eq_constr c (Lazy.force cNone) ->\n    Structures.error (\"Debug checker is only meant to be used for certificates \\\n                       that fail to be checked by SMTCoq.\")\n  | c, [_; n] when Structures.eq_constr c (Lazy.force cSome) ->\n    (match Structures.decompose_app n with\n     | c, [_; _; cnb; cn] when Structures.eq_constr c (Lazy.force cpair) ->\n       let n = fst (Structures.decompose_app cn) in\n       let name =\n         if Structures.eq_constr n (Lazy.force cName_Res ) then \"Res\"\n         else if Structures.eq_constr n (Lazy.force cName_Weaken) then \"Weaken\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmFlatten) then \"ImmFlatten\"\n         else if Structures.eq_constr n (Lazy.force cName_CTrue) then \"CTrue\"\n         else if Structures.eq_constr n (Lazy.force cName_CFalse ) then \"CFalse\"\n         else if Structures.eq_constr n (Lazy.force cName_BuildDef) then \"BuildDef\"\n         else if Structures.eq_constr n (Lazy.force cName_BuildDef2) then \"BuildDef2\"\n         else if Structures.eq_constr n (Lazy.force cName_BuildProj ) then \"BuildProj\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmBuildDef) then \"ImmBuildDef\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmBuildDef2) then \"ImmBuildDef2\"\n         else if Structures.eq_constr n (Lazy.force cName_ImmBuildProj ) then \"ImmBuildProj\"\n         else if Structures.eq_constr n (Lazy.force cName_EqTr ) then \"EqTr\"\n         else if Structures.eq_constr n (Lazy.force cName_EqCgr ) then \"EqCgr\"\n         else if Structures.eq_constr n (Lazy.force cName_EqCgrP) then \"EqCgrP\"\n         else if Structures.eq_constr n (Lazy.force cName_LiaMicromega ) then \"LiaMicromega\"\n         else if Structures.eq_constr n (Lazy.force cName_LiaDiseq) then \"LiaDiseq\"\n         else if Structures.eq_constr n (Lazy.force cName_SplArith) then \"SplArith\"\n         else if Structures.eq_constr n (Lazy.force cName_SplDistinctElim ) then \"SplDistinctElim\"\n         else if Structures.eq_constr n (Lazy.force cName_BBVar) then \"BBVar\"\n         else if Structures.eq_constr n (Lazy.force cName_BBConst) then \"BBConst\"\n         else if Structures.eq_constr n (Lazy.force cName_BBOp) then \"BBOp\"\n         else if Structures.eq_constr n (Lazy.force cName_BBNot) then \"BBNot\"\n         else if Structures.eq_constr n (Lazy.force cName_BBNeg) then \"BBNeg\"\n         else if Structures.eq_constr n (Lazy.force cName_BBAdd) then \"BBAdd\"\n         else if Structures.eq_constr n (Lazy.force cName_BBConcat) then \"BBConcat\"\n         else if Structures.eq_constr n (Lazy.force cName_BBMul) then \"BBMul\"\n         else if Structures.eq_constr n (Lazy.force cName_BBUlt) then \"BBUlt\"\n         else if Structures.eq_constr n (Lazy.force cName_BBSlt) then \"BBSlt\"\n         else if Structures.eq_constr n (Lazy.force cName_BBEq) then \"BBEq\"\n         else if Structures.eq_constr n (Lazy.force cName_BBDiseq) then \"BBDiseq\"\n         else if Structures.eq_constr n (Lazy.force cName_BBExtract) then \"BBExtract\"\n         else if Structures.eq_constr n (Lazy.force cName_BBZextend) then \"BBZextend\"\n         else if Structures.eq_constr n (Lazy.force cName_BBSextend) then \"BBSextend\"\n         else if Structures.eq_constr n (Lazy.force cName_BBShl) then \"BBShl\"\n         else if Structures.eq_constr n (Lazy.force cName_BBShr) then \"BBShr\"\n         else if Structures.eq_constr n (Lazy.force cName_RowEq) then \"RowEq\"\n         else if Structures.eq_constr n (Lazy.force cName_RowNeq) then \"RowNeq\"\n         else if Structures.eq_constr n (Lazy.force cName_Ext) then \"Ext\"\n         else if Structures.eq_constr n (Lazy.force cName_Hole) then \"Hole\"\n         else string_coq_constr n\n       in\n       let nb = mk_nat cnb + List.length roots + (confl.id + 1 - count_used confl) in\n       Structures.error (\"Step number \" ^ string_of_int nb ^\n                         \" (\" ^ name ^ \") of the certificate likely failed.\")\n     | _ -> assert false\n    )\n  | _ -> assert false\n\n\n\n(* let rec of_coq_list cl =\n *   match Structures.decompose_app cl with\n *   | c, _ when Structures.eq_constr c (Lazy.force cnil) -> []\n *   | c, [_; x; cr] when Structures.eq_constr c (Lazy.force ccons) ->\n *     x :: of_coq_list cr\n *   | _ -> assert false *)\n\n\n(* let checker_debug_step t_i t_func t_atom t_form root used_root trace\n *     (rt, ro, ra, rf, roots, max_id, confl) =\n * \n *   let t_i' = make_t_i rt in\n *   let ce5 = Structures.mkUConst t_i' in\n *   let ct_i = Structures.mkConst (Structures.declare_constant t_i ce5) in\n * \n *   let t_func' = make_t_func ro ct_i in\n *   let ce6 = Structures.mkUConst t_func' in\n *   let ct_func =\n *     Structures.mkConst (Structures.declare_constant t_func ce6) in\n * \n *   let t_atom' = Atom.interp_tbl ra in\n *   let ce1 = Structures.mkUConst t_atom' in\n *   let ct_atom =\n *     Structures.mkConst (Structures.declare_constant t_atom ce1) in\n * \n *   let t_form' = snd (Form.interp_tbl rf) in\n *   let ce2 = Structures.mkUConst t_form' in\n *   let ct_form =\n *     Structures.mkConst (Structures.declare_constant t_form ce2) in\n * \n *   let (tres, last_root, cuts) = SmtTrace.to_coq (fun i -> mkInt (Form.to_lit i))\n *       (interp_conseq_uf ct_i)\n *       (certif_ops (Some [|ct_i; ct_func; ct_atom; ct_form|])) confl None in\n *   List.iter (fun (v,ty) ->\n *     let _ = Structures.declare_new_variable v ty in\n *     print_assm ty\n *   ) cuts;\n * \n *   let used_roots = compute_roots roots last_root in\n *   let croots =\n *     let res = Array.make (List.length roots + 1) (mkInt 0) in\n *     let i = ref 0 in\n *     List.iter (fun j -> res.(!i) <- mkInt (Form.to_lit j); incr i) roots;\n *     Structures.mkArray (Lazy.force cint, res) in\n *   let cused_roots =\n *     let l = List.length used_roots in\n *     let res = Array.make (l + 1) (mkInt 0) in\n *     let i = ref (l-1) in\n *     List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n *     mklApp cSome [|mklApp carray [|Lazy.force cint|];\n *                    Structures.mkArray (Lazy.force cint, res)|] in\n *   let ce3 = Structures.mkUConst croots in\n *   let _ = Structures.declare_constant root ce3 in\n *   let ce3' = Structures.mkUConst cused_roots in\n *   let _ = Structures.declare_constant used_root ce3' in\n * \n *   let certif =\n *     mklApp cCertif [|ct_i; ct_func; ct_atom; ct_form; mkInt (max_id + 1);\n *                      tres;mkInt (get_pos confl)|] in\n *   let ce4 = Structures.mkUConst certif in\n *   let _ = Structures.declare_constant trace ce4 in\n * \n *   let setup =\n *    mklApp csetup_checker_step_debug\n *      [| ct_i; ct_func; ct_atom; ct_form; croots; cused_roots; certif |] in\n * \n *   let setup = Structures.cbv_vm (Global.env ()) setup\n *       (mklApp cprod\n *          [|Lazy.force cState_S_t;\n *            mklApp clist [|mklApp cstep\n *                             [|ct_i; ct_func; ct_atom; ct_form|]|]|]) in\n * \n *   let s, steps = match Structures.decompose_app setup with\n *     | c, [_; _; s; csteps] when Structures.eq_constr c (Lazy.force cpair) ->\n *       s, of_coq_list csteps\n *     | _ -> assert false\n *   in\n * \n *   let cpt = ref (List.length roots) in\n *   let debug_step s step =\n *     incr cpt;\n *     Format.eprintf \"%d@.\" !cpt;\n *     let tm =\n *       mklApp cchecker_step_debug\n *         [| ct_i; ct_func; ct_atom; ct_form; s; step |] in\n * \n *     let res =\n *       Structures.cbv_vm (Global.env ()) tm\n *           (mklApp cprod [|Lazy.force cState_S_t; Lazy.force cbool|]) in\n * \n *     match Structures.decompose_app res with\n *     | c, [_; _; s; cbad] when Structures.eq_constr c (Lazy.force cpair) ->\n *       if not (mk_bool cbad) then s\n *       else Structures.error (\"Step number \" ^ string_of_int !cpt ^\n *                              \" (\" ^ string_coq_constr\n *                                (fst (Structures.decompose_app step)) ^ \")\" ^\n *                              \" of the certificate likely failed.\" )\n *     | _ -> assert false\n *   in\n * \n *   List.fold_left debug_step s steps |> ignore;\n * \n *   Structures.error (\"Debug checker is only meant to be used for certificates \\\n *                      that fail to be checked by SMTCoq.\") *)\n\n\n\n(* Tactic *)\n\nlet build_body rt ro ra rf l b (max_id, confl) vm_cast find =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = Structures.lift 1 (make_t_func ro (v 0 (*t_i - 1*))) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n  let (tres,_,cuts) = SmtTrace.to_coq Form.to_coq\n      (interp_conseq_uf t_i)\n      (certif_ops\n         (Some [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|]))\n      confl find\n  in\n  let certif =\n    mklApp cCertif\n      [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*);\n        mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let add_lets t =\n    Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n    Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(*t_i*)|]|],\n    Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n    Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n    Structures.mkLetIn (nc, certif, mklApp ccertif\n             [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n    t))))) in\n\n  let cbc =\n    add_lets\n      (mklApp cchecker_b [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*);\n                           v 2 (*t_form*); l; b; v 1 (*certif*)|])\n    |> vm_cast\n  in\n\n  let proof_cast =\n    add_lets\n      (mklApp cchecker_b_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l; b; v 1 (*certif*); cbc |]) in\n\n  let proof_nocast =\n    add_lets\n      (mklApp cchecker_b_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l; b; v 1 (*certif*)|]) in\n\n  (proof_cast, proof_nocast, cuts)\n\n\nlet build_body_eq rt ro ra rf l1 l2 l (max_id, confl) vm_cast find =\n  let nti = Structures.mkName \"t_i\" in\n  let ntfunc = Structures.mkName \"t_func\" in\n  let ntatom = Structures.mkName \"t_atom\" in\n  let ntform = Structures.mkName \"t_form\" in\n  let nc = Structures.mkName \"c\" in\n\n  let v = Structures.mkRel in\n\n  let t_i = make_t_i rt in\n  let t_func = Structures.lift 1 (make_t_func ro (v 0 (*t_i*))) in\n  let t_atom = Atom.interp_tbl ra in\n  let t_form = snd (Form.interp_tbl rf) in\n  let (tres,_,cuts) = SmtTrace.to_coq Form.to_coq\n      (interp_conseq_uf t_i)\n      (certif_ops (Some [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|])) confl find in\n  let certif =\n    mklApp cCertif [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*); mkInt (max_id + 1); tres;mkInt (get_pos confl)|] in\n\n  let add_lets t =\n    Structures.mkLetIn (nti, t_i, mklApp carray [|Lazy.force ctyp_compdec|],\n    Structures.mkLetIn (ntfunc, t_func, mklApp carray [|mklApp ctval [|v 1(*t_i*)|]|],\n    Structures.mkLetIn (ntatom, t_atom, mklApp carray [|Lazy.force catom|],\n    Structures.mkLetIn (ntform, t_form, mklApp carray [|Lazy.force cform|],\n    Structures.mkLetIn (nc, certif, mklApp ccertif\n             [|v 4 (*t_i*); v 3 (*t_func*); v 2 (*t_atom*); v 1 (*t_form*)|],\n    t))))) in\n\n  let ceqc =\n    add_lets\n      (mklApp cchecker_eq [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*);\n                            v 2 (*t_form*); l1; l2; l; v 1 (*certif*)|])\n      |> vm_cast\n  in\n\n  let proof_cast =\n    add_lets\n      (mklApp cchecker_eq_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l1; l2; l; v 1 (*certif*); ceqc|])\n  in\n  let proof_nocast =\n    add_lets\n      (mklApp cchecker_eq_correct\n         [|v 5 (*t_i*);v 4 (*t_func*);v 3 (*t_atom*); v 2 (*t_form*);\n           l1; l2; l; v 1 (*certif*)|])\n  in\n\n  (proof_cast, proof_nocast, cuts)\n\n\nlet get_arguments concl =\n  let f, args = Structures.decompose_app concl in\n  match args with\n  | [ty;a;b] when (Structures.eq_constr f (Lazy.force ceq)) && (Structures.eq_constr ty (Lazy.force cbool)) -> a, b\n  | [a] when (Structures.eq_constr f (Lazy.force cis_true)) -> a, Lazy.force ctrue\n  | _ -> failwith (\"Verit.tactic: can only deal with equality over bool\")\n\n\nlet make_proof call_solver env rt ro ra_quant rf_quant l ls_smtc =\n  let root = SmtTrace.mkRootV [l] in\n  call_solver env rt ro ra_quant rf_quant (root,l) ls_smtc\n(* TODO: not generic anymore, the \"lemma\" part is currently specific to veriT *)\n\n(* <of_coq_lemma> reifies the given coq lemma, so we can then easily print it in a\n .smt2 file. We need the reify tables to correctly recognize free variables\n of the lemma. We also need to make sure to leave unchanged the tables because\n the new objects may contain bound (by forall of the lemma) variables. *)\n\n(* Bound variables are given fresh names to avoid variable capture *)\nlet gen_rel_name =\n  let num = ref (-1) in\n  fun () -> incr num; \"SMTCoqRelName\"^(string_of_int !num)\n\nlet of_coq_lemma rt ro ra_quant rf_quant env sigma solver_logic clemma =\n  let warn () =\n    Structures.warning \"Lemma\" (\"Discarding the following lemma (unsupported): \"^(Pp.string_of_ppcmds (Ppconstr.pr_constr_expr (Structures.extern_constr clemma))));\n    None\n  in\n\n  let rel_context, qf_lemma = Term.decompose_prod_assum clemma in\n  (* Bound variables are given fresh names to avoid variable capture *)\n  let rel_context = List.map (fun rel -> Context.Rel.Declaration.set_name (Names.Name.mk_name (Names.Id.of_string (gen_rel_name ()))) rel) rel_context in\n\n  let env_lemma = Environ.push_rel_context rel_context env in\n  let f, args = Structures.decompose_app qf_lemma in\n  let core_f =\n    if Structures.eq_constr f (Lazy.force cis_true) then\n      match args with\n      | [a] -> Some a\n      | _ -> warn ()\n    else if Structures.eq_constr f (Lazy.force ceq) then\n      match args with\n      | [ty; arg1; arg2] when Structures.eq_constr ty (Lazy.force cbool) &&\n                                Structures.eq_constr arg2 (Lazy.force ctrue) ->\n         Some arg1\n      | _ -> warn ()\n    else warn () in\n  let core_smt =\n    match core_f with\n      | Some core_f ->\n         (try\n            Some (Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env_lemma sigma) rf_quant core_f)\n          with\n            | Atom.UnknownUnderForall -> warn ()\n         )\n      | None -> None\n  in\n  let forall_args =\n    let fmap r = let n, t = Structures.destruct_rel_decl r in\n                 Structures.string_of_name n, SmtBtype.of_coq rt solver_logic t in\n    List.map fmap rel_context\n  in\n  match forall_args with\n    | [] -> core_smt\n    | _ ->\n       (match core_smt with\n          | Some core_smt -> Some (Form.get rf_quant (Fapp (Fforall forall_args, [|core_smt|])))\n          | None -> None)\n\nlet core_tactic call_solver solver_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl env sigma concl =\n  let a, b = get_arguments concl in\n\n  let tlcepl = List.map (Structures.interp_constr env sigma) lcepl in\n  let lcpl = lcpl @ tlcepl in\n\n  let create_lemma l =\n    let cl = Structures.retyping_get_type_of env sigma l in\n    match of_coq_lemma rt ro ra_quant rf_quant env sigma solver_logic cl with\n      | Some smt -> Some ((cl, l), smt)\n      | None -> None\n  in\n  let l_pl_ls = SmtMisc.filter_map create_lemma lcpl in\n  let lsmt = List.map snd l_pl_ls in\n\n  let lem_tbl : (int, Structures.constr * Structures.constr) Hashtbl.t =\n    Hashtbl.create 100 in\n  let new_ref ((l, pl), ls) =\n    Hashtbl.add lem_tbl (Form.index ls) (l, pl) in\n\n  List.iter new_ref l_pl_ls;\n\n  let find_lemma cl =\n    let re_hash hf = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant hf in\n    match cl.value with\n    | Some [l] ->\n       let hl = re_hash l in\n       begin try Hashtbl.find lem_tbl (Form.index hl)\n             with Not_found ->\n               let oc = open_out \"/tmp/find_lemma.log\" in\n               let fmt = Format.formatter_of_out_channel oc in\n               List.iter (fun u -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) u) lsmt;\n               Format.fprintf fmt \"\\n%a\\n\" (Form.to_smt ~debug:true) hl;\n               flush oc; close_out oc; failwith \"find_lemma\" end\n      | _ -> failwith \"unexpected form of root\" in\n\n  let (body_cast, body_nocast, cuts) =\n    if ((Structures.eq_constr b (Lazy.force ctrue)) ||\n        (Structures.eq_constr b (Lazy.force cfalse))) then (\n      let l = Form.of_coq (Atom.of_coq rt ro ra solver_logic env sigma) rf a in\n      let _ = Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env sigma) rf_quant a in\n      let nl = if (Structures.eq_constr b (Lazy.force ctrue)) then Form.neg l else l in\n      let lsmt = Form.flatten rf nl :: lsmt in\n      let max_id_confl = make_proof call_solver env rt ro ra_quant rf_quant nl lsmt in\n      build_body rt ro ra rf (Form.to_coq l) b max_id_confl (vm_cast env) (Some find_lemma)\n    ) else (\n      let l1 = Form.of_coq (Atom.of_coq rt ro ra solver_logic env sigma) rf a in\n      let _ = Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env sigma) rf_quant a in\n      let l2 = Form.of_coq (Atom.of_coq rt ro ra solver_logic env sigma) rf b in\n      let _ = Form.of_coq (Atom.of_coq ~eqsym:true rt ro ra_quant solver_logic env sigma) rf_quant b in\n      let l = Form.get rf (Fapp(Fiff,[|l1;l2|])) in\n      let nl = Form.neg l in\n      let lsmt = Form.flatten rf nl :: lsmt in\n      let max_id_confl = make_proof call_solver env rt ro ra_quant rf_quant nl lsmt in\n      build_body_eq rt ro ra rf (Form.to_coq l1) (Form.to_coq l2)\n        (Form.to_coq nl) max_id_confl (vm_cast env) (Some find_lemma) ) in\n\n      let cuts = (SmtBtype.get_cuts rt) @ cuts in\n\n  List.fold_right (fun (eqn, eqt) tac ->\n      Structures.tclTHENLAST\n        (Structures.assert_before (Structures.name_of_id eqn) eqt)\n        tac\n    ) cuts\n    (Structures.tclTHEN\n       (Structures.set_evars_tac body_nocast)\n       (Structures.vm_cast_no_check body_cast))\n\n\nlet tactic call_solver solver_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl =\n  Structures.tclTHEN\n    Tactics.intros\n    (Structures.mk_tactic (core_tactic call_solver solver_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl))\n\n\n(**********************************************)\n(* Show solver models as Coq counter-examples *)\n(**********************************************)\n\n\nopen SExpr\nopen Smtlib2_genConstr\nopen Format\n\n\nlet string_index_of_constr env i cf =\n  try\n    let s = string_coq_constr cf in\n    let nc = Environ.named_context env in\n    let nd = Environ.lookup_named (Structures.mkId s) env in\n    let cpt = ref 0 in\n    (try List.iter (fun n -> incr cpt; if n == nd then raise Exit) nc\n     with Exit -> ());\n    s, !cpt\n  with _ -> string_coq_constr cf, -i\n\n\nlet vstring_i env i =\n  let cf = SmtAtom.Atom.get_coq_term_op i in\n  if Structures.isRel cf then\n    let dbi = Structures.destRel cf in\n    let s =\n      Environ.lookup_rel dbi env\n      |> Structures.get_rel_dec_name\n      |> SmtMisc.string_of_name_def \"?\"\n    in\n    s, dbi\n  else\n    string_index_of_constr env i cf\n\n\nlet sstring_i env i v =\n  let tf = SmtBtype.get_coq_type_op i in\n  let (s, idx) = string_index_of_constr env i tf in\n  (s^\"#\"^v, idx)\n\n\nlet smt2_id_to_coq_string env t_i ra rf name =\n  try\n    let l = String.split_on_char '_' name in\n    match l with\n      | [\"op\"; i] -> vstring_i env (int_of_string i)\n      | [\"@uc\"; \"Tindex\"; i; j] -> sstring_i env (int_of_string i) j\n      | _ -> raise Not_found\n  with _ -> (name, 0)\n\n\nlet op_to_coq_string op = match op with\n  | \"=\" | \"+\" | \"-\" | \"*\" | \"/\" -> op\n  | \"or\" -> \"||\"\n  | \"and\" -> \"&&\"\n  | \"xor\" -> \"xorb\"\n  | \"=>\" -> \"implb\"\n  | _ -> op\n\n\nlet coq_bv_string s =\n  let rec aux acc = function\n    | true :: r -> aux (acc ^ \"|1\") r\n    | false :: r -> aux (acc ^ \"|0\") r\n    | [] -> \"#b\" ^ acc ^ \"|\"\n  in\n  if String.length s < 3 ||\n     not (s.[0] = '#' && s.[1] = 'b') then failwith \"not bv\";\n  aux \"\" (parse_smt2bv s)\n\n\nlet is_bvint bs =\n  try Scanf.sscanf bs \"bv%s\" (fun s ->\n      try ignore (Big_int.big_int_of_string s); true\n      with _ -> false)\n  with _ -> false\n\n\nlet rec smt2_sexpr_to_coq_string env t_i ra rf =\n  let open SExpr in function\n  | Atom \"true\" -> \"true\"\n  | Atom \"false\" -> \"false\"\n  | Atom s ->\n    (try ignore (int_of_string s); s\n     with Failure _ ->\n     try coq_bv_string s\n     with Failure _ ->\n     try fst (smt2_id_to_coq_string env t_i ra rf s)\n     with _ -> s)\n  | List [Atom \"as\"; Atom \"const\"; _] -> \"const_farray\"\n  | List [Atom \"as\"; s; _] -> smt2_sexpr_to_coq_string env t_i ra rf s\n  | List [Atom \"_\"; Atom bs; Atom s] when is_bvint bs ->\n    Scanf.sscanf bs \"bv%s\" (fun i ->\n        coq_bv_string (bigint_bv (Big_int.big_int_of_string i)\n                         (int_of_string s)))\n  | List [Atom \"-\"; Atom _ as s] ->\n    sprintf \"-%s\"\n      (smt2_sexpr_to_coq_string env t_i ra rf s)\n  | List [Atom \"-\"; s] ->\n    sprintf \"(- %s)\"\n      (smt2_sexpr_to_coq_string env t_i ra rf s)\n  | List [Atom ((\"+\"|\"-\"|\"*\"|\"/\"|\"or\"|\"and\"|\"=\") as op); s1; s2] ->\n    sprintf \"%s %s %s\"\n      (smt2_sexpr_to_coq_string env t_i ra rf s1)\n      (op_to_coq_string op)\n      (smt2_sexpr_to_coq_string env t_i ra rf s2)\n  | List [Atom ((\"xor\"|\"=>\"|\"\") as op); s1; s2] ->\n    sprintf \"(%s %s %s)\"\n      (op_to_coq_string op)\n      (smt2_sexpr_to_coq_string env t_i ra rf s1)\n      (smt2_sexpr_to_coq_string env t_i ra rf s2)\n  | List [Atom \"select\"; a; i] ->\n    sprintf \"%s[%s]\"\n      (smt2_sexpr_to_coq_string env t_i ra rf a)\n      (smt2_sexpr_to_coq_string env t_i ra rf i)\n  | List [Atom \"store\"; a; i; v] ->\n    sprintf \"%s[%s <- %s]\"\n      (smt2_sexpr_to_coq_string env t_i ra rf a)\n      (smt2_sexpr_to_coq_string env t_i ra rf i)\n      (smt2_sexpr_to_coq_string env t_i ra rf v)\n  | List [Atom \"ite\"; c; s1; s2] ->\n    sprintf \"if %s then %s else %s\"\n      (smt2_sexpr_to_coq_string env t_i ra rf c)\n      (smt2_sexpr_to_coq_string env t_i ra rf s1)\n      (smt2_sexpr_to_coq_string env t_i ra rf s2)\n  | List l ->\n    sprintf \"(%s)\"\n      (String.concat \" \" (List.map (smt2_sexpr_to_coq_string env t_i ra rf) l))\n\n\nlet str_contains s1 s2 =\n  let re = Str.regexp_string s2 in\n  try ignore (Str.search_forward re s1 0); true\n  with Not_found -> false\n\nlet lambda_to_coq_string l s =\n  Format.sprintf \"fun %s => %s\"\n    (String.concat \" \"\n       (List.map (function\n            | List [Atom v; _] ->\n              if str_contains s v then v else \"_\"\n            | _ -> assert false) l))\n    s\n\ntype model =\n  | Fun of ((string * int) * string)\n  | Sort\n\nlet model_item env rt ro ra rf =\n  let t_i = make_t_i rt in\n  function\n  | List [Atom \"define-fun\"; Atom n; List []; _; expr] ->\n     Fun (smt2_id_to_coq_string env t_i ra rf n,\n           smt2_sexpr_to_coq_string env t_i ra rf expr)\n\n  | List [Atom \"define-fun\"; Atom n; List l; _; expr] ->\n     Fun (smt2_id_to_coq_string env t_i ra rf n,\n           lambda_to_coq_string l\n             (smt2_sexpr_to_coq_string env t_i ra rf expr))\n\n  | List [Atom \"declare-sort\"; Atom n; _] ->\n     Sort\n\n  | l ->\n     (* let out = open_out_gen [Open_append] 700 \"/tmp/test.log\" in\n      * let outf = Format.formatter_of_out_channel out in\n      * SExpr.print outf l; pp_print_flush outf ();\n      * close_out out; *)\n     Structures.error (\"Could not reconstruct model\")\n\n\nlet model env rt ro ra rf = function\n  | List (Atom \"model\" :: l) ->\n     List.fold_left (fun acc m -> match model_item env rt ro ra rf m with Fun m -> m::acc | Sort -> acc) [] l\n     |> List.sort (fun ((_ ,i1), _) ((_, i2), _) -> i2 - i1)\n  | _ -> Structures.error (\"No model\")\n\n\nlet model_string env rt ro ra rf s =\n  String.concat \"\\n\"\n    (List.map (fun ((x, _) ,v) -> Format.sprintf \"%s := %s\" x v)\n       (model env rt ro ra rf s))\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":295,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 295, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":296,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 296, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":297,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 297, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":298,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":260,"character":0},"end":{"line":316,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 298, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":299,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":269,"character":33}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 299, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":300,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 300, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":301,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":269,"character":33},"end":{"line":269,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 301, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":302,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":267,"character":32}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 302, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":303,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":264,"character":35}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 303, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":304,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":263,"character":37}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 304, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":305,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 305, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":306,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 306, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":307,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":288,"character":11},"end":{"line":288,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 307, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":308,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":287,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Sending response {"id": 308, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":309,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":248,"character":47},"end":{"line":248,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 309, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":310,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":233,"character":47},"end":{"line":233,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 310, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":311,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 311, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":312,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 312, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":313,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":288,"character":11},"end":{"line":288,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 313, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":314,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":282,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 314, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":315,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 315, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":316,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":23,"character":4},"end":{"line":23,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 316, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":317,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":22,"character":4},"end":{"line":22,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 317, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":318,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":26,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 318, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":319,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":25,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 319, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":320,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":26,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.032901763916ms
Sending response {"id": 320, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":321,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":133,"character":20}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 321, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":322,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 322, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":323,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":133,"character":20},"end":{"line":133,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 323, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":324,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":134,"character":2},"end":{"line":134,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 324, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":325,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":134,"character":2},"end":{"line":134,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 325, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":326,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":134,"character":2},"end":{"line":134,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 326, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":327,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":134,"character":2},"end":{"line":134,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 327, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":328,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":262,"character":0},"end":{"line":262,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 328, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":329,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":262,"character":0},"end":{"line":262,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 329, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":330,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":266,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 330, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":331,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":267,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 331, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":332,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 332, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":333,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 333, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":334,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":288,"character":4},"end":{"line":288,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 334, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":335,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 335, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":336,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":288,"character":11}}}
[server] Got a method textDocument/definition
[server] processing took 0.00405311584473ms
Sending response {"id": 336, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":337,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 337, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":338,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":288,"character":4},"end":{"line":288,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 338, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":339,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":279,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.00619888305664ms
Sending response {"id": 339, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":340,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":260,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0159740447998ms
Sending response {"id": 340, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":341,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 341, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":342,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":260,"character":12},"end":{"line":260,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 342, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":343,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":241,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 343, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":344,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":205,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 344, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":345,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":210,"character":3}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 345, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":346,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":211,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 346, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":347,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":211,"character":6}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 347, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":348,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":211,"character":6},"end":{"line":211,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 348, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":349,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"range":{"start":{"line":211,"character":4},"end":{"line":211,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 349, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":350,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":246,"character":40}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 350, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":351,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":251,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 351, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":352,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":252,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.018835067749ms
Sending response {"id": 352, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":353,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":252,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 353, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":354,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"},"position":{"line":240,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 354, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n(** Sharing of coq Int *)\nlet cInt_tbl = Hashtbl.create 17 \n\nlet mkInt i = \n  try Hashtbl.find cInt_tbl i \n  with Not_found ->\n    let ci = Structures.mkInt i in\n    Hashtbl.add cInt_tbl i ci;\n    ci\n\n(** Generic representation of shared object *)\ntype 'a gen_hashed = { index : int; mutable hval : 'a }\n\n\n(** Functions over constr *)\nlet mklApp f args = Structures.mkApp (Lazy.force f, args)\n\nlet string_of_name_def d n = try Structures.string_of_name n with | _ -> d\n\nlet string_coq_constr t =\n  let rec fix rf x = rf (fix rf) x in\n  let pr = fix\n      Ppconstr.modular_constr_pr Pp.mt Structures.ppconstr_lsimpleconstr in\n  Pp.string_of_ppcmds (pr (Structures.constrextern_extern_constr t))\n\n\n(** Logics *)\n\ntype logic_item =\n  | LUF\n  | LLia\n  | LBitvectors\n  | LArrays\n\nmodule SL = Set.Make (struct\n    type t = logic_item\n    let compare = Pervasives.compare\n  end)\n\ntype logic = SL.t\n\n\n(** Utils *)\nlet rec filter_map f = function\n  | [] -> []\n  | x::xs -> match f x with Some x -> x::(filter_map f xs) | None -> filter_map f xs\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":355,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 355, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":356,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 356, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":357,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 357, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":358,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":27,"character":0},"end":{"line":27,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 358, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":355}}
Read message 
{"jsonrpc":"2.0","id":359,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":19,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 359, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":360,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":26,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0171661376953ms
Sending response {"id": 360, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":361,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":27,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 361, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":362,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 362, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":363,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":27,"character":20},"end":{"line":27,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 363, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":364,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":26,"character":28},"end":{"line":26,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 364, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":365,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":27,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 365, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":366,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":27,"character":33}}}
[server] Got a method textDocument/definition
[server] processing took 0.00691413879395ms
Sending response {"id": 366, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":367,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":27,"character":20},"end":{"line":27,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 367, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":368,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":27,"character":33}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 368, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":369,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"position":{"line":27,"character":33}}}
[server] Got a method textDocument/definition
[server] processing took 0.00810623168945ms
Sending response {"id": 369, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml","version":1},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n(** Sharing of coq Int *)\nlet cInt_tbl = Hashtbl.create 17 \n\nlet mkInt i = \n  try Hashtbl.find cInt_tbl i \n  with Not_found ->\n    let ci = Structures.mkInt i in\n    Hashtbl.add cInt_tbl i ci;\n    ci\n\n(** Generic representation of shared object *)\ntype 'a gen_hashed = { index : int; mutable hval : 'a }\n\n\n(** Functions over constr *)\nlet mklApp f args = Structures.mkApp (Lazy.force f, args)\n\nlet string_of_name_def d n = try Structures.string_of_name n with | _ -> d\n\nlet string_coq_constr t =\n  let rec fix rf x = rf (fix rf) x in\n  let pr = fix\n      Ppconstr.modular_constr_pr Pp.mt Structures.ppconstr_lsimpleconstr in\n  Pp.string_of_ppcmds (pr (Structures.constrextern_extern_constr t))\n\n\n(** Logics *)\n\ntype logic_item =\n  | LUF\n  | LLia\n  | LBitvectors\n  | LArrays\n\nmodule SL = Set.Make (struct\n    type t = logic_item\n    let compare = Pervasives.compare\n  end)\n\ntype logic = SL.t\n\n\n(** Utils *)\nlet rec filter_map f = function\n  | [] -> []\n  | x::xs -> match f x with Some x -> x::(filter_map f xs) | None -> filter_map f xs\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":370,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 370, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":371,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 371, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":372,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 372, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":373,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":27,"character":20},"end":{"line":27,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 373, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":374,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 374, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":375,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00977516174316ms
Sending response {"id": 375, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":376,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 376, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":377,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0638961791992ms
Sending response {"id": 377, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":378,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 378, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":379,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0162124633789ms
Sending response {"id": 379, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":380,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"position":{"line":3,"character":27}}}
[server] Got a method textDocument/hover
[server] processing took 0.0350475311279ms
Sending response {"id": 380, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":381,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 381, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":382,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 382, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":383,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"},"range":{"start":{"line":27,"character":20},"end":{"line":27,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 383, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":384,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMisc.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 384, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Entries\nopen Coqlib\n\n\n(* Constr generation and manipulation *)\ntype id = Names.identifier\nlet mkId = Names.id_of_string\n\n\ntype name = Names.name\nlet name_of_id i = Names.Name i\nlet mkName s =\n  let id = mkId s in\n  name_of_id id\nlet string_of_name = function\n    Names.Name id -> Names.string_of_id id\n  | _ -> failwith \"unnamed rel\"\n\n\ntype constr = Term.constr\ntype types = Term.types\nlet eq_constr = Term.eq_constr\nlet hash_constr = Term.hash_constr\nlet mkProp = Term.mkProp\nlet mkConst = Term.mkConst\nlet mkVar = Term.mkVar\nlet mkRel = Term.mkRel\nlet isRel = Term.isRel\nlet destRel = Term.destRel\nlet lift = Term.lift\nlet mkApp = Term.mkApp\nlet decompose_app = Term.decompose_app\nlet mkLambda = Term.mkLambda\nlet mkProd = Term.mkProd\nlet mkLetIn = Term.mkLetIn\n\nlet pr_constr_env = Printer.pr_constr_env\nlet pr_constr = Printer.pr_constr\n\n\nlet dummy_loc = Pp.dummy_loc\n\nlet mkUConst c =\n  { const_entry_body = c;\n    const_entry_type = None;\n    const_entry_secctx = None;\n    const_entry_opaque = false;\n    const_entry_inline_code = false}\n\nlet mkTConst c _ ty =\n  { const_entry_body = c;\n    const_entry_type = Some ty;\n    const_entry_secctx = None;\n    const_entry_opaque = false;\n    const_entry_inline_code = false}\n\n(* TODO : Set -> Type *)\nlet declare_new_type t =\n  Command.declare_assumption false (Decl_kinds.Local,Decl_kinds.Definitional) Term.mkSet [] false None (dummy_loc, t);\n  Term.mkVar t\n\nlet declare_new_variable v constr_t =\n  Command.declare_assumption false (Decl_kinds.Local,Decl_kinds.Definitional) constr_t [] false None (dummy_loc, v);\n  Term.mkVar v\n\nlet declare_constant n c =\n  Declare.declare_constant n (DefinitionEntry c, Decl_kinds.IsDefinition Decl_kinds.Definition)\n\n\ntype cast_kind = Term.cast_kind\nlet vmcast = Term.VMcast\nlet mkCast = Term.mkCast\n\n\n(* EConstr *)\ntype econstr = Term.constr\nlet econstr_of_constr e = e\n\n\n(* Modules *)\nlet gen_constant modules constant = lazy (gen_constant_in_modules \"SMT\" modules constant)\n\n\n(* Int63 *)\nlet int63_modules = [[\"Coq\";\"Numbers\";\"Cyclic\";\"Int63\";\"Int63Native\"]]\n\nlet mkInt : int -> Term.constr =\n  fun i -> Term.mkInt (Uint63.of_int i)\n\nlet cint = gen_constant int63_modules \"int\"\n\n\n(* PArray *)\nlet parray_modules = [[\"Coq\";\"Array\";\"PArray\"]]\n\nlet max_array_size : int =\n  Parray.trunc_size (Uint63.of_int 4194303)\nlet mkArray : Term.types * Term.constr array -> Term.constr =\n  Term.mkArray\n\n\n(* Traces *)\n(* WARNING: side effect on r! *)\nlet mkTrace step_to_coq next carray _ _ _ _ size step def_step r =\n  let max = max_array_size - 1 in\n  let q,r1 = size / max, size mod max in\n  let trace =\n    let len = if r1 = 0 then q + 1 else q + 2 in\n    Array.make len (mkArray (step, [|def_step|])) in\n  for j = 0 to q - 1 do\n    let tracej = Array.make max_array_size def_step in\n    for i = 0 to max - 1 do\n      r := next !r;\n      tracej.(i) <- step_to_coq !r;\n    done;\n    trace.(j) <- mkArray (step, tracej)\n  done;\n  if r1 <> 0 then (\n    let traceq = Array.make (r1 + 1) def_step in\n    for i = 0 to r1-1 do\n      r := next !r;\n    traceq.(i) <- step_to_coq !r;\n    done;\n    trace.(q) <- mkArray (step, traceq)\n  );\n  mkArray (Term.mkApp (Lazy.force carray, [|step|]), trace)\n\n\n(* Micromega *)\nmodule Micromega_plugin_Micromega = Micromega\nmodule Micromega_plugin_Mutils = Mutils\nmodule Micromega_plugin_Certificate = Certificate\nmodule Micromega_plugin_Coq_micromega = Coq_micromega\n\nlet micromega_coq_proofTerm =\n  Coq_micromega.M.coq_proofTerm\n\nlet micromega_dump_proof_term p =\n  Coq_micromega.dump_proof_term p\n\n\n(* Tactics *)\ntype tactic = Proof_type.tactic\nlet tclTHEN = Tacticals.tclTHEN\nlet tclTHENLAST = Tacticals.tclTHENLAST\nlet assert_before = Tactics.assert_tac\nlet vm_cast_no_check = Tactics.vm_cast_no_check\nlet mk_tactic tac gl =\n  let env = Tacmach.pf_env gl in\n  let sigma = Tacmach.project gl in\n  let t = Tacmach.pf_concl gl in\n  tac env sigma t gl\nlet set_evars_tac _ = Tacticals.tclIDTAC\n\n\n(* Other differences between the two versions of Coq *)\ntype constr_expr = Topconstr.constr_expr\nlet error = Errors.error\nlet warning _ s = Pp.warning s\nlet extern_constr = Constrextern.extern_constr true Environ.empty_env\nlet destruct_rel_decl (n, _, t) = n, t\nlet interp_constr env sigma = Constrintern.interp_constr sigma env\nlet ppconstr_lsimpleconstr = Ppconstr.lsimple\nlet constrextern_extern_constr =\n  let env = Global.env () in\n  Constrextern.extern_constr false env\n\nlet get_rel_dec_name = fun _ -> Names.Anonymous\n\n(* Eta-expanded to get rid of optional arguments *)\nlet retyping_get_type_of env = Retyping.get_type_of env\n\nlet vm_conv = Reduction.vm_conv\nlet cbv_vm = Vnorm.cbv_vm\n\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":385,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 385, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":386,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 386, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":387,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 387, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":388,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"range":{"start":{"line":167,"character":37},"end":{"line":167,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 388, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":389,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":170,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 389, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":390,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 390, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":391,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"range":{"start":{"line":170,"character":14},"end":{"line":170,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 391, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":392,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":169,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 392, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":393,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":170,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 393, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":394,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":170,"character":9}}}
[server] Got a method textDocument/definition
[server] processing took 0.00715255737305ms
Sending response {"id": 394, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":395,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"range":{"start":{"line":42,"character":4},"end":{"line":42,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 395, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":396,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":42,"character":18}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Sending response {"id": 396, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":397,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"range":{"start":{"line":42,"character":17},"end":{"line":42,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 397, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":398,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":42,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 398, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":399,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":42,"character":18}}}
[server] Got a method textDocument/definition
[server] processing took 0.00905990600586ms
Sending response {"id": 399, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":400,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0579357147217ms
Sending response {"id": 400, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":401,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0619888305664ms
Sending response {"id": 401, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":402,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":39,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0138282775879ms
Sending response {"id": 402, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":403,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":39,"character":9}}}
[server] Got a method textDocument/definition
[server] processing took 0.00715255737305ms
Sending response {"id": 403, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":404,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"range":{"start":{"line":39,"character":9},"end":{"line":39,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 404, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":405,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":39,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Sending response {"id": 405, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":406,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 406, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":407,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":38,"character":9}}}
[server] Got a method textDocument/definition
[server] processing took 0.00500679016113ms
Sending response {"id": 407, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":408,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 408, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":409,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":37,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 409, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":410,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"},"position":{"line":38,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0147819519043ms
Sending response {"id": 410, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":411,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 411, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":412,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 412, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":413,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 413, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"verit/veritLexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open VeritParser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"verit/veritLexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"verit/veritLexer.mll\"\n                               ( token lexbuf )\n# 791 \"verit/veritLexer.ml\"\n\n  | 1 ->\n# 164 \"verit/veritLexer.mll\"\n                               ( EOL )\n# 796 \"verit/veritLexer.ml\"\n\n  | 2 ->\n# 166 \"verit/veritLexer.mll\"\n                               ( COLON )\n# 801 \"verit/veritLexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"verit/veritLexer.mll\"\n                i\n# 807 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"verit/veritLexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"verit/veritLexer.ml\"\n\n  | 4 ->\n# 169 \"verit/veritLexer.mll\"\n                               ( LPAR )\n# 816 \"verit/veritLexer.ml\"\n\n  | 5 ->\n# 170 \"verit/veritLexer.mll\"\n                               ( RPAR )\n# 821 \"verit/veritLexer.ml\"\n\n  | 6 ->\n# 172 \"verit/veritLexer.mll\"\n                               ( LBRACKET )\n# 826 \"verit/veritLexer.ml\"\n\n  | 7 ->\n# 173 \"verit/veritLexer.mll\"\n                               ( RBRACKET )\n# 831 \"verit/veritLexer.ml\"\n\n  | 8 ->\n# 175 \"verit/veritLexer.mll\"\n                               ( EQ )\n# 836 \"verit/veritLexer.ml\"\n\n  | 9 ->\n# 176 \"verit/veritLexer.mll\"\n                               ( LT )\n# 841 \"verit/veritLexer.ml\"\n\n  | 10 ->\n# 177 \"verit/veritLexer.mll\"\n                               ( LEQ )\n# 846 \"verit/veritLexer.ml\"\n\n  | 11 ->\n# 178 \"verit/veritLexer.mll\"\n                               ( GT )\n# 851 \"verit/veritLexer.ml\"\n\n  | 12 ->\n# 179 \"verit/veritLexer.mll\"\n                               ( GEQ )\n# 856 \"verit/veritLexer.ml\"\n\n  | 13 ->\n# 180 \"verit/veritLexer.mll\"\n                               ( PLUS )\n# 861 \"verit/veritLexer.ml\"\n\n  | 14 ->\n# 181 \"verit/veritLexer.mll\"\n                               ( MINUS )\n# 866 \"verit/veritLexer.ml\"\n\n  | 15 ->\n# 182 \"verit/veritLexer.mll\"\n                               ( OPP )\n# 871 \"verit/veritLexer.ml\"\n\n  | 16 ->\n# 183 \"verit/veritLexer.mll\"\n                               ( MULT )\n# 876 \"verit/veritLexer.ml\"\n\n  | 17 ->\n# 184 \"verit/veritLexer.mll\"\n                               ( IMP )\n# 881 \"verit/veritLexer.ml\"\n\n  | 18 ->\n# 186 \"verit/veritLexer.mll\"\n                               ( SAT )\n# 886 \"verit/veritLexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"verit/veritLexer.mll\"\n                      i\n# 892 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"verit/veritLexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"verit/veritLexer.ml\"\n\n  | 20 ->\n# 189 \"verit/veritLexer.mll\"\n                             ( TINT )\n# 901 \"verit/veritLexer.ml\"\n\n  | 21 ->\n# 190 \"verit/veritLexer.mll\"\n                   ( TBOOL )\n# 906 \"verit/veritLexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"verit/veritLexer.mll\"\n            i\n# 912 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"verit/veritLexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"verit/veritLexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"verit/veritLexer.mll\"\n                 bv\n# 924 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"verit/veritLexer.mll\"\n                               ( BITV bv )\n# 928 \"verit/veritLexer.ml\"\n\n  | 24 ->\n# 195 \"verit/veritLexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"verit/veritLexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"verit/veritLexer.mll\"\n               v\n# 941 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"verit/veritLexer.mll\"\n                               ( BINDVAR v )\n# 945 \"verit/veritLexer.ml\"\n\n  | 26 ->\n# 200 \"verit/veritLexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"verit/veritLexer.ml\"\n\n  | 27 ->\n# 202 \"verit/veritLexer.mll\"\n                               ( raise Eof )\n# 955 \"verit/veritLexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":414,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 414, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":415,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 415, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":416,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 416, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":417,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":19,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Sending response {"id": 417, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":418,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":23,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 418, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":419,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":23,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 419, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":420,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 420, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":421,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":23,"character":22},"end":{"line":23,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 421, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":422,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":24,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 422, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":423,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":24,"character":19},"end":{"line":24,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 423, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":424,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":31,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 424, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":425,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":21,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 425, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":426,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":20,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 426, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":427,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":19,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0391006469727ms
Sending response {"id": 427, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":428,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":19,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 428, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":429,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":19,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Sending response {"id": 429, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":430,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":19,"character":9},"end":{"line":19,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 430, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":431,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":19,"character":12},"end":{"line":19,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 431, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":432,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 432, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":433,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 433, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":434,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 434, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"verit/veritLexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open VeritParser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"verit/veritLexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"verit/veritLexer.mll\"\n                               ( token lexbuf )\n# 791 \"verit/veritLexer.ml\"\n\n  | 1 ->\n# 164 \"verit/veritLexer.mll\"\n                               ( EOL )\n# 796 \"verit/veritLexer.ml\"\n\n  | 2 ->\n# 166 \"verit/veritLexer.mll\"\n                               ( COLON )\n# 801 \"verit/veritLexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"verit/veritLexer.mll\"\n                i\n# 807 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"verit/veritLexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"verit/veritLexer.ml\"\n\n  | 4 ->\n# 169 \"verit/veritLexer.mll\"\n                               ( LPAR )\n# 816 \"verit/veritLexer.ml\"\n\n  | 5 ->\n# 170 \"verit/veritLexer.mll\"\n                               ( RPAR )\n# 821 \"verit/veritLexer.ml\"\n\n  | 6 ->\n# 172 \"verit/veritLexer.mll\"\n                               ( LBRACKET )\n# 826 \"verit/veritLexer.ml\"\n\n  | 7 ->\n# 173 \"verit/veritLexer.mll\"\n                               ( RBRACKET )\n# 831 \"verit/veritLexer.ml\"\n\n  | 8 ->\n# 175 \"verit/veritLexer.mll\"\n                               ( EQ )\n# 836 \"verit/veritLexer.ml\"\n\n  | 9 ->\n# 176 \"verit/veritLexer.mll\"\n                               ( LT )\n# 841 \"verit/veritLexer.ml\"\n\n  | 10 ->\n# 177 \"verit/veritLexer.mll\"\n                               ( LEQ )\n# 846 \"verit/veritLexer.ml\"\n\n  | 11 ->\n# 178 \"verit/veritLexer.mll\"\n                               ( GT )\n# 851 \"verit/veritLexer.ml\"\n\n  | 12 ->\n# 179 \"verit/veritLexer.mll\"\n                               ( GEQ )\n# 856 \"verit/veritLexer.ml\"\n\n  | 13 ->\n# 180 \"verit/veritLexer.mll\"\n                               ( PLUS )\n# 861 \"verit/veritLexer.ml\"\n\n  | 14 ->\n# 181 \"verit/veritLexer.mll\"\n                               ( MINUS )\n# 866 \"verit/veritLexer.ml\"\n\n  | 15 ->\n# 182 \"verit/veritLexer.mll\"\n                               ( OPP )\n# 871 \"verit/veritLexer.ml\"\n\n  | 16 ->\n# 183 \"verit/veritLexer.mll\"\n                               ( MULT )\n# 876 \"verit/veritLexer.ml\"\n\n  | 17 ->\n# 184 \"verit/veritLexer.mll\"\n                               ( IMP )\n# 881 \"verit/veritLexer.ml\"\n\n  | 18 ->\n# 186 \"verit/veritLexer.mll\"\n                               ( SAT )\n# 886 \"verit/veritLexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"verit/veritLexer.mll\"\n                      i\n# 892 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"verit/veritLexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"verit/veritLexer.ml\"\n\n  | 20 ->\n# 189 \"verit/veritLexer.mll\"\n                             ( TINT )\n# 901 \"verit/veritLexer.ml\"\n\n  | 21 ->\n# 190 \"verit/veritLexer.mll\"\n                   ( TBOOL )\n# 906 \"verit/veritLexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"verit/veritLexer.mll\"\n            i\n# 912 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"verit/veritLexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"verit/veritLexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"verit/veritLexer.mll\"\n                 bv\n# 924 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"verit/veritLexer.mll\"\n                               ( BITV bv )\n# 928 \"verit/veritLexer.ml\"\n\n  | 24 ->\n# 195 \"verit/veritLexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"verit/veritLexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"verit/veritLexer.mll\"\n               v\n# 941 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"verit/veritLexer.mll\"\n                               ( BINDVAR v )\n# 945 \"verit/veritLexer.ml\"\n\n  | 26 ->\n# 200 \"verit/veritLexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"verit/veritLexer.ml\"\n\n  | 27 ->\n# 202 \"verit/veritLexer.mll\"\n                               ( raise Eof )\n# 955 \"verit/veritLexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":435,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0231266021729ms
Sending response {"id": 435, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":436,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 436, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":437,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 437, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":438,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":19,"character":12},"end":{"line":19,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 438, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":439,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.018835067749ms
Sending response {"id": 439, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":440,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 440, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":441,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 441, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"verit/veritLexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open VeritParser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"verit/veritLexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"verit/veritLexer.mll\"\n                               ( token lexbuf )\n# 791 \"verit/veritLexer.ml\"\n\n  | 1 ->\n# 164 \"verit/veritLexer.mll\"\n                               ( EOL )\n# 796 \"verit/veritLexer.ml\"\n\n  | 2 ->\n# 166 \"verit/veritLexer.mll\"\n                               ( COLON )\n# 801 \"verit/veritLexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"verit/veritLexer.mll\"\n                i\n# 807 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"verit/veritLexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"verit/veritLexer.ml\"\n\n  | 4 ->\n# 169 \"verit/veritLexer.mll\"\n                               ( LPAR )\n# 816 \"verit/veritLexer.ml\"\n\n  | 5 ->\n# 170 \"verit/veritLexer.mll\"\n                               ( RPAR )\n# 821 \"verit/veritLexer.ml\"\n\n  | 6 ->\n# 172 \"verit/veritLexer.mll\"\n                               ( LBRACKET )\n# 826 \"verit/veritLexer.ml\"\n\n  | 7 ->\n# 173 \"verit/veritLexer.mll\"\n                               ( RBRACKET )\n# 831 \"verit/veritLexer.ml\"\n\n  | 8 ->\n# 175 \"verit/veritLexer.mll\"\n                               ( EQ )\n# 836 \"verit/veritLexer.ml\"\n\n  | 9 ->\n# 176 \"verit/veritLexer.mll\"\n                               ( LT )\n# 841 \"verit/veritLexer.ml\"\n\n  | 10 ->\n# 177 \"verit/veritLexer.mll\"\n                               ( LEQ )\n# 846 \"verit/veritLexer.ml\"\n\n  | 11 ->\n# 178 \"verit/veritLexer.mll\"\n                               ( GT )\n# 851 \"verit/veritLexer.ml\"\n\n  | 12 ->\n# 179 \"verit/veritLexer.mll\"\n                               ( GEQ )\n# 856 \"verit/veritLexer.ml\"\n\n  | 13 ->\n# 180 \"verit/veritLexer.mll\"\n                               ( PLUS )\n# 861 \"verit/veritLexer.ml\"\n\n  | 14 ->\n# 181 \"verit/veritLexer.mll\"\n                               ( MINUS )\n# 866 \"verit/veritLexer.ml\"\n\n  | 15 ->\n# 182 \"verit/veritLexer.mll\"\n                               ( OPP )\n# 871 \"verit/veritLexer.ml\"\n\n  | 16 ->\n# 183 \"verit/veritLexer.mll\"\n                               ( MULT )\n# 876 \"verit/veritLexer.ml\"\n\n  | 17 ->\n# 184 \"verit/veritLexer.mll\"\n                               ( IMP )\n# 881 \"verit/veritLexer.ml\"\n\n  | 18 ->\n# 186 \"verit/veritLexer.mll\"\n                               ( SAT )\n# 886 \"verit/veritLexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"verit/veritLexer.mll\"\n                      i\n# 892 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"verit/veritLexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"verit/veritLexer.ml\"\n\n  | 20 ->\n# 189 \"verit/veritLexer.mll\"\n                             ( TINT )\n# 901 \"verit/veritLexer.ml\"\n\n  | 21 ->\n# 190 \"verit/veritLexer.mll\"\n                   ( TBOOL )\n# 906 \"verit/veritLexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"verit/veritLexer.mll\"\n            i\n# 912 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"verit/veritLexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"verit/veritLexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"verit/veritLexer.mll\"\n                 bv\n# 924 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"verit/veritLexer.mll\"\n                               ( BITV bv )\n# 928 \"verit/veritLexer.ml\"\n\n  | 24 ->\n# 195 \"verit/veritLexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"verit/veritLexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"verit/veritLexer.mll\"\n               v\n# 941 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"verit/veritLexer.mll\"\n                               ( BINDVAR v )\n# 945 \"verit/veritLexer.ml\"\n\n  | 26 ->\n# 200 \"verit/veritLexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"verit/veritLexer.ml\"\n\n  | 27 ->\n# 202 \"verit/veritLexer.mll\"\n                               ( raise Eof )\n# 955 \"verit/veritLexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":442,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 442, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":443,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 443, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":444,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 444, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":445,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":19,"character":12},"end":{"line":19,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 445, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":446,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"position":{"line":152,"character":31}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Sending response {"id": 446, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"verit/veritLexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open VeritParser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"verit/veritLexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"verit/veritLexer.mll\"\n                               ( token lexbuf )\n# 791 \"verit/veritLexer.ml\"\n\n  | 1 ->\n# 164 \"verit/veritLexer.mll\"\n                               ( EOL )\n# 796 \"verit/veritLexer.ml\"\n\n  | 2 ->\n# 166 \"verit/veritLexer.mll\"\n                               ( COLON )\n# 801 \"verit/veritLexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"verit/veritLexer.mll\"\n                i\n# 807 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"verit/veritLexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"verit/veritLexer.ml\"\n\n  | 4 ->\n# 169 \"verit/veritLexer.mll\"\n                               ( LPAR )\n# 816 \"verit/veritLexer.ml\"\n\n  | 5 ->\n# 170 \"verit/veritLexer.mll\"\n                               ( RPAR )\n# 821 \"verit/veritLexer.ml\"\n\n  | 6 ->\n# 172 \"verit/veritLexer.mll\"\n                               ( LBRACKET )\n# 826 \"verit/veritLexer.ml\"\n\n  | 7 ->\n# 173 \"verit/veritLexer.mll\"\n                               ( RBRACKET )\n# 831 \"verit/veritLexer.ml\"\n\n  | 8 ->\n# 175 \"verit/veritLexer.mll\"\n                               ( EQ )\n# 836 \"verit/veritLexer.ml\"\n\n  | 9 ->\n# 176 \"verit/veritLexer.mll\"\n                               ( LT )\n# 841 \"verit/veritLexer.ml\"\n\n  | 10 ->\n# 177 \"verit/veritLexer.mll\"\n                               ( LEQ )\n# 846 \"verit/veritLexer.ml\"\n\n  | 11 ->\n# 178 \"verit/veritLexer.mll\"\n                               ( GT )\n# 851 \"verit/veritLexer.ml\"\n\n  | 12 ->\n# 179 \"verit/veritLexer.mll\"\n                               ( GEQ )\n# 856 \"verit/veritLexer.ml\"\n\n  | 13 ->\n# 180 \"verit/veritLexer.mll\"\n                               ( PLUS )\n# 861 \"verit/veritLexer.ml\"\n\n  | 14 ->\n# 181 \"verit/veritLexer.mll\"\n                               ( MINUS )\n# 866 \"verit/veritLexer.ml\"\n\n  | 15 ->\n# 182 \"verit/veritLexer.mll\"\n                               ( OPP )\n# 871 \"verit/veritLexer.ml\"\n\n  | 16 ->\n# 183 \"verit/veritLexer.mll\"\n                               ( MULT )\n# 876 \"verit/veritLexer.ml\"\n\n  | 17 ->\n# 184 \"verit/veritLexer.mll\"\n                               ( IMP )\n# 881 \"verit/veritLexer.ml\"\n\n  | 18 ->\n# 186 \"verit/veritLexer.mll\"\n                               ( SAT )\n# 886 \"verit/veritLexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"verit/veritLexer.mll\"\n                      i\n# 892 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"verit/veritLexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"verit/veritLexer.ml\"\n\n  | 20 ->\n# 189 \"verit/veritLexer.mll\"\n                             ( TINT )\n# 901 \"verit/veritLexer.ml\"\n\n  | 21 ->\n# 190 \"verit/veritLexer.mll\"\n                   ( TBOOL )\n# 906 \"verit/veritLexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"verit/veritLexer.mll\"\n            i\n# 912 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"verit/veritLexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"verit/veritLexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"verit/veritLexer.mll\"\n                 bv\n# 924 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"verit/veritLexer.mll\"\n                               ( BITV bv )\n# 928 \"verit/veritLexer.ml\"\n\n  | 24 ->\n# 195 \"verit/veritLexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"verit/veritLexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"verit/veritLexer.mll\"\n               v\n# 941 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"verit/veritLexer.mll\"\n                               ( BINDVAR v )\n# 945 \"verit/veritLexer.ml\"\n\n  | 26 ->\n# 200 \"verit/veritLexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"verit/veritLexer.ml\"\n\n  | 27 ->\n# 202 \"verit/veritLexer.mll\"\n                               ( raise Eof )\n# 955 \"verit/veritLexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":447,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 447, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":448,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 448, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":449,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 449, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":450,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":19,"character":12},"end":{"line":19,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0300407409668ms
Sending response {"id": 450, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":447}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":450}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
Read message 
{"jsonrpc":"2.0","id":451,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 451, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":452,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0240802764893ms
Sending response {"id": 452, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":453,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0269412994385ms
Sending response {"id": 453, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"verit/veritLexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open VeritParser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"verit/veritLexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"verit/veritLexer.mll\"\n                               ( token lexbuf )\n# 791 \"verit/veritLexer.ml\"\n\n  | 1 ->\n# 164 \"verit/veritLexer.mll\"\n                               ( EOL )\n# 796 \"verit/veritLexer.ml\"\n\n  | 2 ->\n# 166 \"verit/veritLexer.mll\"\n                               ( COLON )\n# 801 \"verit/veritLexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"verit/veritLexer.mll\"\n                i\n# 807 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"verit/veritLexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"verit/veritLexer.ml\"\n\n  | 4 ->\n# 169 \"verit/veritLexer.mll\"\n                               ( LPAR )\n# 816 \"verit/veritLexer.ml\"\n\n  | 5 ->\n# 170 \"verit/veritLexer.mll\"\n                               ( RPAR )\n# 821 \"verit/veritLexer.ml\"\n\n  | 6 ->\n# 172 \"verit/veritLexer.mll\"\n                               ( LBRACKET )\n# 826 \"verit/veritLexer.ml\"\n\n  | 7 ->\n# 173 \"verit/veritLexer.mll\"\n                               ( RBRACKET )\n# 831 \"verit/veritLexer.ml\"\n\n  | 8 ->\n# 175 \"verit/veritLexer.mll\"\n                               ( EQ )\n# 836 \"verit/veritLexer.ml\"\n\n  | 9 ->\n# 176 \"verit/veritLexer.mll\"\n                               ( LT )\n# 841 \"verit/veritLexer.ml\"\n\n  | 10 ->\n# 177 \"verit/veritLexer.mll\"\n                               ( LEQ )\n# 846 \"verit/veritLexer.ml\"\n\n  | 11 ->\n# 178 \"verit/veritLexer.mll\"\n                               ( GT )\n# 851 \"verit/veritLexer.ml\"\n\n  | 12 ->\n# 179 \"verit/veritLexer.mll\"\n                               ( GEQ )\n# 856 \"verit/veritLexer.ml\"\n\n  | 13 ->\n# 180 \"verit/veritLexer.mll\"\n                               ( PLUS )\n# 861 \"verit/veritLexer.ml\"\n\n  | 14 ->\n# 181 \"verit/veritLexer.mll\"\n                               ( MINUS )\n# 866 \"verit/veritLexer.ml\"\n\n  | 15 ->\n# 182 \"verit/veritLexer.mll\"\n                               ( OPP )\n# 871 \"verit/veritLexer.ml\"\n\n  | 16 ->\n# 183 \"verit/veritLexer.mll\"\n                               ( MULT )\n# 876 \"verit/veritLexer.ml\"\n\n  | 17 ->\n# 184 \"verit/veritLexer.mll\"\n                               ( IMP )\n# 881 \"verit/veritLexer.ml\"\n\n  | 18 ->\n# 186 \"verit/veritLexer.mll\"\n                               ( SAT )\n# 886 \"verit/veritLexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"verit/veritLexer.mll\"\n                      i\n# 892 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"verit/veritLexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"verit/veritLexer.ml\"\n\n  | 20 ->\n# 189 \"verit/veritLexer.mll\"\n                             ( TINT )\n# 901 \"verit/veritLexer.ml\"\n\n  | 21 ->\n# 190 \"verit/veritLexer.mll\"\n                   ( TBOOL )\n# 906 \"verit/veritLexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"verit/veritLexer.mll\"\n            i\n# 912 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"verit/veritLexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"verit/veritLexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"verit/veritLexer.mll\"\n                 bv\n# 924 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"verit/veritLexer.mll\"\n                               ( BITV bv )\n# 928 \"verit/veritLexer.ml\"\n\n  | 24 ->\n# 195 \"verit/veritLexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"verit/veritLexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"verit/veritLexer.mll\"\n               v\n# 941 \"verit/veritLexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"verit/veritLexer.mll\"\n                               ( BINDVAR v )\n# 945 \"verit/veritLexer.ml\"\n\n  | 26 ->\n# 200 \"verit/veritLexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"verit/veritLexer.ml\"\n\n  | 27 ->\n# 202 \"verit/veritLexer.mll\"\n                               ( raise Eof )\n# 955 \"verit/veritLexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":454,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 454, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":455,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.756025314331ms
Sending response {"id": 455, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":456,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 456, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":457,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"},"range":{"start":{"line":19,"character":12},"end":{"line":19,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 457, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":457}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritLexer.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"verit/veritParser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open VeritSyntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"verit/veritParser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"verit/veritParser.mly\"\n                                                           ( raise Sat )\n# 815 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"verit/veritParser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"verit/veritParser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"verit/veritParser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"verit/veritParser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"verit/veritParser.mly\"\n                                                           ( Tpbr  )\n# 860 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"verit/veritParser.mly\"\n                                                           ( Inpu  )\n# 866 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"verit/veritParser.mly\"\n                                                           ( Deep  )\n# 872 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"verit/veritParser.mly\"\n                                                           ( True  )\n# 878 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"verit/veritParser.mly\"\n                                                           ( Fals  )\n# 884 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"verit/veritParser.mly\"\n                                                           ( Andp  )\n# 890 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"verit/veritParser.mly\"\n                                                           ( Andn  )\n# 896 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"verit/veritParser.mly\"\n                                                           ( Orp   )\n# 902 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"verit/veritParser.mly\"\n                                                           ( Orn   )\n# 908 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"verit/veritParser.mly\"\n                                                           ( Xorp1 )\n# 914 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"verit/veritParser.mly\"\n                                                           ( Xorp2 )\n# 920 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"verit/veritParser.mly\"\n                                                           ( Xorn1 )\n# 926 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"verit/veritParser.mly\"\n                                                           ( Xorn2 )\n# 932 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"verit/veritParser.mly\"\n                                                           ( Impp  )\n# 938 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"verit/veritParser.mly\"\n                                                           ( Impn1 )\n# 944 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"verit/veritParser.mly\"\n                                                           ( Impn2 )\n# 950 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"verit/veritParser.mly\"\n                                                           ( Equp1 )\n# 956 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"verit/veritParser.mly\"\n                                                           ( Equp2 )\n# 962 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"verit/veritParser.mly\"\n                                                           ( Equn1 )\n# 968 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"verit/veritParser.mly\"\n                                                           ( Equn2 )\n# 974 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"verit/veritParser.mly\"\n                                                           ( Itep1 )\n# 980 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"verit/veritParser.mly\"\n                                                           ( Itep2 )\n# 986 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"verit/veritParser.mly\"\n                                                           ( Iten1 )\n# 992 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"verit/veritParser.mly\"\n                                                           ( Iten2 )\n# 998 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"verit/veritParser.mly\"\n                                                           ( Eqre  )\n# 1004 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"verit/veritParser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"verit/veritParser.mly\"\n                                                           ( Eqco  )\n# 1016 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"verit/veritParser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"verit/veritParser.mly\"\n                                                           ( Dlge  )\n# 1028 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"verit/veritParser.mly\"\n                                                           ( Lage  )\n# 1034 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"verit/veritParser.mly\"\n                                                           ( Lata  )\n# 1040 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"verit/veritParser.mly\"\n                                                           ( Dlde  )\n# 1046 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"verit/veritParser.mly\"\n                                                           ( Lade  )\n# 1052 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"verit/veritParser.mly\"\n                                                           ( Eins  )\n# 1058 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"verit/veritParser.mly\"\n                                                           ( Skea  )\n# 1064 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"verit/veritParser.mly\"\n                                                           ( Skaa  )\n# 1070 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"verit/veritParser.mly\"\n                                                           ( Qnts  )\n# 1076 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"verit/veritParser.mly\"\n                                                           ( Qntm  )\n# 1082 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"verit/veritParser.mly\"\n                                                           ( Reso  )\n# 1088 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"verit/veritParser.mly\"\n                                                           ( Weak  )\n# 1094 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"verit/veritParser.mly\"\n                                                           ( And   )\n# 1100 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"verit/veritParser.mly\"\n                                                           ( Nor   )\n# 1106 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"verit/veritParser.mly\"\n                                                           ( Or    )\n# 1112 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"verit/veritParser.mly\"\n                                                           ( Nand  )\n# 1118 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"verit/veritParser.mly\"\n                                                           ( Xor1  )\n# 1124 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"verit/veritParser.mly\"\n                                                           ( Xor2  )\n# 1130 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"verit/veritParser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"verit/veritParser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"verit/veritParser.mly\"\n                                                           ( Imp   )\n# 1148 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"verit/veritParser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"verit/veritParser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"verit/veritParser.mly\"\n                                                           ( Equ1  )\n# 1166 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"verit/veritParser.mly\"\n                                                           ( Equ2  )\n# 1172 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"verit/veritParser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"verit/veritParser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"verit/veritParser.mly\"\n                                                           ( Ite1  )\n# 1190 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"verit/veritParser.mly\"\n                                                           ( Ite2  )\n# 1196 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"verit/veritParser.mly\"\n                                                           ( Nite1 )\n# 1202 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"verit/veritParser.mly\"\n                                                           ( Nite2 )\n# 1208 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"verit/veritParser.mly\"\n                                                           ( Tpal  )\n# 1214 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"verit/veritParser.mly\"\n                                                           ( Tlap  )\n# 1220 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"verit/veritParser.mly\"\n                                                           ( Tple  )\n# 1226 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"verit/veritParser.mly\"\n                                                           ( Tpne  )\n# 1232 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"verit/veritParser.mly\"\n                                                           ( Tpde  )\n# 1238 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"verit/veritParser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"verit/veritParser.mly\"\n                                                           ( Tpie  )\n# 1250 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"verit/veritParser.mly\"\n                                                           ( Tpma  )\n# 1256 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"verit/veritParser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"verit/veritParser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"verit/veritParser.mly\"\n                                                           ( Tppp  )\n# 1274 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"verit/veritParser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"verit/veritParser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"verit/veritParser.mly\"\n                                                           ( Subp  )\n# 1292 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"verit/veritParser.mly\"\n                                                           ( Flat  )\n# 1298 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"verit/veritParser.mly\"\n                                                           ( Hole  )\n# 1304 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"verit/veritParser.mly\"\n                                                           ( Bbva  )\n# 1310 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"verit/veritParser.mly\"\n                                                           ( Bbconst )\n# 1316 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"verit/veritParser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"verit/veritParser.mly\"\n                                                           ( Bbdis )\n# 1328 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"verit/veritParser.mly\"\n                                                           ( Bbop  )\n# 1334 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"verit/veritParser.mly\"\n                                                           ( Bbadd )\n# 1340 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"verit/veritParser.mly\"\n                                                           ( Bbmul )\n# 1346 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"verit/veritParser.mly\"\n                                                           ( Bbult )\n# 1352 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"verit/veritParser.mly\"\n                                                           ( Bbslt )\n# 1358 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"verit/veritParser.mly\"\n                                                           ( Bbnot )\n# 1364 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"verit/veritParser.mly\"\n                                                           ( Bbneg )\n# 1370 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"verit/veritParser.mly\"\n                                                           ( Bbconc )\n# 1376 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"verit/veritParser.mly\"\n                                                           ( Bbextr )\n# 1382 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"verit/veritParser.mly\"\n                                                           ( Bbzext )\n# 1388 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"verit/veritParser.mly\"\n                                                           ( Bbsext )\n# 1394 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"verit/veritParser.mly\"\n                                                           ( Bbshl )\n# 1400 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"verit/veritParser.mly\"\n                                                           ( Bbshr )\n# 1406 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"verit/veritParser.mly\"\n                                                           ( Row1  )\n# 1412 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"verit/veritParser.mly\"\n                                                           ( Row2  )\n# 1418 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"verit/veritParser.mly\"\n                                                           ( Exte  )\n# 1424 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"verit/veritParser.mly\"\n                                                           ( [] )\n# 1430 \"verit/veritParser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"verit/veritParser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"verit/veritParser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"verit/veritParser.mly\"\n                                                           ( [_1] )\n# 1444 \"verit/veritParser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"verit/veritParser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"verit/veritParser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"verit/veritParser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"verit/veritParser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"verit/veritParser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"verit/veritParser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"verit/veritParser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"verit/veritParser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"verit/veritParser.mly\"\n                                             ( _1 )\n# 1480 \"verit/veritParser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"verit/veritParser.mly\"\n                                       ( _1 )\n# 1487 \"verit/veritParser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"verit/veritParser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"verit/veritParser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"verit/veritParser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"verit/veritParser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"verit/veritParser.mly\"\n                 ( TZ )\n# 1557 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"verit/veritParser.mly\"\n                  ( Tbool )\n# 1563 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"verit/veritParser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"verit/veritParser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"verit/veritParser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"verit/veritParser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"verit/veritParser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"verit/veritParser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"verit/veritParser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"verit/veritParser.mly\"\n                                                           ( _2 )\n# 1602 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 1656 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"verit/veritParser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"verit/veritParser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"verit/veritParser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"verit/veritParser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"verit/veritParser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"verit/veritParser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"verit/veritParser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"verit/veritParser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"verit/veritParser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"verit/veritParser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"verit/veritParser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"verit/veritParser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"verit/veritParser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"verit/veritParser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"verit/veritParser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 1993 \"verit/veritParser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"verit/veritParser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"verit/veritParser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"verit/veritParser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"verit/veritParser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"verit/veritParser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"verit/veritParser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"verit/veritParser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"verit/veritParser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"verit/veritParser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 2039 \"verit/veritParser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"verit/veritParser.mly\"\n                                                           ( [_1] )\n# 2046 \"verit/veritParser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"verit/veritParser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"verit/veritParser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":458,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 458, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":459,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 459, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":460,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 460, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":461,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 461, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":462,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Sending response {"id": 462, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":463,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 463, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":464,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"position":{"line":75,"character":8}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0529289245605ms
Sending response {"id": 464, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":465,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 465, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":466,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":75,"character":8},"end":{"line":75,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 466, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":467,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":76,"character":5},"end":{"line":76,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 467, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":468,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":87,"character":4},"end":{"line":87,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 468, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":469,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":87,"character":4},"end":{"line":87,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 469, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":470,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":90,"character":5},"end":{"line":90,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 470, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":471,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":24,"character":6},"end":{"line":24,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0560283660889ms
Sending response {"id": 471, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":472,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":51,"character":4},"end":{"line":51,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 472, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":473,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":52,"character":4},"end":{"line":52,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 473, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":474,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 474, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":475,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 475, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":476,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 476, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":477,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":52,"character":4},"end":{"line":52,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 477, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"verit/veritParser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open VeritSyntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"verit/veritParser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"verit/veritParser.mly\"\n                                                           ( raise Sat )\n# 815 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"verit/veritParser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"verit/veritParser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"verit/veritParser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"verit/veritParser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"verit/veritParser.mly\"\n                                                           ( Tpbr  )\n# 860 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"verit/veritParser.mly\"\n                                                           ( Inpu  )\n# 866 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"verit/veritParser.mly\"\n                                                           ( Deep  )\n# 872 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"verit/veritParser.mly\"\n                                                           ( True  )\n# 878 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"verit/veritParser.mly\"\n                                                           ( Fals  )\n# 884 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"verit/veritParser.mly\"\n                                                           ( Andp  )\n# 890 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"verit/veritParser.mly\"\n                                                           ( Andn  )\n# 896 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"verit/veritParser.mly\"\n                                                           ( Orp   )\n# 902 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"verit/veritParser.mly\"\n                                                           ( Orn   )\n# 908 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"verit/veritParser.mly\"\n                                                           ( Xorp1 )\n# 914 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"verit/veritParser.mly\"\n                                                           ( Xorp2 )\n# 920 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"verit/veritParser.mly\"\n                                                           ( Xorn1 )\n# 926 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"verit/veritParser.mly\"\n                                                           ( Xorn2 )\n# 932 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"verit/veritParser.mly\"\n                                                           ( Impp  )\n# 938 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"verit/veritParser.mly\"\n                                                           ( Impn1 )\n# 944 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"verit/veritParser.mly\"\n                                                           ( Impn2 )\n# 950 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"verit/veritParser.mly\"\n                                                           ( Equp1 )\n# 956 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"verit/veritParser.mly\"\n                                                           ( Equp2 )\n# 962 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"verit/veritParser.mly\"\n                                                           ( Equn1 )\n# 968 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"verit/veritParser.mly\"\n                                                           ( Equn2 )\n# 974 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"verit/veritParser.mly\"\n                                                           ( Itep1 )\n# 980 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"verit/veritParser.mly\"\n                                                           ( Itep2 )\n# 986 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"verit/veritParser.mly\"\n                                                           ( Iten1 )\n# 992 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"verit/veritParser.mly\"\n                                                           ( Iten2 )\n# 998 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"verit/veritParser.mly\"\n                                                           ( Eqre  )\n# 1004 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"verit/veritParser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"verit/veritParser.mly\"\n                                                           ( Eqco  )\n# 1016 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"verit/veritParser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"verit/veritParser.mly\"\n                                                           ( Dlge  )\n# 1028 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"verit/veritParser.mly\"\n                                                           ( Lage  )\n# 1034 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"verit/veritParser.mly\"\n                                                           ( Lata  )\n# 1040 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"verit/veritParser.mly\"\n                                                           ( Dlde  )\n# 1046 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"verit/veritParser.mly\"\n                                                           ( Lade  )\n# 1052 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"verit/veritParser.mly\"\n                                                           ( Eins  )\n# 1058 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"verit/veritParser.mly\"\n                                                           ( Skea  )\n# 1064 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"verit/veritParser.mly\"\n                                                           ( Skaa  )\n# 1070 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"verit/veritParser.mly\"\n                                                           ( Qnts  )\n# 1076 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"verit/veritParser.mly\"\n                                                           ( Qntm  )\n# 1082 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"verit/veritParser.mly\"\n                                                           ( Reso  )\n# 1088 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"verit/veritParser.mly\"\n                                                           ( Weak  )\n# 1094 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"verit/veritParser.mly\"\n                                                           ( And   )\n# 1100 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"verit/veritParser.mly\"\n                                                           ( Nor   )\n# 1106 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"verit/veritParser.mly\"\n                                                           ( Or    )\n# 1112 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"verit/veritParser.mly\"\n                                                           ( Nand  )\n# 1118 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"verit/veritParser.mly\"\n                                                           ( Xor1  )\n# 1124 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"verit/veritParser.mly\"\n                                                           ( Xor2  )\n# 1130 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"verit/veritParser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"verit/veritParser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"verit/veritParser.mly\"\n                                                           ( Imp   )\n# 1148 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"verit/veritParser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"verit/veritParser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"verit/veritParser.mly\"\n                                                           ( Equ1  )\n# 1166 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"verit/veritParser.mly\"\n                                                           ( Equ2  )\n# 1172 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"verit/veritParser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"verit/veritParser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"verit/veritParser.mly\"\n                                                           ( Ite1  )\n# 1190 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"verit/veritParser.mly\"\n                                                           ( Ite2  )\n# 1196 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"verit/veritParser.mly\"\n                                                           ( Nite1 )\n# 1202 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"verit/veritParser.mly\"\n                                                           ( Nite2 )\n# 1208 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"verit/veritParser.mly\"\n                                                           ( Tpal  )\n# 1214 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"verit/veritParser.mly\"\n                                                           ( Tlap  )\n# 1220 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"verit/veritParser.mly\"\n                                                           ( Tple  )\n# 1226 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"verit/veritParser.mly\"\n                                                           ( Tpne  )\n# 1232 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"verit/veritParser.mly\"\n                                                           ( Tpde  )\n# 1238 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"verit/veritParser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"verit/veritParser.mly\"\n                                                           ( Tpie  )\n# 1250 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"verit/veritParser.mly\"\n                                                           ( Tpma  )\n# 1256 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"verit/veritParser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"verit/veritParser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"verit/veritParser.mly\"\n                                                           ( Tppp  )\n# 1274 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"verit/veritParser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"verit/veritParser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"verit/veritParser.mly\"\n                                                           ( Subp  )\n# 1292 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"verit/veritParser.mly\"\n                                                           ( Flat  )\n# 1298 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"verit/veritParser.mly\"\n                                                           ( Hole  )\n# 1304 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"verit/veritParser.mly\"\n                                                           ( Bbva  )\n# 1310 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"verit/veritParser.mly\"\n                                                           ( Bbconst )\n# 1316 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"verit/veritParser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"verit/veritParser.mly\"\n                                                           ( Bbdis )\n# 1328 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"verit/veritParser.mly\"\n                                                           ( Bbop  )\n# 1334 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"verit/veritParser.mly\"\n                                                           ( Bbadd )\n# 1340 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"verit/veritParser.mly\"\n                                                           ( Bbmul )\n# 1346 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"verit/veritParser.mly\"\n                                                           ( Bbult )\n# 1352 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"verit/veritParser.mly\"\n                                                           ( Bbslt )\n# 1358 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"verit/veritParser.mly\"\n                                                           ( Bbnot )\n# 1364 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"verit/veritParser.mly\"\n                                                           ( Bbneg )\n# 1370 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"verit/veritParser.mly\"\n                                                           ( Bbconc )\n# 1376 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"verit/veritParser.mly\"\n                                                           ( Bbextr )\n# 1382 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"verit/veritParser.mly\"\n                                                           ( Bbzext )\n# 1388 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"verit/veritParser.mly\"\n                                                           ( Bbsext )\n# 1394 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"verit/veritParser.mly\"\n                                                           ( Bbshl )\n# 1400 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"verit/veritParser.mly\"\n                                                           ( Bbshr )\n# 1406 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"verit/veritParser.mly\"\n                                                           ( Row1  )\n# 1412 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"verit/veritParser.mly\"\n                                                           ( Row2  )\n# 1418 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"verit/veritParser.mly\"\n                                                           ( Exte  )\n# 1424 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"verit/veritParser.mly\"\n                                                           ( [] )\n# 1430 \"verit/veritParser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"verit/veritParser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"verit/veritParser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"verit/veritParser.mly\"\n                                                           ( [_1] )\n# 1444 \"verit/veritParser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"verit/veritParser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"verit/veritParser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"verit/veritParser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"verit/veritParser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"verit/veritParser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"verit/veritParser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"verit/veritParser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"verit/veritParser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"verit/veritParser.mly\"\n                                             ( _1 )\n# 1480 \"verit/veritParser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"verit/veritParser.mly\"\n                                       ( _1 )\n# 1487 \"verit/veritParser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"verit/veritParser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"verit/veritParser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"verit/veritParser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"verit/veritParser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"verit/veritParser.mly\"\n                 ( TZ )\n# 1557 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"verit/veritParser.mly\"\n                  ( Tbool )\n# 1563 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"verit/veritParser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"verit/veritParser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"verit/veritParser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"verit/veritParser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"verit/veritParser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"verit/veritParser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"verit/veritParser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"verit/veritParser.mly\"\n                                                           ( _2 )\n# 1602 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 1656 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"verit/veritParser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"verit/veritParser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"verit/veritParser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"verit/veritParser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"verit/veritParser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"verit/veritParser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"verit/veritParser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"verit/veritParser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"verit/veritParser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"verit/veritParser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"verit/veritParser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"verit/veritParser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"verit/veritParser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"verit/veritParser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"verit/veritParser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 1993 \"verit/veritParser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"verit/veritParser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"verit/veritParser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"verit/veritParser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"verit/veritParser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"verit/veritParser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"verit/veritParser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"verit/veritParser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"verit/veritParser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"verit/veritParser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 2039 \"verit/veritParser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"verit/veritParser.mly\"\n                                                           ( [_1] )\n# 2046 \"verit/veritParser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"verit/veritParser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"verit/veritParser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":478,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 478, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":479,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0228881835938ms
Sending response {"id": 479, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":480,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 480, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":481,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 481, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":482,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 482, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":483,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 483, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":484,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":52,"character":4},"end":{"line":52,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 484, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":485,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 485, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":486,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 486, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":487,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 487, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":488,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":124,"character":2},"end":{"line":124,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 488, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":489,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 489, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":490,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":12,"character":1},"end":{"line":12,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 490, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":491,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":67,"character":24},"end":{"line":67,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 491, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":492,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":67,"character":24},"end":{"line":67,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 492, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":493,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":67,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.0240802764893ms
Sending response {"id": 493, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":494,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":69,"character":26},"end":{"line":69,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 494, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":495,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 495, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":496,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":79,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 496, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":497,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":76,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 497, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":498,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":76,"character":6}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 498, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":499,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":76,"character":6},"end":{"line":76,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 499, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":500,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":76,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 500, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":501,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":76,"character":6},"end":{"line":76,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 501, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":502,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":91,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 502, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":503,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":75,"character":6},"end":{"line":100,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 503, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":504,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":83,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 504, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":505,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":80,"character":51}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Sending response {"id": 505, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":506,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":85,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Sending response {"id": 506, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":507,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 507, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":508,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 508, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":509,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 509, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":510,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"},"position":{"line":26,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 510, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":511,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 511, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":512,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 512, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":513,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 513, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":514,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 514, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":515,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 515, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":516,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 516, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
Read message 
{"jsonrpc":"2.0","id":517,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 517, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":518,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0479221343994ms
Sending response {"id": 518, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":519,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 519, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":520,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"position":{"line":41,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0400543212891ms
Sending response {"id": 520, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":521,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0348091125488ms
Sending response {"id": 521, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":522,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":16,"character":576},"end":{"line":16,"character":579}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 522, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":523,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":25,"character":7},"end":{"line":25,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 523, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":524,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 524, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":525,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 525, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":526,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":25,"character":7},"end":{"line":25,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 526, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":527,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 527, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":528,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"position":{"line":23,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 528, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":529,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 529, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":530,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 530, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":531,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 531, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":532,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":75,"character":6},"end":{"line":100,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 532, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":529}}
Read message 
{"jsonrpc":"2.0","id":533,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":82,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 533, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":534,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":82,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Sending response {"id": 534, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":535,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":90,"character":31}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 535, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":536,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":79,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 536, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":537,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 537, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":538,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":79,"character":24},"end":{"line":79,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 538, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":539,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":79,"character":24},"end":{"line":79,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 539, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":540,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":80,"character":28}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 540, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":541,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":80,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 541, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":542,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":80,"character":26},"end":{"line":80,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 542, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":543,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":79,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 543, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":544,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":79,"character":24},"end":{"line":79,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 544, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":545,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":78,"character":49},"end":{"line":79,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 545, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":546,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":79,"character":24},"end":{"line":79,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 546, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":547,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":79,"character":51}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 547, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":548,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":80,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 548, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":549,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":80,"character":21},"end":{"line":80,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 549, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":550,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":80,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 550, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":551,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":80,"character":21},"end":{"line":80,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 551, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":552,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":80,"character":21},"end":{"line":80,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 552, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":553,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":80,"character":26},"end":{"line":80,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 553, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":554,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":81,"character":22}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Sending response {"id": 554, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":555,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":81,"character":19},"end":{"line":81,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 555, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":556,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":84,"character":22}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 556, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":557,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":84,"character":0},"end":{"line":85,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 557, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":558,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":84,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.131845474243ms
Sending response {"id": 558, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":559,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":84,"character":14},"end":{"line":84,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 559, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":560,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":85,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 560, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":561,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":85,"character":23},"end":{"line":85,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 561, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":562,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":84,"character":30}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 562, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":563,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":84,"character":0},"end":{"line":85,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 563, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":564,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":84,"character":30}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 564, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":565,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":84,"character":0},"end":{"line":85,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 565, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":566,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":84,"character":30}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 566, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":567,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":84,"character":27},"end":{"line":84,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 567, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":568,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":139,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 568, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":569,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":139,"character":30}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Sending response {"id": 569, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":570,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":139,"character":30},"end":{"line":139,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 570, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":571,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":139,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 571, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":572,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":139,"character":24},"end":{"line":139,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 572, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":573,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"position":{"line":128,"character":24}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00882148742676ms
Sending response {"id": 573, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":574,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":128,"character":24},"end":{"line":128,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 574, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":575,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":128,"character":14},"end":{"line":128,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 575, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":576,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.042200088501ms
Sending response {"id": 576, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":577,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0519752502441ms
Sending response {"id": 577, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":578,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 578, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":579,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 579, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":580,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 580, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":581,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"},"range":{"start":{"line":128,"character":14},"end":{"line":128,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 581, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":578}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":581}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":582,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 582, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":583,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 583, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":584,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 584, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":585,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":128,"character":14},"end":{"line":128,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 585, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":582}}
Read message 
{"jsonrpc":"2.0","id":586,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":111,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0259876251221ms
Sending response {"id": 586, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":587,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":17,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 587, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":588,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 588, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":589,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":17,"character":14},"end":{"line":17,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 589, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":590,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":19},"end":{"line":67,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 590, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":591,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 591, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":592,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 592, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":593,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":19}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 593, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":594,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":19},"end":{"line":67,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 594, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":2},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := ZVeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":595,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 595, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":596,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":20},"end":{"line":67,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 596, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":597,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 597, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":3},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3VeritParser.line VeritLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":598,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 598, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":599,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":21},"end":{"line":67,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 599, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":600,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 600, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":601,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":39}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Sending response {"id": 601, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":602,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":39},"end":{"line":67,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 602, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":603,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":42}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 603, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":604,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":43},"end":{"line":67,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 604, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":605,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":38}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 605, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":606,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":38},"end":{"line":67,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 606, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":4},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3VeritParser.line ZLexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":607,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 607, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":608,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":39},"end":{"line":67,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 608, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":609,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 609, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":5},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3VeritParser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":610,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 610, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":611,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":40},"end":{"line":67,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 611, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":612,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 612, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":5},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3VeritParser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":5}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":613,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":206,"character":57},"end":{"line":206,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 613, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":614,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":19},"end":{"line":67,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 614, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":615,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":206,"character":57},"end":{"line":206,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 615, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":616,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 616, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":617,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 617, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":618,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":21},"end":{"line":67,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 618, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":619,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":24,"character":11},"end":{"line":24,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 619, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":620,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":21},"end":{"line":67,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 620, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":621,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":64,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 621, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":622,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":27}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 622, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":623,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":27},"end":{"line":67,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 623, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":9},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3VParser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":624,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 624, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":625,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":22},"end":{"line":67,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 625, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":10},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a verit trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":626,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 626, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":627,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":21},"end":{"line":67,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 627, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":628,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 628, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":629,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":19},"end":{"line":67,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 629, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":630,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 630, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":631,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":76,"character":6},"end":{"line":76,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 631, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":632,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 632, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":633,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 633, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":634,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":24,"character":11},"end":{"line":24,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 634, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":635,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":24,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 635, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":636,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":24,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Sending response {"id": 636, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":637,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":24,"character":11},"end":{"line":24,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 637, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":11},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":638,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 638, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":639,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":24,"character":12},"end":{"line":24,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 639, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":640,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 640, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":12},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise VeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":641,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 641, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":642,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":24,"character":13},"end":{"line":24,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 642, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":643,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 643, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":644,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0429153442383ms
Sending response {"id": 644, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":645,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":70,"character":23}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Sending response {"id": 645, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":646,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":74,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0259876251221ms
Sending response {"id": 646, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":647,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":74,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Sending response {"id": 647, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":648,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":74,"character":11}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 648, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":649,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 649, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":650,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":74,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 650, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":14},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raiseeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":15},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raiseZeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":651,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 651, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":652,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":10},"end":{"line":74,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 652, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":653,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 653, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":16},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raiseeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":18},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise ZeritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":654,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 654, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":655,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":11},"end":{"line":74,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 655, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":656,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 656, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":19},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3eritLexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":657,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 657, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":658,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":12},"end":{"line":74,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 658, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":659,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 659, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":660,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":74,"character":13}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0178813934326ms
Sending response {"id": 660, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":661,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":12},"end":{"line":74,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 661, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":20},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | VeritLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":662,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 662, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":663,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":74,"character":12},"end":{"line":74,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 663, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":664,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 664, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":665,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":33},"end":{"line":67,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 665, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":666,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":76,"character":6},"end":{"line":76,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 666, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":667,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":76,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 667, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":668,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":76,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 668, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":669,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":78,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 669, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":670,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":76,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 670, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":671,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":76,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 671, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":21},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":672,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 672, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":673,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":76,"character":6},"end":{"line":76,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 673, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":674,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 674, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":22},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | zLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":675,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 675, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":676,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":76,"character":7},"end":{"line":76,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 676, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":677,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 677, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":23},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":678,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 678, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":679,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":76,"character":6},"end":{"line":76,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 679, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":679}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":24},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | ZLexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":25},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (VeritSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":680,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 680, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":681,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":76,"character":8},"end":{"line":76,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 681, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":682,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 682, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":683,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":78,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 683, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":684,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":78,"character":26}}}
[server] Got a method textDocument/hover
[server] processing took 0.0350475311279ms
Sending response {"id": 684, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":685,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":78,"character":32}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 685, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":686,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":78,"character":32},"end":{"line":78,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 686, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":687,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":78,"character":31}}}
[server] Got a method textDocument/hover
[server] processing took 0.169038772583ms
Sending response {"id": 687, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":688,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":78,"character":30},"end":{"line":78,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 688, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":689,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":78,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Sending response {"id": 689, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":32},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (z3Syntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":690,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 690, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":691,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":78,"character":27},"end":{"line":78,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 691, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":35},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (ZSyntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":692,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0300407409668ms
Sending response {"id": 692, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":693,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":78,"character":26},"end":{"line":78,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 693, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":693}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":36},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (VeritSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":694,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":79,"character":27}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.155925750732ms
Sending response {"id": 694, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":695,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 695, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":696,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 696, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":697,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":79,"character":27},"end":{"line":79,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 697, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":42},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (ZSyntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":698,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 698, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":699,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":79,"character":25},"end":{"line":79,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 699, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":43},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = VeritSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":700,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 700, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":701,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":79,"character":26},"end":{"line":79,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 701, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":702,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 702, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":703,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":80,"character":26}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 703, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":704,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":81,"character":26}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 704, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":705,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":81,"character":26},"end":{"line":81,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 705, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":706,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":89,"character":40},"end":{"line":89,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.018835067749ms
Sending response {"id": 706, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":707,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":84,"character":27},"end":{"line":84,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Sending response {"id": 707, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":708,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":101,"character":52}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 708, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":709,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":85,"character":38}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Sending response {"id": 709, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":710,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":84,"character":31}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Sending response {"id": 710, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":711,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":85,"character":43}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 711, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":44},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":712,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 712, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":713,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":84,"character":27},"end":{"line":84,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 713, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":714,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 714, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":45},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = ZSyntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":715,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 715, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":716,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":84,"character":28},"end":{"line":84,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 716, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":46},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = VeritSyntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":717,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 717, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":718,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":84,"character":29},"end":{"line":84,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 718, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":719,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 719, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":720,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":84,"character":42}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0150203704834ms
Sending response {"id": 720, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":721,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 721, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":722,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":84,"character":42},"end":{"line":84,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 722, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":723,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":84,"character":42}}}
[server] Got a method textDocument/hover
[server] processing took 0.0300407409668ms
Sending response {"id": 723, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":724,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":81,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 724, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":725,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":81,"character":29},"end":{"line":81,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 725, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":726,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":80,"character":44}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 726, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":727,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":80,"character":44}}}
[server] Got a method textDocument/hover
[server] processing took 0.0622272491455ms
Sending response {"id": 727, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":728,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":80,"character":44}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 728, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":729,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":80,"character":44}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 729, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":730,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":87,"character":23},"end":{"line":87,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 730, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":47},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Verit.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":731,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 731, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":732,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":101,"character":40},"end":{"line":101,"character":45}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 732, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":733,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 733, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":48},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":734,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 734, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":735,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 735, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":736,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 736, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":49},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":737,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 737, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":738,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":114,"character":11},"end":{"line":114,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 738, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":739,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 739, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":50},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":740,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 740, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":741,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":115,"character":11},"end":{"line":115,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 741, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":742,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 742, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":51},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":743,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 743, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":744,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":116,"character":17},"end":{"line":116,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 744, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":745,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 745, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":52},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":746,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 746, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":747,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":117,"character":17},"end":{"line":117,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 747, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":748,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 748, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":53},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_verit _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":749,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 749, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":750,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":171,"character":9},"end":{"line":171,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 750, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":751,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 751, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":54},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_Z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":752,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 752, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":753,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":172,"character":53},"end":{"line":172,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 753, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":754,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 754, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":755,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":171,"character":10}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 755, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":756,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":171,"character":10},"end":{"line":171,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 756, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":56},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"verit_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":757,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 757, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":758,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":171,"character":10},"end":{"line":171,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 758, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":759,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 759, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":760,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":172,"character":53},"end":{"line":172,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 760, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":57},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"Z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":761,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 761, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":762,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":176,"character":53},"end":{"line":176,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 762, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":763,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0147819519043ms
Sending response {"id": 763, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":764,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":172,"character":56}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 764, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":765,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":172,"character":54}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Sending response {"id": 765, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":766,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":172,"character":54}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 766, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":767,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":172,"character":53}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 767, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":768,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":172,"character":54},"end":{"line":172,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 768, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":59},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":769,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 769, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":770,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":172,"character":54},"end":{"line":172,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 770, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":771,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 771, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":772,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":183,"character":18},"end":{"line":183,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 772, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":60},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":773,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 773, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":774,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":206,"character":75},"end":{"line":206,"character":80}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 774, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":775,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 775, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":776,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":183,"character":40},"end":{"line":183,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 776, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":61},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":777,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":183,"character":18},"end":{"line":183,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 777, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":778,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 778, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":779,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 779, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":62},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":780,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":183,"character":20},"end":{"line":183,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 780, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":781,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 781, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":782,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0228881835938ms
Sending response {"id": 782, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":63},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Verit = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":783,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":183,"character":18},"end":{"line":183,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 783, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":784,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 784, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":785,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0550746917725ms
Sending response {"id": 785, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":64},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":786,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":183,"character":20},"end":{"line":183,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 786, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":787,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 787, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":788,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 788, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":64},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Verit.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":64}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":789,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":206,"character":75},"end":{"line":206,"character":80}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 789, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":65},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | VeritSyntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":790,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 790, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":791,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":213,"character":14},"end":{"line":213,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 791, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":792,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 792, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":66},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":793,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 793, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":794,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":233,"character":11},"end":{"line":233,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 794, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":795,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 795, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":67},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = VeritSyntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":796,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 796, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":797,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":234,"character":11},"end":{"line":234,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 797, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":798,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 798, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":68},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = VeritSyntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":799,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 799, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":800,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 800, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":801,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 801, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":69},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = VeritSyntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":802,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 802, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":803,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":236,"character":17},"end":{"line":236,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 803, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":804,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 804, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":70},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_verit verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":805,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 805, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":806,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 806, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":807,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.03981590271ms
Sending response {"id": 807, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":808,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":229,"character":19},"end":{"line":229,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 808, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":809,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":233,"character":11},"end":{"line":233,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 809, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":810,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":233,"character":11},"end":{"line":233,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 810, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":811,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":234,"character":11},"end":{"line":234,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 811, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":812,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 812, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":813,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":19},"end":{"line":67,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 813, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":814,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":233,"character":11},"end":{"line":233,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 814, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":815,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":237,"character":26},"end":{"line":237,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 815, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":816,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":220,"character":47}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Sending response {"id": 816, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":817,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":220,"character":47},"end":{"line":220,"character":47}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 817, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":818,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":220,"character":47}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 818, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":819,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 819, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":820,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":220,"character":65}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 820, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":821,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":237,"character":26},"end":{"line":237,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 821, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":71},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 verit_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":822,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 822, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":823,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":237,"character":29},"end":{"line":237,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 823, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":824,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 824, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":72},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_verit\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":825,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 825, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":826,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":176,"character":53},"end":{"line":176,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 826, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":827,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 827, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":73},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":828,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 828, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":829,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":195,"character":30},"end":{"line":195,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 829, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":830,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 830, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":74},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"verit-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":831,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 831, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":832,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":197,"character":30},"end":{"line":197,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 832, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":833,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 833, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":75},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"verit-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":834,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 834, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":835,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":206,"character":47},"end":{"line":206,"character":52}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 835, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":836,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 836, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":76},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"z3-non-zero-exit-code\" (\"Z3.call_verit: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":837,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 837, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":838,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":206,"character":80},"end":{"line":206,"character":85}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 838, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":839,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 839, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":77},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"z3-non-zero-exit-code\" (\"Z3.call_z3: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet verit_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":840,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 840, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":841,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":216,"character":4},"end":{"line":216,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 841, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":842,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 842, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":78},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"z3-non-zero-exit-code\" (\"Z3.call_z3: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet z3_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":843,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 843, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":844,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":216,"character":6},"end":{"line":216,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 844, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":845,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 845, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":846,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0231266021729ms
Sending response {"id": 846, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":847,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 847, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":79},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"z3 --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"z3-non-zero-exit-code\" (\"Z3.call_z3: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet z3_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":848,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 848, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":849,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":195,"character":44},"end":{"line":195,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 849, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":850,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 850, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":851,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":185,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 851, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":852,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":185,"character":28},"end":{"line":185,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 852, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":80},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"z3-non-zero-exit-code\" (\"Z3.call_z3: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet z3_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":853,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 853, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":854,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 854, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":855,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 855, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":80},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen CoqTerms\nopen SmtTrace\nopen SmtAtom\nopen SmtBtype\nopen SmtCertif\n\n\n(* let debug = false *)\n\n\n(******************************************************************************)\n(* Given a Z3 trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n(* exception Import_trace of int *)\n\n(* let get_val = function\n *     Some a -> a\n *   | None -> assert false *)\n\n(* For debugging certif processing : <add_scertif> <select> <occur> <alloc> *)\n(* let print_certif c where=\n *   let r = ref c in\n *   let out_channel = open_out where in\n *   let fmt = Format.formatter_of_out_channel out_channel in\n *   let continue = ref true in\n *   while !continue do\n *     let kind = to_string (!r.kind) in\n *     let id = !r.id in\n *     let pos = match !r.pos with\n *       | None -> \"None\"\n *       | Some p -> string_of_int p in\n *     let used = !r.used in\n *     Format.fprintf fmt \"id:%i kind:%s pos:%s used:%i value:\" id kind pos used;\n *     begin match !r.value with\n *     | None -> Format.fprintf fmt \"None\"\n *     | Some l -> List.iter (fun f -> Form.to_smt Atom.to_smt fmt f;\n *                                     Format.fprintf fmt \" \") l end;\n *     Format.fprintf fmt \"\\n\";\n *     match !r.next with\n *     | None -> continue := false\n *     | Some n -> r := n\n *   done;\n *   Format.fprintf fmt \"@.\"; close_out out_channel *)\n\nlet import_trace ra_quant rf_quant filename first lsmt =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let confl_num = ref (-1) in\n  let first_num = ref (-1) in\n  let is_first = ref true in\n  let line = ref 1 in\n  (* let _ = Parsing.set_trace true in *)\n  try\n    while true do\n      confl_num := Z3Parser.line Z3Lexer.token lexbuf;\n      if !is_first then (\n        is_first := false;\n        first_num := !confl_num\n      );\n      incr line\n    done;\n    raise Z3Lexer.Eof\n  with\n    | Z3Lexer.Eof ->\n       close_in chan;\n       let cfirst = ref (Z3Syntax.get_clause !first_num) in\n       let confl = ref (Z3Syntax.get_clause !confl_num) in\n       let re_hash = Form.hash_hform (Atom.hash_hatom ra_quant) rf_quant in\n       begin match first with\n       | None -> ()\n       | Some _ ->\n          let init_index = Z3Syntax.init_index lsmt re_hash in\n          let cf, lr = order_roots init_index !cfirst in\n          cfirst := cf;\n          let to_add = Z3Syntax.qf_to_add (List.tl lr) in\n          let to_add =\n            (match first, !cfirst.value with\n             | Some (root, l), Some [fl] when init_index fl = 1 && not (Form.equal l (re_hash fl)) ->\n                 let cfirst_value = !cfirst.value in\n                 !cfirst.value <- root.value;\n                 [Other (ImmFlatten (root, fl)), cfirst_value, !cfirst]\n             | _ -> []) @ to_add in\n       match to_add with\n       | [] -> ()\n       | _  -> confl := add_scertifs to_add !cfirst end;\n       select !confl;\n       occur !confl;\n       (alloc !cfirst, !confl)\n    | Parsing.Parse_error -> failwith (\"Z3.import_trace: parsing error line \"^(string_of_int !line))\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  Z3Syntax.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace ra_quant rf_quant fproof None [] in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\nlet checker fsmt fproof =\n  SmtCommands.checker (import_all fsmt fproof)\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\nlet export out_channel rt ro lsmt =\n  let fmt = Format.formatter_of_out_channel out_channel in\n  Format.fprintf fmt \"(set-logic UFLIA)@.\";\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (Tindex t);\n    Format.fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,dom,cod,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    Format.fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t -> if !is_first then is_first := false else Format.fprintf fmt \" \"; SmtBtype.to_smt fmt t) dom;\n    Format.fprintf fmt \") \";\n    SmtBtype.to_smt fmt cod;\n    Format.fprintf fmt \")@.\"\n  ) (Op.to_list ro);\n\n  List.iter (fun u -> Format.fprintf fmt \"(assert \";\n                      Form.to_smt fmt u;\n                      Format.fprintf fmt \")\\n\") lsmt;\n\n  Format.fprintf fmt \"(check-sat)\\n(exit)@.\"\n\nexception Unknown\n\nlet call_z3 _ rt ro ra_quant rf_quant first lsmt =\n  let (filename, outchan) = Filename.open_temp_file \"z3_coq\" \".smt2\" in\n  export outchan rt ro lsmt;\n  close_out outchan;\n  let logfilename = Filename.chop_extension filename ^ \".vtlog\" in\n  let wname, woc = Filename.open_temp_file \"warnings_z3\" \".log\" in\n  close_out woc;\n  let command = \"veriT --proof-prune --proof-merge --proof-with-sharing --cnf-definitional --disable-ackermann --input=smtlib2 --proof=\" ^ logfilename ^ \" \" ^ filename ^ \" 2> \" ^ wname in\n  Format.eprintf \"%s@.\" command;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command command in\n  let t1 = Sys.time () in\n  Format.eprintf \"Z3 = %.5f@.\" (t1-.t0);\n\n  let win = open_in wname in\n\n  let raise_warnings_errors () =\n    try\n      while true do\n        let l = input_line win in\n        let n = String.length l in\n        if l = \"warning : proof_done: status is still open\" then\n          raise Unknown\n        else if l = \"Invalid memory reference\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ l)\n        else if n >= 7 && String.sub l 0 7 = \"warning\" then\n          Structures.warning \"z3-warning\" (\"veriT outputted the warning: \" ^ (String.sub l 7 (n-7)))\n        else if n >= 8 && String.sub l 0 8 = \"error : \" then\n          Structures.error (\"veriT failed with the error: \" ^ (String.sub l 8 (n-8)))\n        else\n          Structures.error (\"veriT failed with the error: \" ^ l)\n      done\n    with End_of_file -> () in\n\n  try\n    if exit_code <> 0 then Structures.warning \"z3-non-zero-exit-code\" (\"Z3.call_z3: command \" ^ command ^ \" exited with code \" ^ string_of_int exit_code);\n    raise_warnings_errors ();\n    let res = import_trace ra_quant rf_quant logfilename (Some first) lsmt in\n    close_in win; Sys.remove wname; res\n  with x -> close_in win; Sys.remove wname;\n            match x with\n            | Unknown -> Structures.error \"veriT returns 'unknown'\"\n            | Z3Syntax.Sat -> Structures.error \"veriT found a counter-example\"\n            | _ -> raise x\n\nlet z3_logic =\n  SL.of_list [LUF; LLia]\n\nlet tactic_gen vm_cast lcpl lcepl =\n  (* Transform the tuple of lemmas given by the user into a list *)\n  let lcpl =\n    let lcpl = EConstr.Unsafe.to_constr lcpl in\n    let lcpl = CoqTerms.option_of_constr_option lcpl in\n    match lcpl with\n      | Some lcpl -> CoqTerms.list_of_constr_tuple lcpl\n      | None -> []\n  in\n\n  (* Core tactic *)\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Z3Syntax.ra in\n  let rf = Z3Syntax.rf in\n  let ra_quant = Z3Syntax.ra_quant in\n  let rf_quant = Z3Syntax.rf_quant in\n  SmtCommands.tactic call_z3 z3_logic rt ro ra rf ra_quant rf_quant vm_cast lcpl lcepl\nlet tactic = tactic_gen vm_cast_true\nlet tactic_no_check = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml","version":80}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":856,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":185,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.00715255737305ms
Sending response {"id": 856, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":857,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 857, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":858,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 858, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":859,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0300407409668ms
Sending response {"id": 859, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":860,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"},"range":{"start":{"line":25,"character":7},"end":{"line":25,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 860, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":861,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 861, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":862,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00286102294922ms
Sending response {"id": 862, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":863,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 863, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":864,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":25,"character":7},"end":{"line":25,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 864, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":865,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 865, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":866,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 866, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":867,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 867, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritSyntax.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":868,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 868, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":869,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 869, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":870,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 870, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":871,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 871, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":872,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":18,"character":19}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0190734863281ms
Sending response {"id": 872, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":873,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":19},"end":{"line":18,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 873, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":874,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":18,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 874, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":875,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":220,"character":20},"end":{"line":220,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 875, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":876,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":15},"end":{"line":18,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 876, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":877,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":15},"end":{"line":18,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 877, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":878,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":33,"character":23},"end":{"line":33,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 878, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":879,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":33,"character":23},"end":{"line":33,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 879, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":880,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 880, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":881,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":33,"character":23},"end":{"line":33,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 881, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":882,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":4,"character":69}}}
[server] Got a method textDocument/hover
[server] processing took 0.018835067749ms
Sending response {"id": 882, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":883,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":5,"character":62}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 883, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":884,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":7,"character":61}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Sending response {"id": 884, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":885,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 885, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":886,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":7,"character":61},"end":{"line":7,"character":61}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 886, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":887,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":8,"character":64}}}
[server] Got a method textDocument/hover
[server] processing took 0.0250339508057ms
Sending response {"id": 887, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":888,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":6,"character":68}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Sending response {"id": 888, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":889,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":5,"character":63}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 889, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":890,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":33,"character":23},"end":{"line":33,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 890, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":2},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":891,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 891, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":892,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 892, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":893,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 893, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":3},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":894,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 894, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":895,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":39,"character":19},"end":{"line":39,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 895, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":896,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 896, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":4},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":897,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 897, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":898,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":47,"character":19},"end":{"line":47,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 898, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":5},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":899,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 899, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":900,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":81,"character":18},"end":{"line":81,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 900, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":901,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 901, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":6},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":902,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 902, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":903,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":95,"character":19},"end":{"line":95,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 903, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":904,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 904, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":7},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":905,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0112056732178ms
Sending response {"id": 905, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":906,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":119,"character":23},"end":{"line":119,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 906, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":907,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 907, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":8},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":908,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 908, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":909,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":120,"character":25},"end":{"line":120,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 909, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":910,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 910, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":9},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":911,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 911, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":912,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":121,"character":18},"end":{"line":121,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 912, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":10},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":913,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 913, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":914,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":142,"character":26},"end":{"line":142,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 914, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":915,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 915, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":11},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":14},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":916,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 916, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":917,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":146,"character":18},"end":{"line":146,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 917, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":918,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 918, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":15},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":919,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 919, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":920,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":155,"character":24},"end":{"line":155,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 920, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":921,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 921, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":16},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":922,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 922, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":923,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":164,"character":21},"end":{"line":164,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0221729278564ms
Sending response {"id": 923, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":924,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 924, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":17},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":925,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 925, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":926,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":169,"character":23},"end":{"line":169,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 926, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":18},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":927,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 927, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":928,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":173,"character":26},"end":{"line":173,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 928, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":929,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 929, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":19},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":930,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 930, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":931,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":215,"character":33},"end":{"line":215,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 931, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":932,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 932, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":20},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":933,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.339031219482ms
Sending response {"id": 933, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":934,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":467,"character":26},"end":{"line":467,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 934, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":935,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 935, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":35},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":936,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 936, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":937,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":528,"character":33},"end":{"line":528,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 937, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":938,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 938, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":36},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":939,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 939, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":940,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":528,"character":35},"end":{"line":528,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 940, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":941,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 941, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":942,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":522,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Sending response {"id": 942, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":943,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":522,"character":21},"end":{"line":522,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 943, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":944,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 944, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":36},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":36}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","id":945,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 945, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":946,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 946, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":947,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 947, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":948,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 948, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":949,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 949, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":950,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 950, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":951,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 951, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":952,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":25,"character":7},"end":{"line":25,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 952, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":953,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 953, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":954,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 954, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":955,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 955, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":956,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 956, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":957,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 957, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":958,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 958, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":959,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":25,"character":7},"end":{"line":25,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 959, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":960,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 960, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
Read message 
{"jsonrpc":"2.0","id":961,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 961, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":962,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 962, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":963,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 963, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":964,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 964, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"verit/veritParser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open VeritSyntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"verit/veritParser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"verit/veritParser.mly\"\n                                                           ( raise Sat )\n# 815 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"verit/veritParser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"verit/veritParser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"verit/veritParser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"verit/veritParser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"verit/veritParser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"verit/veritParser.mly\"\n                                                           ( Tpbr  )\n# 860 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"verit/veritParser.mly\"\n                                                           ( Inpu  )\n# 866 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"verit/veritParser.mly\"\n                                                           ( Deep  )\n# 872 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"verit/veritParser.mly\"\n                                                           ( True  )\n# 878 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"verit/veritParser.mly\"\n                                                           ( Fals  )\n# 884 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"verit/veritParser.mly\"\n                                                           ( Andp  )\n# 890 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"verit/veritParser.mly\"\n                                                           ( Andn  )\n# 896 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"verit/veritParser.mly\"\n                                                           ( Orp   )\n# 902 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"verit/veritParser.mly\"\n                                                           ( Orn   )\n# 908 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"verit/veritParser.mly\"\n                                                           ( Xorp1 )\n# 914 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"verit/veritParser.mly\"\n                                                           ( Xorp2 )\n# 920 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"verit/veritParser.mly\"\n                                                           ( Xorn1 )\n# 926 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"verit/veritParser.mly\"\n                                                           ( Xorn2 )\n# 932 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"verit/veritParser.mly\"\n                                                           ( Impp  )\n# 938 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"verit/veritParser.mly\"\n                                                           ( Impn1 )\n# 944 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"verit/veritParser.mly\"\n                                                           ( Impn2 )\n# 950 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"verit/veritParser.mly\"\n                                                           ( Equp1 )\n# 956 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"verit/veritParser.mly\"\n                                                           ( Equp2 )\n# 962 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"verit/veritParser.mly\"\n                                                           ( Equn1 )\n# 968 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"verit/veritParser.mly\"\n                                                           ( Equn2 )\n# 974 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"verit/veritParser.mly\"\n                                                           ( Itep1 )\n# 980 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"verit/veritParser.mly\"\n                                                           ( Itep2 )\n# 986 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"verit/veritParser.mly\"\n                                                           ( Iten1 )\n# 992 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"verit/veritParser.mly\"\n                                                           ( Iten2 )\n# 998 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"verit/veritParser.mly\"\n                                                           ( Eqre  )\n# 1004 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"verit/veritParser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"verit/veritParser.mly\"\n                                                           ( Eqco  )\n# 1016 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"verit/veritParser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"verit/veritParser.mly\"\n                                                           ( Dlge  )\n# 1028 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"verit/veritParser.mly\"\n                                                           ( Lage  )\n# 1034 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"verit/veritParser.mly\"\n                                                           ( Lata  )\n# 1040 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"verit/veritParser.mly\"\n                                                           ( Dlde  )\n# 1046 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"verit/veritParser.mly\"\n                                                           ( Lade  )\n# 1052 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"verit/veritParser.mly\"\n                                                           ( Eins  )\n# 1058 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"verit/veritParser.mly\"\n                                                           ( Skea  )\n# 1064 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"verit/veritParser.mly\"\n                                                           ( Skaa  )\n# 1070 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"verit/veritParser.mly\"\n                                                           ( Qnts  )\n# 1076 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"verit/veritParser.mly\"\n                                                           ( Qntm  )\n# 1082 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"verit/veritParser.mly\"\n                                                           ( Reso  )\n# 1088 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"verit/veritParser.mly\"\n                                                           ( Weak  )\n# 1094 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"verit/veritParser.mly\"\n                                                           ( And   )\n# 1100 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"verit/veritParser.mly\"\n                                                           ( Nor   )\n# 1106 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"verit/veritParser.mly\"\n                                                           ( Or    )\n# 1112 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"verit/veritParser.mly\"\n                                                           ( Nand  )\n# 1118 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"verit/veritParser.mly\"\n                                                           ( Xor1  )\n# 1124 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"verit/veritParser.mly\"\n                                                           ( Xor2  )\n# 1130 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"verit/veritParser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"verit/veritParser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"verit/veritParser.mly\"\n                                                           ( Imp   )\n# 1148 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"verit/veritParser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"verit/veritParser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"verit/veritParser.mly\"\n                                                           ( Equ1  )\n# 1166 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"verit/veritParser.mly\"\n                                                           ( Equ2  )\n# 1172 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"verit/veritParser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"verit/veritParser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"verit/veritParser.mly\"\n                                                           ( Ite1  )\n# 1190 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"verit/veritParser.mly\"\n                                                           ( Ite2  )\n# 1196 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"verit/veritParser.mly\"\n                                                           ( Nite1 )\n# 1202 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"verit/veritParser.mly\"\n                                                           ( Nite2 )\n# 1208 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"verit/veritParser.mly\"\n                                                           ( Tpal  )\n# 1214 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"verit/veritParser.mly\"\n                                                           ( Tlap  )\n# 1220 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"verit/veritParser.mly\"\n                                                           ( Tple  )\n# 1226 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"verit/veritParser.mly\"\n                                                           ( Tpne  )\n# 1232 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"verit/veritParser.mly\"\n                                                           ( Tpde  )\n# 1238 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"verit/veritParser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"verit/veritParser.mly\"\n                                                           ( Tpie  )\n# 1250 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"verit/veritParser.mly\"\n                                                           ( Tpma  )\n# 1256 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"verit/veritParser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"verit/veritParser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"verit/veritParser.mly\"\n                                                           ( Tppp  )\n# 1274 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"verit/veritParser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"verit/veritParser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"verit/veritParser.mly\"\n                                                           ( Subp  )\n# 1292 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"verit/veritParser.mly\"\n                                                           ( Flat  )\n# 1298 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"verit/veritParser.mly\"\n                                                           ( Hole  )\n# 1304 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"verit/veritParser.mly\"\n                                                           ( Bbva  )\n# 1310 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"verit/veritParser.mly\"\n                                                           ( Bbconst )\n# 1316 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"verit/veritParser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"verit/veritParser.mly\"\n                                                           ( Bbdis )\n# 1328 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"verit/veritParser.mly\"\n                                                           ( Bbop  )\n# 1334 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"verit/veritParser.mly\"\n                                                           ( Bbadd )\n# 1340 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"verit/veritParser.mly\"\n                                                           ( Bbmul )\n# 1346 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"verit/veritParser.mly\"\n                                                           ( Bbult )\n# 1352 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"verit/veritParser.mly\"\n                                                           ( Bbslt )\n# 1358 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"verit/veritParser.mly\"\n                                                           ( Bbnot )\n# 1364 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"verit/veritParser.mly\"\n                                                           ( Bbneg )\n# 1370 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"verit/veritParser.mly\"\n                                                           ( Bbconc )\n# 1376 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"verit/veritParser.mly\"\n                                                           ( Bbextr )\n# 1382 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"verit/veritParser.mly\"\n                                                           ( Bbzext )\n# 1388 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"verit/veritParser.mly\"\n                                                           ( Bbsext )\n# 1394 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"verit/veritParser.mly\"\n                                                           ( Bbshl )\n# 1400 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"verit/veritParser.mly\"\n                                                           ( Bbshr )\n# 1406 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"verit/veritParser.mly\"\n                                                           ( Row1  )\n# 1412 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"verit/veritParser.mly\"\n                                                           ( Row2  )\n# 1418 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"verit/veritParser.mly\"\n                                                           ( Exte  )\n# 1424 \"verit/veritParser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"verit/veritParser.mly\"\n                                                           ( [] )\n# 1430 \"verit/veritParser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"verit/veritParser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"verit/veritParser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"verit/veritParser.mly\"\n                                                           ( [_1] )\n# 1444 \"verit/veritParser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"verit/veritParser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"verit/veritParser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"verit/veritParser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"verit/veritParser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"verit/veritParser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"verit/veritParser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"verit/veritParser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"verit/veritParser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"verit/veritParser.mly\"\n                                             ( _1 )\n# 1480 \"verit/veritParser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"verit/veritParser.mly\"\n                                       ( _1 )\n# 1487 \"verit/veritParser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"verit/veritParser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"verit/veritParser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"verit/veritParser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"verit/veritParser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"verit/veritParser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"verit/veritParser.mly\"\n                 ( TZ )\n# 1557 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"verit/veritParser.mly\"\n                  ( Tbool )\n# 1563 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"verit/veritParser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"verit/veritParser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"verit/veritParser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"verit/veritParser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"verit/veritParser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"verit/veritParser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"verit/veritParser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"verit/veritParser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"verit/veritParser.mly\"\n                                                           ( _2 )\n# 1602 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"verit/veritParser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 1656 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"verit/veritParser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"verit/veritParser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"verit/veritParser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"verit/veritParser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"verit/veritParser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"verit/veritParser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"verit/veritParser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"verit/veritParser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"verit/veritParser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"verit/veritParser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"verit/veritParser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"verit/veritParser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"verit/veritParser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"verit/veritParser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"verit/veritParser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"verit/veritParser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"verit/veritParser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"verit/veritParser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"verit/veritParser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 1993 \"verit/veritParser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"verit/veritParser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"verit/veritParser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"verit/veritParser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"verit/veritParser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"verit/veritParser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"verit/veritParser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"verit/veritParser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"verit/veritParser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"verit/veritParser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"verit/veritParser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"verit/veritParser.mly\"\n                                                           ( _1 )\n# 2039 \"verit/veritParser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"verit/veritParser.mly\"\n                                                           ( [_1] )\n# 2046 \"verit/veritParser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"verit/veritParser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"verit/veritParser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":965,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 965, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":966,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 966, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":967,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 967, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":968,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 968, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":969,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"},"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 969, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":970,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"},"range":{"start":{"line":313,"character":11},"end":{"line":313,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 970, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":971,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"},"position":{"line":319,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 971, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":972,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 972, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":973,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 973, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":974,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 974, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":975,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":52,"character":4},"end":{"line":52,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 975, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":976,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 976, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":977,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":153,"character":10},"end":{"line":153,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 977, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":978,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":35,"character":6},"end":{"line":35,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 978, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":979,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"position":{"line":143,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0209808349609ms
Sending response {"id": 979, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":980,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"},"range":{"start":{"line":143,"character":9},"end":{"line":143,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 980, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/veritParser.mli"}}}
Read message 
{"jsonrpc":"2.0","id":981,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0388622283936ms
Sending response {"id": 981, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":982,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 982, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":983,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 983, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":984,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 984, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":985,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 985, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":986,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 986, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":987,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 987, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":988,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 988, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":989,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 989, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":990,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 990, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":991,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00977516174316ms
Sending response {"id": 991, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
Read message 
{"jsonrpc":"2.0","id":992,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 992, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":993,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 993, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":994,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 994, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":995,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 995, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":996,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 996, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":997,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.164031982422ms
Sending response {"id": 997, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":998,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 998, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":999,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 999, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1000,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 1000, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1001,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1001, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1002,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1002, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1003,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1003, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1004,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1004, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1005,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1005, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1006,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1006, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1007,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0181198120117ms
Sending response {"id": 1007, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1008,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1008, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1009,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1009, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1010,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1010, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1011,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1011, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1012,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1012, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1013,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":260,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 1013, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1014,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":258,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Sending response {"id": 1014, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1015,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":250,"character":10}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0228881835938ms
Sending response {"id": 1015, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1016,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1016, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1017,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":250,"character":10},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1017, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1018,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":250,"character":10}}}
[server] Got a method textDocument/definition
[server] processing took 0.0100135803223ms
Sending response {"id": 1018, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1019,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1019, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1020,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":250,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0369548797607ms
Sending response {"id": 1020, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1021,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":250,"character":10}}}
[server] Got a method textDocument/definition
[server] processing took 0.0150203704834ms
Sending response {"id": 1021, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":36},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":36}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1022,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1022, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1023,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":250,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 1023, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1024,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1024, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1025,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1025, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1026,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1026, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1027,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":581,"character":4},"end":{"line":581,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1027, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1028,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":197,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 1028, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1029,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":197,"character":22}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Sending response {"id": 1029, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1030,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.028133392334ms
Sending response {"id": 1030, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1031,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":197,"character":22},"end":{"line":197,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1031, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1032,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":197,"character":22}}}
[server] Got a method textDocument/definition
[server] processing took 0.0109672546387ms
Sending response {"id": 1032, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1033,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":197,"character":52},"end":{"line":197,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0231266021729ms
Sending response {"id": 1033, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1034,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":250,"character":4},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1034, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1035,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 1035, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1036,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":250,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 1036, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1037,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"position":{"line":250,"character":9}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0121593475342ms
Sending response {"id": 1037, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1038,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":250,"character":4},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1038, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1039,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1039, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1040,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00286102294922ms
Sending response {"id": 1040, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1041,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1041, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1042,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"position":{"line":26,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.0181198120117ms
Sending response {"id": 1042, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1042}}
Read message 
{"jsonrpc":"2.0","id":1043,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"position":{"line":12,"character":12}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0219345092773ms
Sending response {"id": 1043, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1044,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 1044, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1045,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":12,"character":12},"end":{"line":12,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 1045, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli","languageId":"ocaml","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli","version":2},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli","version":2},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli","version":2}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1046,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1046, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1047,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1047, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1048,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli"},"range":{"start":{"line":59,"character":24},"end":{"line":59,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1048, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1049,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1049, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/z3Syntax.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1050,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1050, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1051,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1051, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1052,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1052, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1053,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":59,"character":24},"end":{"line":59,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1053, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1054,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 1054, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1055,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1055, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1056,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 1056, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1057,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":59,"character":24},"end":{"line":59,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1057, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1058,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":40,"character":28}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 1058, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1059,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1059, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1060,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":29},"end":{"line":40,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0319480895996ms
Sending response {"id": 1060, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1061,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":41,"character":11},"end":{"line":41,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1061, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1062,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":21,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 1062, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1063,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":21,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 1063, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1064,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":21,"character":16},"end":{"line":21,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1064, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1065,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":21,"character":16}}}
[server] Got a method textDocument/definition
[server] processing took 0.0121593475342ms
Sending response {"id": 1065, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","version":1},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1066,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1066, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1067,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1067, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1068,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":9,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.0178813934326ms
Sending response {"id": 1068, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
Read message 
{"jsonrpc":"2.0","id":1069,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.046968460083ms
Sending response {"id": 1069, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1070,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1070, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1071,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1071, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1072,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":21,"character":16},"end":{"line":21,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1072, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1073,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 1073, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1074,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 1074, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1075,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1075, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1076,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":250,"character":10},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1076, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nval line :\n  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> int\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1077,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1077, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1078,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0240802764893ms
Sending response {"id": 1078, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1079,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1079, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1080,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1080, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1081,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1081, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1082,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1082, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1083,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":250,"character":10},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1083, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1084,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0841617584229ms
Sending response {"id": 1084, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1085,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1085, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1086,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1086, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1087,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":21,"character":16},"end":{"line":21,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1087, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1088,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":21,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.00882148742676ms
Sending response {"id": 1088, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1089,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 1089, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1090,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":11},"end":{"line":40,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 1090, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1091,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":36},"end":{"line":40,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1091, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1092,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":16,"character":674},"end":{"line":16,"character":675}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1092, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1093,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":11},"end":{"line":40,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1093, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml","languageId":"ocaml","version":1,"text":"# 1 \"z3/z3Lexer.mll\"\n \n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open Z3Parser\n  exception Eof\n\n  let typ_table = Hashtbl.create 53\n  let _ =\n    List.iter (fun (kwd, tok) -> Hashtbl.add typ_table kwd tok)\n      [ \"input\", INPU;\n        \"deep_res\", DEEP;\n        \"true\", TRUE;\n        \"false\", FALS;\n        \"and_pos\", ANDP;\n        \"and_neg\", ANDN;\n        \"or_pos\", ORP;\n        \"or_neg\", ORN;\n        \"xor_pos1\", XORP1;\n        \"xor_pos2\", XORP2;\n        \"xor_neg1\", XORN1;\n        \"xor_neg2\", XORN2;\n        \"implies_pos\", IMPP;\n        \"implies_neg1\", IMPN1;\n        \"implies_neg2\", IMPN2;\n        \"equiv_pos1\", EQUP1;\n        \"equiv_pos2\", EQUP2;\n        \"equiv_neg1\", EQUN1;\n        \"equiv_neg2\", EQUN2;\n        \"ite_pos1\", ITEP1;\n        \"ite_pos2\", ITEP2;\n        \"ite_neg1\", ITEN1;\n        \"ite_neg2\", ITEN2;\n        \"eq_reflexive\", EQRE;\n        \"eq_transitive\", EQTR;\n        \"eq_congruent\", EQCO;\n        \"eq_congruent_pred\", EQCP;\n        \"dl_generic\", DLGE;\n        \"lia_generic\", LAGE;\n        \"la_generic\", LAGE;\n        \"la_tautology\", LATA;\n        \"dl_disequality\", DLDE;\n        \"la_disequality\", LADE;\n        \"forall_inst\", FINS;\n\t\"forall\", FORALL;\n        \"exists_inst\", EINS;\n        \"skolem_ex_ax\", SKEA;\n        \"skolem_all_ax\", SKAA;\n        \"qnt_simplify_ax\", QNTS;\n        \"qnt_merge_ax\", QNTM;\n        \"resolution\", RESO;\n        \"weaken\", WEAK;\n        \"and\", AND;\n        \"not_or\", NOR;\n        \"or\", OR;\n        \"not_and\", NAND;\n        \"xor1\", XOR1;\n        \"xor2\", XOR2;\n        \"not_xor1\", NXOR1;\n        \"not_xor2\", NXOR2;\n        \"implies\", IMP;\n        \"not_implies1\", NIMP1;\n        \"not_implies2\", NIMP2;\n        \"equiv1\", EQU1;\n        \"equiv2\", EQU2;\n        \"not_equiv1\", NEQU1;\n        \"not_equiv2\", NEQU2;\n        \"ite1\", ITE1;\n        \"ite2\", ITE2;\n        \"not_ite1\", NITE1;\n        \"not_ite2\", NITE2;\n        \"tmp_alphaconv\", TPAL;\n        \"tmp_LA_pre\", TLAP;\n        \"tmp_let_elim\", TPLE;\n        \"tmp_nary_elim\", TPNE;\n        \"tmp_distinct_elim\", TPDE;\n        \"tmp_simp_arith\", TPSA;\n        \"tmp_ite_elim\", TPIE;\n        \"tmp_macrosubst\", TPMA;\n        \"tmp_betared\", TPBR;\n        \"tmp_bfun_elim\", TPBE;\n        \"tmp_sk_connector\", TPSC;\n        \"tmp_pm_process\", TPPP;\n        \"tmp_qnt_tidy\", TPQT;\n        \"tmp_qnt_simplify\", TPQS;\n        \"tmp_skolemize\", TPSK;\n        \"subproof\", SUBP;\n        \"flatten\", FLAT;\n        \"hole\", HOLE;\n        \"bbvar\", BBVA;\n        \"bbconst\", BBCONST;\n        \"bbeq\", BBEQ;\n        \"bv_const_neq\", BBDIS;\n        \"bbop\", BBOP;\n        \"bbnot\", BBNOT;\n        \"bbneg\", BBNEG;\n        \"bbadd\", BBADD;\n        \"bbmul\", BBMUL;\n        \"bbult\", BBULT;\n        \"bbslt\", BBSLT;\n        \"bbconcat\", BBCONC;\n        \"bbextract\", BBEXTR;\n        \"bbzextend\", BBZEXT;\n        \"bbsextend\", BBSEXT;\n        \"bbshl\", BBSHL;\n        \"bbshr\", BBSHR;\n        \"bvand\", BVAND;\n        \"bvor\", BVOR;\n        \"bvxor\", BVXOR;\n        \"bvadd\", BVADD;\n        \"bvmul\", BVMUL;\n        \"bvult\", BVULT;\n        \"bvslt\", BVSLT;\n        \"bvule\", BVULE;\n        \"bvsle\", BVSLE;\n        \"bvshl\", BVSHL;\n        \"bvlshr\", BVSHR;\n        \"not\", NOT;\n        \"xor\", XOR;\n        \"ite\", ITE;\n        \"let\", LET;\n        \"distinct\", DIST;\n        \"bbT\", BBT;\n        \"bitof\", BITOF;\n        \"bvnot\", BVNOT;\n        \"bvneg\", BVNEG;\n        \"concat\", BVCONC;\n        \"extract\", BVEXTR;\n        \"zero_extend\", BVZEXT;\n        \"sign_extend\", BVSEXT;\n        \"select\", SELECT;\n        \"diff\", DIFF;\n        \"store\", STORE;\n        \"row1\", ROW1;\n        \"row2\", ROW2;\n        \"ext\", EXTE;\n      ]\n\n# 150 \"z3/z3Lexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\228\\255\\062\\000\\120\\000\\195\\000\\014\\001\\024\\001\\099\\001\\\n    \\174\\001\\249\\001\\239\\255\\240\\255\\068\\002\\242\\255\\031\\000\\033\\000\\\n    \\033\\000\\248\\255\\249\\255\\250\\255\\251\\255\\081\\002\\253\\255\\001\\000\\\n    \\006\\000\\075\\000\\091\\002\\101\\002\\105\\000\\238\\255\\245\\255\\243\\255\\\n    \\115\\002\\190\\002\\009\\003\\084\\003\\159\\003\\250\\003\\020\\000\\040\\000\\\n    \\001\\000\\013\\000\\059\\000\\041\\000\\053\\000\\096\\000\\110\\000\\108\\000\\\n    \\117\\000\\117\\000\\108\\000\\152\\000\\237\\255\\069\\004\\144\\004\\219\\004\\\n    \\038\\005\\113\\005\\191\\005\\010\\006\\235\\003\\085\\006\\095\\006\\170\\006\\\n    \\245\\006\\064\\007\\139\\007\\214\\007\\033\\008\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\022\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\255\\255\\255\\255\\014\\000\\255\\255\\011\\000\\009\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\001\\000\\\n    \\000\\000\\255\\255\\003\\000\\255\\255\\023\\000\\255\\255\\255\\255\\255\\255\\\n    \\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\024\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\024\\000\\024\\000\\024\\000\\\n    \\024\\000\\024\\000\\024\\000\\019\\000\\255\\255\\019\\000\\024\\000\\020\\000\\\n    \\024\\000\\024\\000\\021\\000\\025\\000\\026\\000\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\000\\000\\000\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\024\\000\\023\\000\\023\\000\\000\\000\\023\\000\\023\\000\\024\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\024\\000\\041\\000\\000\\000\\021\\000\\000\\000\\000\\000\\024\\000\\000\\000\\\n    \\020\\000\\019\\000\\010\\000\\013\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\022\\000\\000\\000\\015\\000\\016\\000\\014\\000\\003\\000\\\n    \\002\\000\\004\\000\\006\\000\\004\\000\\004\\000\\004\\000\\009\\000\\004\\000\\\n    \\004\\000\\007\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\008\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\018\\000\\031\\000\\017\\000\\030\\000\\029\\000\\\n    \\042\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\028\\000\\028\\000\\039\\000\\011\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\028\\000\\028\\000\\040\\000\\043\\000\\044\\000\\045\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\046\\000\\047\\000\\048\\000\\049\\000\\050\\000\\\n    \\051\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\052\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\064\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\062\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\053\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\032\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\027\\000\\000\\000\\\n    \\000\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\033\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\034\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\035\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\036\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\037\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\038\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\054\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\055\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\056\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\057\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\058\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\060\\000\\000\\000\\000\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\063\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\065\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\\n    \\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\066\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\004\\000\\000\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\000\\000\\000\\000\\000\\000\\000\\000\\067\\000\\000\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\068\\000\\000\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\023\\000\\255\\255\\000\\000\\023\\000\\024\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\040\\000\\255\\255\\000\\000\\255\\255\\255\\255\\024\\000\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\014\\000\\000\\000\\015\\000\\016\\000\\\n    \\041\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\025\\000\\025\\000\\038\\000\\000\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\028\\000\\028\\000\\039\\000\\042\\000\\043\\000\\044\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n    \\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n    \\050\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n    \\003\\000\\003\\000\\003\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\051\\000\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\004\\000\\255\\255\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\\n    \\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\004\\000\\005\\000\\005\\000\\\n    \\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\005\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\255\\255\\255\\255\\255\\255\\255\\255\\006\\000\\\n    \\255\\255\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\006\\000\\\n    \\006\\000\\006\\000\\006\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\007\\000\\255\\255\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\\n    \\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\007\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\255\\255\\255\\255\\255\\255\\255\\255\\008\\000\\255\\255\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\\n    \\008\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\009\\000\\255\\255\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\009\\000\\\n    \\009\\000\\009\\000\\009\\000\\009\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\021\\000\\255\\255\\\n    \\255\\255\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\021\\000\\\n    \\021\\000\\021\\000\\021\\000\\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\\n    \\026\\000\\026\\000\\026\\000\\026\\000\\026\\000\\027\\000\\027\\000\\027\\000\\\n    \\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\027\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\021\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\032\\000\\255\\255\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\\n    \\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\032\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\255\\255\\255\\255\\255\\255\\255\\255\\033\\000\\255\\255\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\033\\000\\\n    \\033\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\034\\000\\255\\255\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\034\\000\\\n    \\034\\000\\034\\000\\034\\000\\034\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\035\\000\\255\\255\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\\n    \\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\035\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\255\\255\\255\\255\\255\\255\\255\\255\\036\\000\\255\\255\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\036\\000\\\n    \\036\\000\\036\\000\\037\\000\\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\\n    \\060\\000\\060\\000\\060\\000\\060\\000\\060\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\037\\000\\255\\255\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\\n    \\037\\000\\037\\000\\037\\000\\037\\000\\037\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\053\\000\\255\\255\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\053\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\255\\255\\255\\255\\255\\255\\255\\255\\054\\000\\\n    \\255\\255\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\054\\000\\\n    \\054\\000\\054\\000\\054\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\055\\000\\255\\255\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\\n    \\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\055\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\255\\255\\255\\255\\255\\255\\255\\255\\056\\000\\255\\255\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\056\\000\\\n    \\056\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\057\\000\\255\\255\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\057\\000\\\n    \\057\\000\\057\\000\\057\\000\\057\\000\\058\\000\\255\\255\\255\\255\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\255\\255\\255\\255\\255\\255\\255\\255\\058\\000\\255\\255\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\058\\000\\\n    \\058\\000\\058\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\059\\000\\255\\255\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\\n    \\059\\000\\059\\000\\059\\000\\059\\000\\059\\000\\061\\000\\061\\000\\061\\000\\\n    \\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\061\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\255\\255\\255\\255\\255\\255\\255\\255\\062\\000\\255\\255\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\062\\000\\\n    \\062\\000\\062\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\063\\000\\255\\255\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\\n    \\063\\000\\063\\000\\063\\000\\063\\000\\063\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\064\\000\\255\\255\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\064\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\255\\255\\255\\255\\255\\255\\255\\255\\065\\000\\\n    \\255\\255\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\065\\000\\\n    \\065\\000\\065\\000\\065\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\066\\000\\255\\255\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\\n    \\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\066\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\255\\255\\255\\255\\255\\255\\255\\255\\067\\000\\255\\255\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\067\\000\\\n    \\067\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\068\\000\\255\\255\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\068\\000\\\n    \\068\\000\\068\\000\\068\\000\\068\\000\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec token lexbuf =\n   __ocaml_lex_token_rec lexbuf 0\nand __ocaml_lex_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 163 \"z3/z3Lexer.mll\"\n                               ( token lexbuf )\n# 791 \"z3/z3Lexer.ml\"\n\n  | 1 ->\n# 164 \"z3/z3Lexer.mll\"\n                               ( EOL )\n# 796 \"z3/z3Lexer.ml\"\n\n  | 2 ->\n# 166 \"z3/z3Lexer.mll\"\n                               ( COLON )\n# 801 \"z3/z3Lexer.ml\"\n\n  | 3 ->\nlet\n# 167 \"z3/z3Lexer.mll\"\n                i\n# 807 \"z3/z3Lexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in\n# 167 \"z3/z3Lexer.mll\"\n                               ( SHARPINT (int_of_string i) )\n# 811 \"z3/z3Lexer.ml\"\n\n  | 4 ->\n# 169 \"z3/z3Lexer.mll\"\n                               ( LPAR )\n# 816 \"z3/z3Lexer.ml\"\n\n  | 5 ->\n# 170 \"z3/z3Lexer.mll\"\n                               ( RPAR )\n# 821 \"z3/z3Lexer.ml\"\n\n  | 6 ->\n# 172 \"z3/z3Lexer.mll\"\n                               ( LBRACKET )\n# 826 \"z3/z3Lexer.ml\"\n\n  | 7 ->\n# 173 \"z3/z3Lexer.mll\"\n                               ( RBRACKET )\n# 831 \"z3/z3Lexer.ml\"\n\n  | 8 ->\n# 175 \"z3/z3Lexer.mll\"\n                               ( EQ )\n# 836 \"z3/z3Lexer.ml\"\n\n  | 9 ->\n# 176 \"z3/z3Lexer.mll\"\n                               ( LT )\n# 841 \"z3/z3Lexer.ml\"\n\n  | 10 ->\n# 177 \"z3/z3Lexer.mll\"\n                               ( LEQ )\n# 846 \"z3/z3Lexer.ml\"\n\n  | 11 ->\n# 178 \"z3/z3Lexer.mll\"\n                               ( GT )\n# 851 \"z3/z3Lexer.ml\"\n\n  | 12 ->\n# 179 \"z3/z3Lexer.mll\"\n                               ( GEQ )\n# 856 \"z3/z3Lexer.ml\"\n\n  | 13 ->\n# 180 \"z3/z3Lexer.mll\"\n                               ( PLUS )\n# 861 \"z3/z3Lexer.ml\"\n\n  | 14 ->\n# 181 \"z3/z3Lexer.mll\"\n                               ( MINUS )\n# 866 \"z3/z3Lexer.ml\"\n\n  | 15 ->\n# 182 \"z3/z3Lexer.mll\"\n                               ( OPP )\n# 871 \"z3/z3Lexer.ml\"\n\n  | 16 ->\n# 183 \"z3/z3Lexer.mll\"\n                               ( MULT )\n# 876 \"z3/z3Lexer.ml\"\n\n  | 17 ->\n# 184 \"z3/z3Lexer.mll\"\n                               ( IMP )\n# 881 \"z3/z3Lexer.ml\"\n\n  | 18 ->\n# 186 \"z3/z3Lexer.mll\"\n                               ( SAT )\n# 886 \"z3/z3Lexer.ml\"\n\n  | 19 ->\nlet\n# 188 \"z3/z3Lexer.mll\"\n                      i\n# 892 \"z3/z3Lexer.ml\"\n= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 7) lexbuf.Lexing.lex_curr_pos in\n# 188 \"z3/z3Lexer.mll\"\n                               ( TINDEX (int_of_string i) )\n# 896 \"z3/z3Lexer.ml\"\n\n  | 20 ->\n# 189 \"z3/z3Lexer.mll\"\n                             ( TINT )\n# 901 \"z3/z3Lexer.ml\"\n\n  | 21 ->\n# 190 \"z3/z3Lexer.mll\"\n                   ( TBOOL )\n# 906 \"z3/z3Lexer.ml\"\n\n  | 22 ->\nlet\n# 191 \"z3/z3Lexer.mll\"\n            i\n# 912 \"z3/z3Lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 191 \"z3/z3Lexer.mll\"\n                               ( try INT (int_of_string i)\n\t                         with _ ->\n                                   BIGINT (Big_int.big_int_of_string i) )\n# 918 \"z3/z3Lexer.ml\"\n\n  | 23 ->\nlet\n# 194 \"z3/z3Lexer.mll\"\n                 bv\n# 924 \"z3/z3Lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 194 \"z3/z3Lexer.mll\"\n                               ( BITV bv )\n# 928 \"z3/z3Lexer.ml\"\n\n  | 24 ->\n# 195 \"z3/z3Lexer.mll\"\n                               ( let v = Lexing.lexeme lexbuf in\n                                 try Hashtbl.find typ_table v with\n                                   | Not_found -> VAR v )\n# 935 \"z3/z3Lexer.ml\"\n\n  | 25 ->\nlet\n# 198 \"z3/z3Lexer.mll\"\n               v\n# 941 \"z3/z3Lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 198 \"z3/z3Lexer.mll\"\n                               ( BINDVAR v )\n# 945 \"z3/z3Lexer.ml\"\n\n  | 26 ->\n# 200 \"z3/z3Lexer.mll\"\n                   ( ATVAR (Lexing.lexeme lexbuf) )\n# 950 \"z3/z3Lexer.ml\"\n\n  | 27 ->\n# 202 \"z3/z3Lexer.mll\"\n                               ( raise Eof )\n# 955 \"z3/z3Lexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1094,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1094, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1095,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1095, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1096,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1096, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1097,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1097, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1098,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1098, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1099,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1099, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":11},"end":{"line":40,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1100, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1101,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":44,"character":29}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 1101, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
Read message 
{"jsonrpc":"2.0","id":1102,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 1102, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1103,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1103, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1104,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1104, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1105,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":250,"character":10},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1105, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1106,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1106, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1107,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1107, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1108,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1108, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1109,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":250,"character":10},"end":{"line":250,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1109, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1110,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1110, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1111,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":18,"character":18}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0228881835938ms
Sending response {"id": 1111, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":39},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of ver proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1112,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1112, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1113,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":18},"end":{"line":18,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1113, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1114,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1114, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":42},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of v3 proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1115,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1115, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1116,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":17},"end":{"line":18,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00309944152832ms
Sending response {"id": 1116, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1117,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1117, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":42},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of v3 proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":42}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1118,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":33,"character":23},"end":{"line":33,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1118, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1119,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":22,"character":674},"end":{"line":22,"character":675}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1119, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1120,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":220,"character":20},"end":{"line":220,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1120, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1121,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":52,"character":22},"end":{"line":52,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1121, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":43},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of v proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1122,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":16},"end":{"line":18,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1122, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1123,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1123, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1124,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1124, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1125,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":47,"character":27}}}
[server] Got a method textDocument/definition
[server] processing took 0.00905990600586ms
Sending response {"id": 1125, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":44},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of ver proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1126,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":18},"end":{"line":18,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1126, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1127,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1127, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":45},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1128,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":15},"end":{"line":18,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1128, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1129,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1129, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1130,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1130, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":46},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of ver proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1131,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":18},"end":{"line":18,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1131, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1132,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1132, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1133,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1133, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":47},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1134,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":15},"end":{"line":18,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1134, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1135,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1135, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1136,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1136, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1137,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 1137, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1138,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":15},"end":{"line":18,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1138, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":48},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of ver proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1139,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":18},"end":{"line":18,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1139, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1140,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1140, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1141,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1141, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":50},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of v3 proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1142,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":17},"end":{"line":18,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1142, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1143,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1143, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1144,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1144, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1145,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":18,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Sending response {"id": 1145, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":52},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of z3 proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1146,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1146, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1147,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":16},"end":{"line":18,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 1147, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1148,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1148, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":52},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of z3 proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"Z3Syntax.get_eq: equality was expected\")\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"Z3Syntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"Z3Syntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"Z3Syntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"Z3Syntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"Z3Syntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"Z3Syntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"Z3Syntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"Z3Syntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"Z3Syntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"Z3Syntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"Z3Syntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"Z3Syntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"Z3Syntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"Z3Syntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"Z3Syntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"Z3Syntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"Z3Syntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"Z3Syntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"Z3Syntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"Z3Syntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"Z3Syntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"Z3Syntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"Z3Syntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"Z3Syntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"Z3Syntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"Z3Syntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"Z3Syntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"Z3Syntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"Z3Syntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"Z3Syntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"Z3Syntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"Z3Syntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml","version":52}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1149,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1149, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1150,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1150, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1151,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1151, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1152,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":16},"end":{"line":18,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1152, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1152}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml","languageId":"ocaml","version":1,"text":"(*** This file is taken from Coq-8.9.0 to solve a compilation issue due\n   to a wrong order in dependencies.\n   See https://github.com/coq/coq/issues/9768 . ***)\n\n\n(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n(*                                                                      *)\n(* Micromega: A reflexive tactic using the Positivstellensatz           *)\n(*                                                                      *)\n(* ** Utility functions **                                              *)\n(*                                                                      *)\n(* - Modules CoqToCaml, CamlToCoq                                       *)\n(* - Modules Cmp, Tag, TagSet                                           *)\n(*                                                                      *)\n(*  Frdric Besson (Irisa/Inria) 2006-2008                             *)\n(*                                                                      *)\n(************************************************************************)\n\nmodule Micromega = Micromega_plugin.Micromega\n\nlet rec pp_list f o l =\n  match l with\n    | [] -> ()\n    | e::l -> f o e ; output_string o \";\" ; pp_list f o l\n\n\nlet finally f rst =\n  try\n    let res = f () in\n      rst () ; res\n  with reraise ->\n    (try rst ()\n    with any -> raise reraise\n    ); raise reraise\n\nlet rec try_any l x =\n match l with\n  | [] -> None\n  | (f,s)::l -> match f x with\n     | None -> try_any l x\n     | x -> x\n\nlet all_sym_pairs f l = \n  let pair_with acc e l = List.fold_left (fun acc x -> (f e x) ::acc) acc l in\n\n  let rec xpairs acc l = \n    match l with\n      | [] -> acc\n      | e::l -> xpairs (pair_with acc e l) l in\n    xpairs [] l\n\nlet all_pairs f l = \n  let pair_with acc e l = List.fold_left (fun acc x -> (f e x) ::acc) acc l in\n\n  let rec xpairs acc l = \n    match l with\n      | [] -> acc\n      | e::lx -> xpairs (pair_with acc e l) lx in\n    xpairs [] l\n\nlet rec is_sublist f l1 l2 =\n  match l1 ,l2 with\n    | [] ,_ -> true\n    | e::l1', [] -> false\n    | e::l1' , e'::l2' ->\n\tif f e e' then is_sublist f l1' l2'\n\telse is_sublist f l1 l2'\n\nlet extract pred l = \n  List.fold_left (fun (fd,sys) e -> \n\t\t    match fd with\n\t\t    | None -> \n\t\t\tbegin\n\t\t\t  match pred e with\n\t\t\t  | None -> fd, e::sys\n\t\t\t  | Some v -> Some(v,e) , sys\n\t\t\tend\n\t\t    |  _   -> (fd, e::sys)\n\t\t ) (None,[]) l\n\nopen Num\nopen Big_int\n\nlet ppcm x y =\n let g = gcd_big_int x y in\n let x' = div_big_int x g in\n let y' = div_big_int y g in\n  mult_big_int g (mult_big_int x' y')\n\nlet denominator = function\n | Int _ | Big_int _ -> unit_big_int\n | Ratio r -> Ratio.denominator_ratio r\n\nlet numerator = function\n | Ratio r -> Ratio.numerator_ratio r\n | Int i -> Big_int.big_int_of_int i\n | Big_int i -> i\n\nlet rec ppcm_list c l =\n match l with\n  | [] -> c\n  | e::l -> ppcm_list (ppcm c (denominator e)) l\n\nlet rec rec_gcd_list c l  =\n match l with\n  | [] -> c\n  | e::l -> rec_gcd_list (gcd_big_int  c (numerator e)) l\n\nlet gcd_list l =\n let res = rec_gcd_list zero_big_int l in\n  if Int.equal (compare_big_int res zero_big_int) 0\n  then unit_big_int else res\n\nlet rats_to_ints l =\n let c = ppcm_list unit_big_int l in\n  List.map (fun x ->  (div_big_int (mult_big_int (numerator x) c)\n\t\t\t(denominator x))) l\n\n(* assoc_pos j [a0...an] = [j,a0....an,j+n],j+n+1 *)\n(**\n  * MODULE: Coq to Caml data-structure mappings\n  *)\n\nmodule CoqToCaml =\nstruct\n open Micromega\n\n let rec nat = function\n  | O -> 0\n  | S n -> (nat n) + 1\n\n\n let rec positive p =\n  match p with\n   | XH -> 1\n   | XI p -> 1+ 2*(positive p)\n   | XO p -> 2*(positive p)\n\n let n nt =\n  match nt with\n   | N0 -> 0\n   | Npos p -> positive p\n\n let rec index i = (* Swap left-right ? *)\n  match i with\n   | XH -> 1\n   | XI i -> 1+(2*(index i))\n   | XO i -> 2*(index i)\n\n open Big_int\n\n let rec positive_big_int p =\n  match p with\n   | XH -> unit_big_int\n   | XI p -> add_int_big_int 1 (mult_int_big_int 2 (positive_big_int p))\n   | XO p -> (mult_int_big_int 2 (positive_big_int p))\n\n let z_big_int x =\n  match x with\n   | Z0 -> zero_big_int\n   | Zpos p -> (positive_big_int p)\n   | Zneg p -> minus_big_int (positive_big_int p)\n\n let q_to_num {qnum = x ; qden = y} =\n  Big_int (z_big_int x) // (Big_int (z_big_int (Zpos y)))\n\nend\n\n\n(**\n  * MODULE: Caml to Coq data-structure mappings\n  *)\n\nmodule CamlToCoq =\nstruct\n open Micromega\n\n let rec nat = function\n  | 0 -> O\n  | n -> S (nat (n-1))\n\n\n let rec positive n =\n  if Int.equal n 1 then XH\n  else if Int.equal (n land 1) 1 then XI (positive (n lsr 1))\n  else  XO (positive (n lsr 1))\n\n let n nt =\n  if nt < 0\n  then assert false\n  else if Int.equal nt 0 then N0\n  else Npos (positive nt)\n\n let rec index  n =\n  if Int.equal n 1 then XH\n  else if Int.equal (n land 1) 1 then XI (index (n lsr 1))\n  else  XO (index (n lsr 1))\n\n\n let z x =\n  match compare x 0 with\n   | 0 -> Z0\n   | 1 -> Zpos (positive x)\n   | _ -> (* this should be -1 *)\n      Zneg (positive (-x))\n\n open Big_int\n\n let positive_big_int n =\n  let two = big_int_of_int 2 in\n  let rec _pos n =\n   if eq_big_int n unit_big_int then XH\n   else\n    let (q,m) = quomod_big_int n two  in\n     if eq_big_int unit_big_int m\n     then XI (_pos q)\n     else XO (_pos q) in\n   _pos n\n\n let bigint x =\n  match sign_big_int x with\n   | 0 -> Z0\n   | 1 -> Zpos (positive_big_int x)\n   | _ -> Zneg (positive_big_int (minus_big_int x))\n\n let q n =\n  {Micromega.qnum = bigint (numerator n) ;\n   Micromega.qden = positive_big_int (denominator n)}\n\nend\n\n(**\n  * MODULE: Comparisons on lists: by evaluating the elements in a single list,\n  * between two lists given an ordering, and using a hash computation\n  *)\n\nmodule Cmp =\nstruct\n\n let rec compare_lexical l =\n  match l with\n   | [] -> 0 (* Equal *)\n   | f::l ->\n      let cmp = f () in\n       if Int.equal cmp 0 then compare_lexical l else cmp\n\n let rec compare_list cmp l1 l2 =\n  match l1 , l2 with\n   | []  , [] -> 0\n   | []  , _  -> -1\n   | _   , [] -> 1\n   | e1::l1 , e2::l2 ->\n      let c = cmp e1 e2 in\n       if Int.equal c 0 then compare_list cmp l1 l2 else c\n\nend\n\n(**\n  * MODULE: Labels for atoms in propositional formulas. \n  * Tags are used to identify unused atoms in CNFs, and propagate them back to\n  * the original formula. The translation back to Coq then ignores these\n  * superfluous items, which speeds the translation up a bit.\n  *)\n\nmodule type Tag =\nsig\n\n  type t\n\n  val from : int -> t\n  val next : t -> t\n  val pp : out_channel -> t -> unit\n  val compare : t -> t -> int\n\nend\n\nmodule Tag : Tag =\nstruct\n\n  type t = int\n\n  let from i = i\n  let next i = i + 1\n  let pp o i = output_string o (string_of_int i)\n  let compare : int -> int -> int = Int.compare\n\nend\n\n(**\n  * MODULE: Ordered sets of tags.\n  *)\n\nmodule TagSet = Set.Make(Tag)\n\n(** As for Unix.close_process, our Unix.waipid will ignore all EINTR *)\n\nlet rec waitpid_non_intr pid =\n  try snd (Unix.waitpid [] pid)\n  with Unix.Unix_error (Unix.EINTR, _, _) -> waitpid_non_intr pid\n\n(**\n  * Forking routine, plumbing the appropriate pipes where needed.\n  *)\n\nlet command exe_path args vl =\n  (* creating pipes for stdin, stdout, stderr *)\n  let (stdin_read,stdin_write) = Unix.pipe ()\n  and (stdout_read,stdout_write) = Unix.pipe ()\n  and (stderr_read,stderr_write) = Unix.pipe () in\n\n  (* Create the process *)\n  let pid = Unix.create_process exe_path args stdin_read stdout_write stderr_write in\n\n  (* Write the data on the stdin of the created process *)\n  let outch = Unix.out_channel_of_descr stdin_write in\n    output_value outch vl ;\n    flush outch ;\n\n  (* Wait for its completion *)\n    let status = waitpid_non_intr pid in\n\n      finally\n        (* Recover the result *)\n\t(fun () ->\n\t  match status with\n\t    | Unix.WEXITED 0 ->\n\t\tlet inch = Unix.in_channel_of_descr stdout_read in\n\t\tbegin\n                  try Marshal.from_channel inch\n                  with any ->\n                    failwith\n                      (Printf.sprintf \"command \\\"%s\\\" exited %s\" exe_path\n                         (Printexc.to_string any))\n                end\n\t    | Unix.WEXITED i   ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" exited %i\" exe_path i)\n\t    | Unix.WSIGNALED i ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" killed %i\" exe_path i)\n\t    | Unix.WSTOPPED i  ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" stopped %i\" exe_path i))\n        (* Cleanup  *)\n\t(fun () ->\n\t  List.iter (fun x -> try Unix.close x with any -> ())\n            [stdin_read; stdin_write;\n             stdout_read; stdout_write;\n             stderr_read; stderr_write])\n\n(* Local Variables: *)\n(* coding: utf-8 *)\n(* End: *)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1153,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0338554382324ms
Sending response {"id": 1153, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1154,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0221729278564ms
Sending response {"id": 1154, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1155,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1155, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1156,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"},"range":{"start":{"line":11,"character":51},"end":{"line":11,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 1156, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1153}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1156}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Entries\n\n\n(* Constr generation and manipulation *)\ntype id = Names.variable\nlet mkId = Names.Id.of_string\n\n\ntype name = Names.Name.t\nlet name_of_id i = Names.Name i\nlet mkName s =\n  let id = mkId s in\n  name_of_id id\nlet string_of_name = function\n    Names.Name id -> Names.Id.to_string id\n  | _ -> failwith \"unnamed rel\"\n\n\ntype constr = Constr.t\ntype types = Constr.types\nlet eq_constr = Constr.equal\nlet hash_constr = Constr.hash\nlet mkProp = Constr.mkProp\nlet mkConst = Constr.mkConst\nlet mkVar = Constr.mkVar\nlet mkRel = Constr.mkRel\nlet isRel = Constr.isRel\nlet destRel = Constr.destRel\nlet lift = Vars.lift\nlet mkApp = Constr.mkApp\nlet decompose_app = Constr.decompose_app\nlet mkLambda = Constr.mkLambda\nlet mkProd = Constr.mkProd\nlet mkLetIn = Constr.mkLetIn\n\nlet pr_constr_env env = Printer.pr_constr_env env Evd.empty\nlet pr_constr = pr_constr_env Environ.empty_env\n\n\nlet mkUConst : Constr.t -> Safe_typing.private_constants Entries.definition_entry = fun c ->\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, ty = Typing.type_of env evd (EConstr.of_constr c) in\n  { Entries.const_entry_body        = Future.from_val ((c, Univ.ContextSet.empty),\n                                               Safe_typing.empty_private_constants);\n    const_entry_secctx      = None;\n    const_entry_feedback    = None;\n    const_entry_type        = Some (EConstr.Unsafe.to_constr ty); (* Cannot contain evars since it comes from a Constr.t *)\n    const_entry_universes   = Evd.const_univ_entry ~poly:false evd;\n    const_entry_opaque      = false;\n    const_entry_inline_code = false }\n\nlet mkTConst c noc ty =\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, _ = Typing.type_of env evd (EConstr.of_constr noc) in\n  { const_entry_body        = Future.from_val ((c, Univ.ContextSet.empty),\n                                               Safe_typing.empty_private_constants);\n    const_entry_secctx      = None;\n    const_entry_feedback    = None;\n    const_entry_type        = Some ty;\n    const_entry_universes   = Evd.const_univ_entry ~poly:false evd;\n    const_entry_opaque      = false;\n    const_entry_inline_code = false }\n\n(* TODO : Set -> Type *)\nlet declare_new_type t =\n  let _ = ComAssumption.declare_assumption false (Decl_kinds.Discharge, false, Decl_kinds.Definitional) (Constr.mkSet, Entries.Monomorphic_const_entry Univ.ContextSet.empty) UnivNames.empty_binders [] false Declaremods.NoInline (CAst.make t) in\n  Constr.mkVar t\n\nlet declare_new_variable v constr_t =\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, _ = Typing.type_of env evd (EConstr.of_constr constr_t) in\n  let _ = ComAssumption.declare_assumption false (Decl_kinds.Discharge, false, Decl_kinds.Definitional) (constr_t, Evd.const_univ_entry ~poly:false evd) UnivNames.empty_binders [] false Declaremods.NoInline (CAst.make v) in\n  Constr.mkVar v\n\nlet declare_constant n c =\n  Declare.declare_constant n (DefinitionEntry c, Decl_kinds.IsDefinition Decl_kinds.Definition)\n\n\n\ntype cast_kind = Constr.cast_kind\nlet vmcast = Constr.VMcast\nlet mkCast = Constr.mkCast\n\n\n(* EConstr *)\ntype econstr = EConstr.t\nlet econstr_of_constr = EConstr.of_constr\n\n\n(* Modules *)\nlet gen_constant_in_modules s m n = UnivGen.constr_of_global @@ Coqlib.gen_reference_in_modules s m n\nlet gen_constant modules constant = lazy (gen_constant_in_modules \"SMT\" modules constant)\n\n\n(* Int63 *)\nlet int63_modules = [[\"SMTCoq\";\"versions\";\"standard\";\"Int63\";\"Int63Native\"]]\n\n(* 31-bits integers are \"called\" 63 bits (this is sound) *)\nlet int31_module = [[\"Coq\";\"Numbers\";\"Cyclic\";\"Int31\";\"Int31\"]]\nlet cD0 = gen_constant int31_module \"D0\"\nlet cD1 = gen_constant int31_module \"D1\"\nlet cI31 = gen_constant int31_module \"I31\"\n\nlet mkInt : int -> constr = fun i ->\n  let a = Array.make 31 (Lazy.force cD0) in\n  let j = ref i in\n  let k = ref 30 in\n  while !j <> 0 do\n    if !j land 1 = 1 then a.(!k) <- Lazy.force cD1;\n    j := !j lsr 1;\n    decr k\n  done;\n  mkApp (Lazy.force cI31, a)\n\nlet cint = gen_constant int31_module \"int31\"\n\n\n(* PArray *)\nlet parray_modules = [[\"SMTCoq\";\"versions\";\"standard\";\"Array\";\"PArray\"]]\n\nlet cmake = gen_constant parray_modules \"make\"\nlet cset = gen_constant parray_modules \"set\"\n\nlet max_array_size : int = 4194302\nlet mkArray : Constr.types * Constr.t array -> Constr.t =\n  fun (ty, a) ->\n  let l = (Array.length a) - 1 in\n  snd (Array.fold_left (fun (i,acc) c ->\n                        let acc' =\n                          if i = l then\n                            acc\n                          else\n                            mkApp (Lazy.force cset, [|ty; acc; mkInt i; c|]) in\n                        (i+1,acc')\n                       ) (0, mkApp (Lazy.force cmake, [|ty; mkInt l; a.(l)|])) a)\n\n\n(* Traces *)\n(* WARNING: side effect on r! *)\nlet mkTrace step_to_coq next _ clist cnil ccons cpair size step def_step r =\n  let rec mkTrace s =\n    if s = size then\n      mkApp (Lazy.force cnil, [|step|])\n    else (\n      r := next !r;\n      let st = step_to_coq !r in\n      mkApp (Lazy.force ccons, [|step; st; mkTrace (s+1)|])\n    ) in\n  mkApp (Lazy.force cpair, [|mkApp (Lazy.force clist, [|step|]); step; mkTrace 0; def_step|])\n\n\n(* Micromega *)\nmodule Micromega_plugin_Micromega = Micromega_plugin.Micromega\nmodule Micromega_plugin_Mutils = Mutils_full\nmodule Micromega_plugin_Certificate = Micromega_plugin.Certificate\nmodule Micromega_plugin_Coq_micromega = Coq_micromega_full\n\nlet micromega_coq_proofTerm =\n  (* Cannot contain evars *)\n  lazy (EConstr.Unsafe.to_constr (Lazy.force (Micromega_plugin_Coq_micromega.M.coq_proofTerm)))\n\nlet micromega_dump_proof_term p =\n  (* Cannot contain evars *)\n  EConstr.Unsafe.to_constr (Micromega_plugin_Coq_micromega.dump_proof_term p)\n\n\n(* Tactics *)\ntype tactic = unit Proofview.tactic\nlet tclTHEN = Tacticals.New.tclTHEN\nlet tclTHENLAST = Tacticals.New.tclTHENLAST\nlet assert_before n c = Tactics.assert_before n (EConstr.of_constr c)\n\nlet vm_cast_no_check c = Tactics.vm_cast_no_check (EConstr.of_constr c)\n\nlet mk_tactic tac =\n  Proofview.Goal.nf_enter (fun gl ->\n    let env = Proofview.Goal.env gl in\n    let sigma = Tacmach.New.project gl in\n    let t = Proofview.Goal.concl gl in\n    let t = EConstr.to_constr sigma t in (* The goal should not contain uninstanciated evars *)\n    tac env sigma t\n  )\nlet set_evars_tac noc =\n  mk_tactic (\n      fun env sigma _ ->\n      let sigma, _ = Typing.type_of env sigma (EConstr.of_constr noc) in\n      Proofview.Unsafe.tclEVARS sigma)\n\n\n(* Other differences between the two versions of Coq *)\ntype constr_expr = Constrexpr.constr_expr\nlet error s = CErrors.user_err (Pp.str s)\nlet warning n s = CWarnings.create ~name:n ~category:\"SMTCoq plugin\" Pp.str s\n\nlet extern_constr c = Constrextern.extern_constr true Environ.empty_env Evd.empty (EConstr.of_constr c)\n\nlet destruct_rel_decl r = Context.Rel.Declaration.get_name r,\n                          Context.Rel.Declaration.get_type r\n\n(* Cannot contain evars since it comes from a Constr.t *)\nlet interp_constr env sigma t = Constrintern.interp_constr env sigma t |> fst |> EConstr.Unsafe.to_constr\n\nlet ppconstr_lsimpleconstr = Ppconstr.lsimpleconstr\n\nlet constrextern_extern_constr c =\n  let env = Global.env () in\n  Constrextern.extern_constr false env (Evd.from_env env) (EConstr.of_constr c)\n\nlet get_rel_dec_name = function\n  | Context.Rel.Declaration.LocalAssum (n, _) | Context.Rel.Declaration.LocalDef (n, _, _) -> n\n\nlet retyping_get_type_of env sigma c =\n  (* Cannot contain evars since it comes from a Constr.t *)\n  EConstr.Unsafe.to_constr (Retyping.get_type_of env sigma (EConstr.of_constr c))\n\nlet vm_conv = Vconv.vm_conv\n\n(* Cannot contain evars since it comes from a Constr.t *)\nlet cbv_vm env c t = EConstr.Unsafe.to_constr (Vnorm.cbv_vm env Evd.empty (EConstr.of_constr c) (EConstr.of_constr t))\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1157,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1157, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1158,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1158, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1159,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1159, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Entries\n\n\n(* Constr generation and manipulation *)\ntype id = Names.variable\nlet mkId = Names.Id.of_string\n\n\ntype name = Names.Name.t\nlet name_of_id i = Names.Name i\nlet mkName s =\n  let id = mkId s in\n  name_of_id id\nlet string_of_name = function\n    Names.Name id -> Names.Id.to_string id\n  | _ -> failwith \"unnamed rel\"\n\n\ntype constr = Constr.t\ntype types = Constr.types\nlet eq_constr = Constr.equal\nlet hash_constr = Constr.hash\nlet mkProp = Constr.mkProp\nlet mkConst = Constr.mkConst\nlet mkVar = Constr.mkVar\nlet mkRel = Constr.mkRel\nlet isRel = Constr.isRel\nlet destRel = Constr.destRel\nlet lift = Vars.lift\nlet mkApp = Constr.mkApp\nlet decompose_app = Constr.decompose_app\nlet mkLambda = Constr.mkLambda\nlet mkProd = Constr.mkProd\nlet mkLetIn = Constr.mkLetIn\n\nlet pr_constr_env env = Printer.pr_constr_env env Evd.empty\nlet pr_constr = pr_constr_env Environ.empty_env\n\n\nlet mkUConst : Constr.t -> Safe_typing.private_constants Entries.definition_entry = fun c ->\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, ty = Typing.type_of env evd (EConstr.of_constr c) in\n  { Entries.const_entry_body        = Future.from_val ((c, Univ.ContextSet.empty),\n                                               Safe_typing.empty_private_constants);\n    const_entry_secctx      = None;\n    const_entry_feedback    = None;\n    const_entry_type        = Some (EConstr.Unsafe.to_constr ty); (* Cannot contain evars since it comes from a Constr.t *)\n    const_entry_universes   = Evd.const_univ_entry ~poly:false evd;\n    const_entry_opaque      = false;\n    const_entry_inline_code = false }\n\nlet mkTConst c noc ty =\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, _ = Typing.type_of env evd (EConstr.of_constr noc) in\n  { const_entry_body        = Future.from_val ((c, Univ.ContextSet.empty),\n                                               Safe_typing.empty_private_constants);\n    const_entry_secctx      = None;\n    const_entry_feedback    = None;\n    const_entry_type        = Some ty;\n    const_entry_universes   = Evd.const_univ_entry ~poly:false evd;\n    const_entry_opaque      = false;\n    const_entry_inline_code = false }\n\n(* TODO : Set -> Type *)\nlet declare_new_type t =\n  let _ = ComAssumption.declare_assumption false (Decl_kinds.Discharge, false, Decl_kinds.Definitional) (Constr.mkSet, Entries.Monomorphic_const_entry Univ.ContextSet.empty) UnivNames.empty_binders [] false Declaremods.NoInline (CAst.make t) in\n  Constr.mkVar t\n\nlet declare_new_variable v constr_t =\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, _ = Typing.type_of env evd (EConstr.of_constr constr_t) in\n  let _ = ComAssumption.declare_assumption false (Decl_kinds.Discharge, false, Decl_kinds.Definitional) (constr_t, Evd.const_univ_entry ~poly:false evd) UnivNames.empty_binders [] false Declaremods.NoInline (CAst.make v) in\n  Constr.mkVar v\n\nlet declare_constant n c =\n  Declare.declare_constant n (DefinitionEntry c, Decl_kinds.IsDefinition Decl_kinds.Definition)\n\n\n\ntype cast_kind = Constr.cast_kind\nlet vmcast = Constr.VMcast\nlet mkCast = Constr.mkCast\n\n\n(* EConstr *)\ntype econstr = EConstr.t\nlet econstr_of_constr = EConstr.of_constr\n\n\n(* Modules *)\nlet gen_constant_in_modules s m n = UnivGen.constr_of_global @@ Coqlib.gen_reference_in_modules s m n\nlet gen_constant modules constant = lazy (gen_constant_in_modules \"SMT\" modules constant)\n\n\n(* Int63 *)\nlet int63_modules = [[\"SMTCoq\";\"versions\";\"standard\";\"Int63\";\"Int63Native\"]]\n\n(* 31-bits integers are \"called\" 63 bits (this is sound) *)\nlet int31_module = [[\"Coq\";\"Numbers\";\"Cyclic\";\"Int31\";\"Int31\"]]\nlet cD0 = gen_constant int31_module \"D0\"\nlet cD1 = gen_constant int31_module \"D1\"\nlet cI31 = gen_constant int31_module \"I31\"\n\nlet mkInt : int -> constr = fun i ->\n  let a = Array.make 31 (Lazy.force cD0) in\n  let j = ref i in\n  let k = ref 30 in\n  while !j <> 0 do\n    if !j land 1 = 1 then a.(!k) <- Lazy.force cD1;\n    j := !j lsr 1;\n    decr k\n  done;\n  mkApp (Lazy.force cI31, a)\n\nlet cint = gen_constant int31_module \"int31\"\n\n\n(* PArray *)\nlet parray_modules = [[\"SMTCoq\";\"versions\";\"standard\";\"Array\";\"PArray\"]]\n\nlet cmake = gen_constant parray_modules \"make\"\nlet cset = gen_constant parray_modules \"set\"\n\nlet max_array_size : int = 4194302\nlet mkArray : Constr.types * Constr.t array -> Constr.t =\n  fun (ty, a) ->\n  let l = (Array.length a) - 1 in\n  snd (Array.fold_left (fun (i,acc) c ->\n                        let acc' =\n                          if i = l then\n                            acc\n                          else\n                            mkApp (Lazy.force cset, [|ty; acc; mkInt i; c|]) in\n                        (i+1,acc')\n                       ) (0, mkApp (Lazy.force cmake, [|ty; mkInt l; a.(l)|])) a)\n\n\n(* Traces *)\n(* WARNING: side effect on r! *)\nlet mkTrace step_to_coq next _ clist cnil ccons cpair size step def_step r =\n  let rec mkTrace s =\n    if s = size then\n      mkApp (Lazy.force cnil, [|step|])\n    else (\n      r := next !r;\n      let st = step_to_coq !r in\n      mkApp (Lazy.force ccons, [|step; st; mkTrace (s+1)|])\n    ) in\n  mkApp (Lazy.force cpair, [|mkApp (Lazy.force clist, [|step|]); step; mkTrace 0; def_step|])\n\n\n(* Micromega *)\nmodule Micromega_plugin_Micromega = Micromega_plugin.Micromega\nmodule Micromega_plugin_Mutils = Mutils_full\nmodule Micromega_plugin_Certificate = Micromega_plugin.Certificate\nmodule Micromega_plugin_Coq_micromega = Coq_micromega_full\n\nlet micromega_coq_proofTerm =\n  (* Cannot contain evars *)\n  lazy (EConstr.Unsafe.to_constr (Lazy.force (Micromega_plugin_Coq_micromega.M.coq_proofTerm)))\n\nlet micromega_dump_proof_term p =\n  (* Cannot contain evars *)\n  EConstr.Unsafe.to_constr (Micromega_plugin_Coq_micromega.dump_proof_term p)\n\n\n(* Tactics *)\ntype tactic = unit Proofview.tactic\nlet tclTHEN = Tacticals.New.tclTHEN\nlet tclTHENLAST = Tacticals.New.tclTHENLAST\nlet assert_before n c = Tactics.assert_before n (EConstr.of_constr c)\n\nlet vm_cast_no_check c = Tactics.vm_cast_no_check (EConstr.of_constr c)\n\nlet mk_tactic tac =\n  Proofview.Goal.nf_enter (fun gl ->\n    let env = Proofview.Goal.env gl in\n    let sigma = Tacmach.New.project gl in\n    let t = Proofview.Goal.concl gl in\n    let t = EConstr.to_constr sigma t in (* The goal should not contain uninstanciated evars *)\n    tac env sigma t\n  )\nlet set_evars_tac noc =\n  mk_tactic (\n      fun env sigma _ ->\n      let sigma, _ = Typing.type_of env sigma (EConstr.of_constr noc) in\n      Proofview.Unsafe.tclEVARS sigma)\n\n\n(* Other differences between the two versions of Coq *)\ntype constr_expr = Constrexpr.constr_expr\nlet error s = CErrors.user_err (Pp.str s)\nlet warning n s = CWarnings.create ~name:n ~category:\"SMTCoq plugin\" Pp.str s\n\nlet extern_constr c = Constrextern.extern_constr true Environ.empty_env Evd.empty (EConstr.of_constr c)\n\nlet destruct_rel_decl r = Context.Rel.Declaration.get_name r,\n                          Context.Rel.Declaration.get_type r\n\n(* Cannot contain evars since it comes from a Constr.t *)\nlet interp_constr env sigma t = Constrintern.interp_constr env sigma t |> fst |> EConstr.Unsafe.to_constr\n\nlet ppconstr_lsimpleconstr = Ppconstr.lsimpleconstr\n\nlet constrextern_extern_constr c =\n  let env = Global.env () in\n  Constrextern.extern_constr false env (Evd.from_env env) (EConstr.of_constr c)\n\nlet get_rel_dec_name = function\n  | Context.Rel.Declaration.LocalAssum (n, _) | Context.Rel.Declaration.LocalDef (n, _, _) -> n\n\nlet retyping_get_type_of env sigma c =\n  (* Cannot contain evars since it comes from a Constr.t *)\n  EConstr.Unsafe.to_constr (Retyping.get_type_of env sigma (EConstr.of_constr c))\n\nlet vm_conv = Vconv.vm_conv\n\n(* Cannot contain evars since it comes from a Constr.t *)\nlet cbv_vm env c t = EConstr.Unsafe.to_constr (Vnorm.cbv_vm env Evd.empty (EConstr.of_constr c) (EConstr.of_constr t))\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1160,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1160, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1161,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1161, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1162,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1162, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Entries\n\n\n(* Constr generation and manipulation *)\ntype id = Names.variable\nlet mkId = Names.Id.of_string\n\n\ntype name = Names.Name.t\nlet name_of_id i = Names.Name i\nlet mkName s =\n  let id = mkId s in\n  name_of_id id\nlet string_of_name = function\n    Names.Name id -> Names.Id.to_string id\n  | _ -> failwith \"unnamed rel\"\n\n\ntype constr = Constr.t\ntype types = Constr.types\nlet eq_constr = Constr.equal\nlet hash_constr = Constr.hash\nlet mkProp = Constr.mkProp\nlet mkConst = Constr.mkConst\nlet mkVar = Constr.mkVar\nlet mkRel = Constr.mkRel\nlet isRel = Constr.isRel\nlet destRel = Constr.destRel\nlet lift = Vars.lift\nlet mkApp = Constr.mkApp\nlet decompose_app = Constr.decompose_app\nlet mkLambda = Constr.mkLambda\nlet mkProd = Constr.mkProd\nlet mkLetIn = Constr.mkLetIn\n\nlet pr_constr_env env = Printer.pr_constr_env env Evd.empty\nlet pr_constr = pr_constr_env Environ.empty_env\n\n\nlet mkUConst : Constr.t -> Safe_typing.private_constants Entries.definition_entry = fun c ->\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, ty = Typing.type_of env evd (EConstr.of_constr c) in\n  { Entries.const_entry_body        = Future.from_val ((c, Univ.ContextSet.empty),\n                                               Safe_typing.empty_private_constants);\n    const_entry_secctx      = None;\n    const_entry_feedback    = None;\n    const_entry_type        = Some (EConstr.Unsafe.to_constr ty); (* Cannot contain evars since it comes from a Constr.t *)\n    const_entry_universes   = Evd.const_univ_entry ~poly:false evd;\n    const_entry_opaque      = false;\n    const_entry_inline_code = false }\n\nlet mkTConst c noc ty =\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, _ = Typing.type_of env evd (EConstr.of_constr noc) in\n  { const_entry_body        = Future.from_val ((c, Univ.ContextSet.empty),\n                                               Safe_typing.empty_private_constants);\n    const_entry_secctx      = None;\n    const_entry_feedback    = None;\n    const_entry_type        = Some ty;\n    const_entry_universes   = Evd.const_univ_entry ~poly:false evd;\n    const_entry_opaque      = false;\n    const_entry_inline_code = false }\n\n(* TODO : Set -> Type *)\nlet declare_new_type t =\n  let _ = ComAssumption.declare_assumption false (Decl_kinds.Discharge, false, Decl_kinds.Definitional) (Constr.mkSet, Entries.Monomorphic_const_entry Univ.ContextSet.empty) UnivNames.empty_binders [] false Declaremods.NoInline (CAst.make t) in\n  Constr.mkVar t\n\nlet declare_new_variable v constr_t =\n  let env = Global.env () in\n  let evd = Evd.from_env env in\n  let evd, _ = Typing.type_of env evd (EConstr.of_constr constr_t) in\n  let _ = ComAssumption.declare_assumption false (Decl_kinds.Discharge, false, Decl_kinds.Definitional) (constr_t, Evd.const_univ_entry ~poly:false evd) UnivNames.empty_binders [] false Declaremods.NoInline (CAst.make v) in\n  Constr.mkVar v\n\nlet declare_constant n c =\n  Declare.declare_constant n (DefinitionEntry c, Decl_kinds.IsDefinition Decl_kinds.Definition)\n\n\n\ntype cast_kind = Constr.cast_kind\nlet vmcast = Constr.VMcast\nlet mkCast = Constr.mkCast\n\n\n(* EConstr *)\ntype econstr = EConstr.t\nlet econstr_of_constr = EConstr.of_constr\n\n\n(* Modules *)\nlet gen_constant_in_modules s m n = UnivGen.constr_of_global @@ Coqlib.gen_reference_in_modules s m n\nlet gen_constant modules constant = lazy (gen_constant_in_modules \"SMT\" modules constant)\n\n\n(* Int63 *)\nlet int63_modules = [[\"SMTCoq\";\"versions\";\"standard\";\"Int63\";\"Int63Native\"]]\n\n(* 31-bits integers are \"called\" 63 bits (this is sound) *)\nlet int31_module = [[\"Coq\";\"Numbers\";\"Cyclic\";\"Int31\";\"Int31\"]]\nlet cD0 = gen_constant int31_module \"D0\"\nlet cD1 = gen_constant int31_module \"D1\"\nlet cI31 = gen_constant int31_module \"I31\"\n\nlet mkInt : int -> constr = fun i ->\n  let a = Array.make 31 (Lazy.force cD0) in\n  let j = ref i in\n  let k = ref 30 in\n  while !j <> 0 do\n    if !j land 1 = 1 then a.(!k) <- Lazy.force cD1;\n    j := !j lsr 1;\n    decr k\n  done;\n  mkApp (Lazy.force cI31, a)\n\nlet cint = gen_constant int31_module \"int31\"\n\n\n(* PArray *)\nlet parray_modules = [[\"SMTCoq\";\"versions\";\"standard\";\"Array\";\"PArray\"]]\n\nlet cmake = gen_constant parray_modules \"make\"\nlet cset = gen_constant parray_modules \"set\"\n\nlet max_array_size : int = 4194302\nlet mkArray : Constr.types * Constr.t array -> Constr.t =\n  fun (ty, a) ->\n  let l = (Array.length a) - 1 in\n  snd (Array.fold_left (fun (i,acc) c ->\n                        let acc' =\n                          if i = l then\n                            acc\n                          else\n                            mkApp (Lazy.force cset, [|ty; acc; mkInt i; c|]) in\n                        (i+1,acc')\n                       ) (0, mkApp (Lazy.force cmake, [|ty; mkInt l; a.(l)|])) a)\n\n\n(* Traces *)\n(* WARNING: side effect on r! *)\nlet mkTrace step_to_coq next _ clist cnil ccons cpair size step def_step r =\n  let rec mkTrace s =\n    if s = size then\n      mkApp (Lazy.force cnil, [|step|])\n    else (\n      r := next !r;\n      let st = step_to_coq !r in\n      mkApp (Lazy.force ccons, [|step; st; mkTrace (s+1)|])\n    ) in\n  mkApp (Lazy.force cpair, [|mkApp (Lazy.force clist, [|step|]); step; mkTrace 0; def_step|])\n\n\n(* Micromega *)\nmodule Micromega_plugin_Micromega = Micromega_plugin.Micromega\nmodule Micromega_plugin_Mutils = Mutils_full\nmodule Micromega_plugin_Certificate = Micromega_plugin.Certificate\nmodule Micromega_plugin_Coq_micromega = Coq_micromega_full\n\nlet micromega_coq_proofTerm =\n  (* Cannot contain evars *)\n  lazy (EConstr.Unsafe.to_constr (Lazy.force (Micromega_plugin_Coq_micromega.M.coq_proofTerm)))\n\nlet micromega_dump_proof_term p =\n  (* Cannot contain evars *)\n  EConstr.Unsafe.to_constr (Micromega_plugin_Coq_micromega.dump_proof_term p)\n\n\n(* Tactics *)\ntype tactic = unit Proofview.tactic\nlet tclTHEN = Tacticals.New.tclTHEN\nlet tclTHENLAST = Tacticals.New.tclTHENLAST\nlet assert_before n c = Tactics.assert_before n (EConstr.of_constr c)\n\nlet vm_cast_no_check c = Tactics.vm_cast_no_check (EConstr.of_constr c)\n\nlet mk_tactic tac =\n  Proofview.Goal.nf_enter (fun gl ->\n    let env = Proofview.Goal.env gl in\n    let sigma = Tacmach.New.project gl in\n    let t = Proofview.Goal.concl gl in\n    let t = EConstr.to_constr sigma t in (* The goal should not contain uninstanciated evars *)\n    tac env sigma t\n  )\nlet set_evars_tac noc =\n  mk_tactic (\n      fun env sigma _ ->\n      let sigma, _ = Typing.type_of env sigma (EConstr.of_constr noc) in\n      Proofview.Unsafe.tclEVARS sigma)\n\n\n(* Other differences between the two versions of Coq *)\ntype constr_expr = Constrexpr.constr_expr\nlet error s = CErrors.user_err (Pp.str s)\nlet warning n s = CWarnings.create ~name:n ~category:\"SMTCoq plugin\" Pp.str s\n\nlet extern_constr c = Constrextern.extern_constr true Environ.empty_env Evd.empty (EConstr.of_constr c)\n\nlet destruct_rel_decl r = Context.Rel.Declaration.get_name r,\n                          Context.Rel.Declaration.get_type r\n\n(* Cannot contain evars since it comes from a Constr.t *)\nlet interp_constr env sigma t = Constrintern.interp_constr env sigma t |> fst |> EConstr.Unsafe.to_constr\n\nlet ppconstr_lsimpleconstr = Ppconstr.lsimpleconstr\n\nlet constrextern_extern_constr c =\n  let env = Global.env () in\n  Constrextern.extern_constr false env (Evd.from_env env) (EConstr.of_constr c)\n\nlet get_rel_dec_name = function\n  | Context.Rel.Declaration.LocalAssum (n, _) | Context.Rel.Declaration.LocalDef (n, _, _) -> n\n\nlet retyping_get_type_of env sigma c =\n  (* Cannot contain evars since it comes from a Constr.t *)\n  EConstr.Unsafe.to_constr (Retyping.get_type_of env sigma (EConstr.of_constr c))\n\nlet vm_conv = Vconv.vm_conv\n\n(* Cannot contain evars since it comes from a Constr.t *)\nlet cbv_vm env c t = EConstr.Unsafe.to_constr (Vnorm.cbv_vm env Evd.empty (EConstr.of_constr c) (EConstr.of_constr t))\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1163,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1163, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1164,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1164, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1165,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1165, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.mli","languageId":"ocaml","version":1,"text":"(*** This file is taken from Coq-8.9.0 to solve a compilation issue due\n   to a wrong order in dependencies.\n   See https://github.com/coq/coq/issues/9768 . ***)\n\n\n(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\nmodule Micromega = Micromega_plugin.Micromega\n\nval numerator : Num.num -> Big_int.big_int\nval denominator : Num.num -> Big_int.big_int\n\nmodule Cmp : sig\n\n  val compare_list : ('a -> 'b -> int) -> 'a list -> 'b list -> int\n  val compare_lexical : (unit -> int) list -> int\n\nend\n\nmodule Tag : sig\n\n  type t\n\n  val pp : out_channel -> t -> unit\n  val next : t -> t\n  val from : int -> t\n\nend\n\nmodule TagSet : CSig.SetS with type elt = Tag.t\n\nval pp_list : (out_channel -> 'a -> unit) -> out_channel -> 'a list -> unit\n\nmodule CamlToCoq : sig\n\n  val positive : int -> Micromega.positive\n  val bigint : Big_int.big_int -> Micromega.z\n  val n : int -> Micromega.n\n  val nat : int -> Micromega.nat\n  val q : Num.num -> Micromega.q\n  val index : int -> Micromega.positive\n  val z : int -> Micromega.z\n  val positive_big_int : Big_int.big_int -> Micromega.positive\n\nend\n\nmodule CoqToCaml : sig\n\n  val z_big_int : Micromega.z -> Big_int.big_int\n  val q_to_num : Micromega.q -> Num.num\n  val positive : Micromega.positive -> int\n  val n : Micromega.n -> int\n  val nat : Micromega.nat -> int\n  val index : Micromega.positive -> int\n\nend\n\nval rats_to_ints : Num.num list -> Big_int.big_int list\n\nval all_pairs : ('a -> 'a -> 'b) -> 'a list -> 'b list\nval all_sym_pairs : ('a -> 'a -> 'b) -> 'a list -> 'b list\nval try_any : (('a -> 'b option) * 'c) list -> 'a -> 'b option\nval is_sublist : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool\n\nval gcd_list : Num.num list -> Big_int.big_int\n\nval extract : ('a -> 'b option) -> 'a list -> ('b * 'a) option * 'a list\n\nval command : string -> string array -> 'a -> 'b\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1166,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1166, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1167,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1167, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1168,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1168, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml","languageId":"ocaml","version":1,"text":"(*** This file is taken from Coq-8.9.0 to solve a compilation issue due\n   to a wrong order in dependencies.\n   See https://github.com/coq/coq/issues/9768 . ***)\n\n\n(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n(*                                                                      *)\n(* Micromega: A reflexive tactic using the Positivstellensatz           *)\n(*                                                                      *)\n(* ** Utility functions **                                              *)\n(*                                                                      *)\n(* - Modules CoqToCaml, CamlToCoq                                       *)\n(* - Modules Cmp, Tag, TagSet                                           *)\n(*                                                                      *)\n(*  Frdric Besson (Irisa/Inria) 2006-2008                             *)\n(*                                                                      *)\n(************************************************************************)\n\nmodule Micromega = Micromega_plugin.Micromega\n\nlet rec pp_list f o l =\n  match l with\n    | [] -> ()\n    | e::l -> f o e ; output_string o \";\" ; pp_list f o l\n\n\nlet finally f rst =\n  try\n    let res = f () in\n      rst () ; res\n  with reraise ->\n    (try rst ()\n    with any -> raise reraise\n    ); raise reraise\n\nlet rec try_any l x =\n match l with\n  | [] -> None\n  | (f,s)::l -> match f x with\n     | None -> try_any l x\n     | x -> x\n\nlet all_sym_pairs f l = \n  let pair_with acc e l = List.fold_left (fun acc x -> (f e x) ::acc) acc l in\n\n  let rec xpairs acc l = \n    match l with\n      | [] -> acc\n      | e::l -> xpairs (pair_with acc e l) l in\n    xpairs [] l\n\nlet all_pairs f l = \n  let pair_with acc e l = List.fold_left (fun acc x -> (f e x) ::acc) acc l in\n\n  let rec xpairs acc l = \n    match l with\n      | [] -> acc\n      | e::lx -> xpairs (pair_with acc e l) lx in\n    xpairs [] l\n\nlet rec is_sublist f l1 l2 =\n  match l1 ,l2 with\n    | [] ,_ -> true\n    | e::l1', [] -> false\n    | e::l1' , e'::l2' ->\n\tif f e e' then is_sublist f l1' l2'\n\telse is_sublist f l1 l2'\n\nlet extract pred l = \n  List.fold_left (fun (fd,sys) e -> \n\t\t    match fd with\n\t\t    | None -> \n\t\t\tbegin\n\t\t\t  match pred e with\n\t\t\t  | None -> fd, e::sys\n\t\t\t  | Some v -> Some(v,e) , sys\n\t\t\tend\n\t\t    |  _   -> (fd, e::sys)\n\t\t ) (None,[]) l\n\nopen Num\nopen Big_int\n\nlet ppcm x y =\n let g = gcd_big_int x y in\n let x' = div_big_int x g in\n let y' = div_big_int y g in\n  mult_big_int g (mult_big_int x' y')\n\nlet denominator = function\n | Int _ | Big_int _ -> unit_big_int\n | Ratio r -> Ratio.denominator_ratio r\n\nlet numerator = function\n | Ratio r -> Ratio.numerator_ratio r\n | Int i -> Big_int.big_int_of_int i\n | Big_int i -> i\n\nlet rec ppcm_list c l =\n match l with\n  | [] -> c\n  | e::l -> ppcm_list (ppcm c (denominator e)) l\n\nlet rec rec_gcd_list c l  =\n match l with\n  | [] -> c\n  | e::l -> rec_gcd_list (gcd_big_int  c (numerator e)) l\n\nlet gcd_list l =\n let res = rec_gcd_list zero_big_int l in\n  if Int.equal (compare_big_int res zero_big_int) 0\n  then unit_big_int else res\n\nlet rats_to_ints l =\n let c = ppcm_list unit_big_int l in\n  List.map (fun x ->  (div_big_int (mult_big_int (numerator x) c)\n\t\t\t(denominator x))) l\n\n(* assoc_pos j [a0...an] = [j,a0....an,j+n],j+n+1 *)\n(**\n  * MODULE: Coq to Caml data-structure mappings\n  *)\n\nmodule CoqToCaml =\nstruct\n open Micromega\n\n let rec nat = function\n  | O -> 0\n  | S n -> (nat n) + 1\n\n\n let rec positive p =\n  match p with\n   | XH -> 1\n   | XI p -> 1+ 2*(positive p)\n   | XO p -> 2*(positive p)\n\n let n nt =\n  match nt with\n   | N0 -> 0\n   | Npos p -> positive p\n\n let rec index i = (* Swap left-right ? *)\n  match i with\n   | XH -> 1\n   | XI i -> 1+(2*(index i))\n   | XO i -> 2*(index i)\n\n open Big_int\n\n let rec positive_big_int p =\n  match p with\n   | XH -> unit_big_int\n   | XI p -> add_int_big_int 1 (mult_int_big_int 2 (positive_big_int p))\n   | XO p -> (mult_int_big_int 2 (positive_big_int p))\n\n let z_big_int x =\n  match x with\n   | Z0 -> zero_big_int\n   | Zpos p -> (positive_big_int p)\n   | Zneg p -> minus_big_int (positive_big_int p)\n\n let q_to_num {qnum = x ; qden = y} =\n  Big_int (z_big_int x) // (Big_int (z_big_int (Zpos y)))\n\nend\n\n\n(**\n  * MODULE: Caml to Coq data-structure mappings\n  *)\n\nmodule CamlToCoq =\nstruct\n open Micromega\n\n let rec nat = function\n  | 0 -> O\n  | n -> S (nat (n-1))\n\n\n let rec positive n =\n  if Int.equal n 1 then XH\n  else if Int.equal (n land 1) 1 then XI (positive (n lsr 1))\n  else  XO (positive (n lsr 1))\n\n let n nt =\n  if nt < 0\n  then assert false\n  else if Int.equal nt 0 then N0\n  else Npos (positive nt)\n\n let rec index  n =\n  if Int.equal n 1 then XH\n  else if Int.equal (n land 1) 1 then XI (index (n lsr 1))\n  else  XO (index (n lsr 1))\n\n\n let z x =\n  match compare x 0 with\n   | 0 -> Z0\n   | 1 -> Zpos (positive x)\n   | _ -> (* this should be -1 *)\n      Zneg (positive (-x))\n\n open Big_int\n\n let positive_big_int n =\n  let two = big_int_of_int 2 in\n  let rec _pos n =\n   if eq_big_int n unit_big_int then XH\n   else\n    let (q,m) = quomod_big_int n two  in\n     if eq_big_int unit_big_int m\n     then XI (_pos q)\n     else XO (_pos q) in\n   _pos n\n\n let bigint x =\n  match sign_big_int x with\n   | 0 -> Z0\n   | 1 -> Zpos (positive_big_int x)\n   | _ -> Zneg (positive_big_int (minus_big_int x))\n\n let q n =\n  {Micromega.qnum = bigint (numerator n) ;\n   Micromega.qden = positive_big_int (denominator n)}\n\nend\n\n(**\n  * MODULE: Comparisons on lists: by evaluating the elements in a single list,\n  * between two lists given an ordering, and using a hash computation\n  *)\n\nmodule Cmp =\nstruct\n\n let rec compare_lexical l =\n  match l with\n   | [] -> 0 (* Equal *)\n   | f::l ->\n      let cmp = f () in\n       if Int.equal cmp 0 then compare_lexical l else cmp\n\n let rec compare_list cmp l1 l2 =\n  match l1 , l2 with\n   | []  , [] -> 0\n   | []  , _  -> -1\n   | _   , [] -> 1\n   | e1::l1 , e2::l2 ->\n      let c = cmp e1 e2 in\n       if Int.equal c 0 then compare_list cmp l1 l2 else c\n\nend\n\n(**\n  * MODULE: Labels for atoms in propositional formulas. \n  * Tags are used to identify unused atoms in CNFs, and propagate them back to\n  * the original formula. The translation back to Coq then ignores these\n  * superfluous items, which speeds the translation up a bit.\n  *)\n\nmodule type Tag =\nsig\n\n  type t\n\n  val from : int -> t\n  val next : t -> t\n  val pp : out_channel -> t -> unit\n  val compare : t -> t -> int\n\nend\n\nmodule Tag : Tag =\nstruct\n\n  type t = int\n\n  let from i = i\n  let next i = i + 1\n  let pp o i = output_string o (string_of_int i)\n  let compare : int -> int -> int = Int.compare\n\nend\n\n(**\n  * MODULE: Ordered sets of tags.\n  *)\n\nmodule TagSet = Set.Make(Tag)\n\n(** As for Unix.close_process, our Unix.waipid will ignore all EINTR *)\n\nlet rec waitpid_non_intr pid =\n  try snd (Unix.waitpid [] pid)\n  with Unix.Unix_error (Unix.EINTR, _, _) -> waitpid_non_intr pid\n\n(**\n  * Forking routine, plumbing the appropriate pipes where needed.\n  *)\n\nlet command exe_path args vl =\n  (* creating pipes for stdin, stdout, stderr *)\n  let (stdin_read,stdin_write) = Unix.pipe ()\n  and (stdout_read,stdout_write) = Unix.pipe ()\n  and (stderr_read,stderr_write) = Unix.pipe () in\n\n  (* Create the process *)\n  let pid = Unix.create_process exe_path args stdin_read stdout_write stderr_write in\n\n  (* Write the data on the stdin of the created process *)\n  let outch = Unix.out_channel_of_descr stdin_write in\n    output_value outch vl ;\n    flush outch ;\n\n  (* Wait for its completion *)\n    let status = waitpid_non_intr pid in\n\n      finally\n        (* Recover the result *)\n\t(fun () ->\n\t  match status with\n\t    | Unix.WEXITED 0 ->\n\t\tlet inch = Unix.in_channel_of_descr stdout_read in\n\t\tbegin\n                  try Marshal.from_channel inch\n                  with any ->\n                    failwith\n                      (Printf.sprintf \"command \\\"%s\\\" exited %s\" exe_path\n                         (Printexc.to_string any))\n                end\n\t    | Unix.WEXITED i   ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" exited %i\" exe_path i)\n\t    | Unix.WSIGNALED i ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" killed %i\" exe_path i)\n\t    | Unix.WSTOPPED i  ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" stopped %i\" exe_path i))\n        (* Cleanup  *)\n\t(fun () ->\n\t  List.iter (fun x -> try Unix.close x with any -> ())\n            [stdin_read; stdin_write;\n             stdout_read; stdout_write;\n             stderr_read; stderr_write])\n\n(* Local Variables: *)\n(* coding: utf-8 *)\n(* End: *)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1169,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1169, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1170,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1170, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1171,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1171, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1172,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"},"range":{"start":{"line":11,"character":51},"end":{"line":11,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.48303604126ms
Sending response {"id": 1172, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1172}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1173,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1173, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1174,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00286102294922ms
Sending response {"id": 1174, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1175,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1175, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1176,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":12,"character":12},"end":{"line":12,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1176, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1177,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1177, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1178,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":16,"character":19},"end":{"line":16,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1178, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1179,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":60,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1179, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1180,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 2.06208229065ms
Sending response {"id": 1180, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","languageId":"ocaml","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1181,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1181, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1182,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 1182, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","version":2},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1183,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 1183, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1184,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1184, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","version":2},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli","version":2}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1185,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1185, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1186,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":23,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 1186, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
Read message 
{"jsonrpc":"2.0","id":1187,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.046968460083ms
Sending response {"id": 1187, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1188,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1188, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1189,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 1189, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1190,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1190, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1191,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1191, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1192,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1192, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1193,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":18,"character":16},"end":{"line":18,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1193, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1193}}
Read message 
{"jsonrpc":"2.0","id":1194,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 1194, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1195,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1195, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1196,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 1196, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1197,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":44,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Sending response {"id": 1197, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1198,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1198, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1199,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1199, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1200,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1200, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1201,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1201, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1202,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 1202, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1203,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 1203, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1204,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Lexer.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1204, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1205,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.06103515625ms
Sending response {"id": 1205, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1206,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0579357147217ms
Sending response {"id": 1206, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1207,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1207, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1208,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.02121925354ms
Sending response {"id": 1208, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1209,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":32,"character":21},"end":{"line":32,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 1209, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1210,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":23,"character":38}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 1210, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1211,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":23,"character":40},"end":{"line":23,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 1211, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1212,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.018835067749ms
Sending response {"id": 1212, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1213,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":28,"character":34}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 1213, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1214,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"position":{"line":28,"character":34}}}
[server] Got a method textDocument/definition
[server] processing took 0.0128746032715ms
Sending response {"id": 1214, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1215,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":28,"character":34},"end":{"line":28,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1215, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n(* WARNING: currently, we map all the econstr into constr: we suppose\n   that the goal does not contain existencial variables *)\n\n(* Constr generation and manipulation *)\ntype id = Names.variable\nval mkId : string -> id\n\ntype name\nval name_of_id : id -> name\nval mkName : string -> name\nval string_of_name : name -> string\n\ntype constr = Constr.t\ntype types = constr\nval eq_constr : constr -> constr -> bool\nval hash_constr : constr -> int\nval mkProp : types\nval mkConst : Names.Constant.t -> constr\nval mkVar : id -> constr\nval mkRel : int -> constr\nval isRel : constr -> bool\nval destRel : constr -> int\nval lift : int -> constr -> constr\nval mkApp : constr * constr array -> constr\nval decompose_app : constr -> constr * constr list\nval mkLambda : name * types * constr -> constr\nval mkProd : name * types * types -> types\nval mkLetIn : name * constr * types * constr -> constr\n\nval pr_constr_env : Environ.env -> constr -> Pp.t\nval pr_constr : constr -> Pp.t\n\nval mkUConst : constr -> Safe_typing.private_constants Entries.definition_entry\nval mkTConst : constr -> constr -> types -> Safe_typing.private_constants Entries.definition_entry\nval declare_new_type : id -> types\nval declare_new_variable : id -> types -> constr\nval declare_constant : id -> Safe_typing.private_constants Entries.definition_entry -> Names.Constant.t\n\ntype cast_kind\nval vmcast : cast_kind\nval mkCast : constr * cast_kind * constr -> constr\n\n\n(* EConstr *)\ntype econstr = EConstr.t\nval econstr_of_constr : constr -> econstr\n\n\n(* Modules *)\nval gen_constant : string list list -> string -> constr lazy_t\n\n\n(* Int63 *)\nval int63_modules : string list list\nval mkInt : int -> constr\nval cint : constr lazy_t\n\n\n(* PArray *)\nval parray_modules : string list list\nval max_array_size : int\nval mkArray : types * constr array -> constr\n\n\n(* Traces *)\nval mkTrace :\n  ('a -> constr) ->\n  ('a -> 'a) ->\n  'b ->\n  constr Lazy.t ->\n  constr Lazy.t ->\n  constr Lazy.t ->\n  constr Lazy.t ->\n  int -> constr -> constr -> 'a ref -> constr\n\n\n(* Micromega *)\nmodule Micromega_plugin_Micromega = Micromega_plugin.Micromega\nmodule Micromega_plugin_Mutils = Mutils_full\nmodule Micromega_plugin_Certificate = Micromega_plugin.Certificate\nmodule Micromega_plugin_Coq_micromega = Coq_micromega_full\n\nval micromega_coq_proofTerm : constr lazy_t\nval micromega_dump_proof_term : Micromega_plugin_Micromega.zArithProof -> constr\n\n\n(* Tactics *)\ntype tactic = unit Proofview.tactic\nval tclTHEN : tactic -> tactic -> tactic\nval tclTHENLAST : tactic -> tactic -> tactic\nval assert_before : name -> types -> tactic\nval vm_cast_no_check : constr -> tactic\nval mk_tactic : (Environ.env -> Evd.evar_map -> constr -> tactic) -> tactic\nval set_evars_tac : constr -> tactic\n\n\n(* Other differences between the two versions of Coq *)\ntype constr_expr = Constrexpr.constr_expr\nval error : string -> 'a\nval warning : string -> string -> unit\nval extern_constr : constr -> constr_expr\nval destruct_rel_decl : (constr, types) Context.Rel.Declaration.pt -> name * types\nval interp_constr : Environ.env -> Evd.evar_map -> constr_expr -> constr\nval ppconstr_lsimpleconstr : Notation_gram.tolerability\nval constrextern_extern_constr : constr -> constr_expr\nval get_rel_dec_name : (constr, types) Context.Rel.Declaration.pt -> name\nval retyping_get_type_of : Environ.env -> Evd.evar_map -> constr -> constr\n\nval vm_conv : Reduction.conv_pb -> types Reduction.kernel_conversion_function\nval cbv_vm : Environ.env -> constr -> types -> constr\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1216,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1216, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1217,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1217, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1218,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1218, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/structures.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\ntype solver = Zchaff | Verit\n\n\nlet usage =\n\"\nUsage: smtcoq [solver] problem trace\nSolver:\n  -zchaff   Uses the verifier for ZChaff (default); the problem must be a dimacs file, and the trace, ZChaff unsatisfiability trace\n  -verit    Uses the verifier for ZChaff; the problem must be a SMTLIB2 file, and the trace, veriT unsatisfiability trace\n\n\"\n\n\nlet string_of_solver = function\n  | Zchaff -> \"ZChaff\"\n  | Verit -> \"veriT\"\n\n\nlet verifier_of_solver = function\n  | Zchaff -> Zchaff_checker.checker\n  | Verit -> Verit_checker.checker\n\n\nlet run s pb trace =\n  Printf.printf \"Calling the %s verifier on %s and %s...\\n\" (string_of_solver s) pb trace;\n  let v = verifier_of_solver s in\n  try\n    let t1 = Unix.time () in \n    let res = v pb trace in\n    let t2 = Unix.time () in\n    if res then\n      Printf.printf \"The trace was correctly verified in %fs\\n\" (t2 -. t1)\n    else\n      failwith \"Error\"\n  with | _ -> Printf.printf \"The verifier failed to check the trace :-(\\n\"\n\n\n\nlet _ =\n  let (s,pb,trace) =\n    try\n      let s = if Sys.argv.(1) = \"-verit\" then Verit else Zchaff in\n      let pb = Sys.argv.((Array.length Sys.argv)-2) in\n      let trace = Sys.argv.((Array.length Sys.argv)-1) in\n      (s,pb,trace)\n    with\n      | _ -> Printf.printf \"%s\" usage; exit 0 in\n  run s pb trace\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1219,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1219, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1220,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 1220, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1221,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1221, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1222,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml"},"range":{"start":{"line":20,"character":3},"end":{"line":20,"character":121}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1222, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1223,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml"},"range":{"start":{"line":27,"character":4},"end":{"line":27,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 1223, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1224,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.ml"},"range":{"start":{"line":32,"character":4},"end":{"line":32,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 1224, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\ntype solver = Zchaff | Verit\nval usage : string\nval string_of_solver : solver -> string\nval verifier_of_solver : solver -> string -> string -> bool\nval run : solver -> string -> string -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1225,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1225, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1226,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1226, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1227,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 1227, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1228,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.mli"},"range":{"start":{"line":12,"character":23},"end":{"line":12,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1228, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/smtcoq.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen SmtCertif\nopen SmtCommands\nopen SmtForm\nopen SmtAtom\nopen SmtTrace\nopen Verit\nopen Smtlib2_ast\nopen Smtlib2_genConstr\n(* open Smt_checker *)\n\n\nmodule Mc = Structures.Micromega_plugin_Certificate.Mc\n\n\nlet mkInt = ExtrNative.of_int\nlet mkArray = ExtrNative.of_array\n\n\nlet rec dump_nat x =\n  match x with\n    | Mc.O -> Smt_checker.O\n    | Mc.S p -> Smt_checker.S (dump_nat p)\n\n\nlet rec dump_positive x =\n  match x with\n    | Mc.XH -> Smt_checker.XH\n    | Mc.XO p -> Smt_checker.XO (dump_positive p)\n    | Mc.XI p -> Smt_checker.XI (dump_positive p)\n\n\nlet dump_z x =\n  match x with\n    | Mc.Z0 -> Smt_checker.Z0\n    | Mc.Zpos p -> Smt_checker.Zpos (dump_positive p)\n    | Mc.Zneg p -> Smt_checker.Zneg (dump_positive p)\n\n\nlet dump_pol e =\n  let rec dump_pol e =\n    match e with\n      | Mc.Pc n -> Smt_checker.Pc (dump_z n)\n      | Mc.Pinj(p,pol) -> Smt_checker.Pinj (dump_positive p, dump_pol pol)\n      | Mc.PX(pol1,p,pol2) -> Smt_checker.PX (dump_pol pol1, dump_positive p, dump_pol pol2) in\n  dump_pol e\n\n\nlet dump_psatz e =\n  let rec dump_cone e =\n    match e with\n      | Mc.PsatzIn n -> Smt_checker.PsatzIn (dump_nat n)\n      | Mc.PsatzMulC(e,c) -> Smt_checker.PsatzMulC (dump_pol e, dump_cone c)\n      | Mc.PsatzSquare e -> Smt_checker.PsatzSquare (dump_pol e)\n      | Mc.PsatzAdd(e1,e2) -> Smt_checker.PsatzAdd (dump_cone e1, dump_cone e2)\n      | Mc.PsatzMulE(e1,e2) -> Smt_checker.PsatzMulE (dump_cone e1, dump_cone e2)\n      | Mc.PsatzC p -> Smt_checker.PsatzC (dump_z p)\n      | Mc.PsatzZ -> Smt_checker.PsatzZ in\n  dump_cone e\n\n\nlet rec dump_list dump_elt l =\n  match l with\n    | [] -> Smt_checker.Nil\n    | e :: l -> Smt_checker.Cons (dump_elt e, dump_list dump_elt l)\n\n\nlet rec dump_proof_term = function\n  | Micromega.DoneProof -> Smt_checker.DoneProof\n  | Micromega.RatProof(cone,rst) ->\n    Smt_checker.RatProof (dump_psatz cone, dump_proof_term rst)\n  | Micromega.CutProof(cone,prf) ->\n    Smt_checker.CutProof (dump_psatz cone, dump_proof_term prf)\n  | Micromega.EnumProof(c1,c2,prfs) ->\n    Smt_checker.EnumProof (dump_psatz c1, dump_psatz c2, dump_list dump_proof_term prfs)\n\n\n\nlet to_coq to_lit confl =\n  let out_f f = to_lit f in\n  let out_c c = mkInt (get_pos c) in\n  let step_to_coq c =\n    match c.kind with\n    | Res res ->\n\tlet size = List.length res.rtail + 3 in\n\tlet args = Array.make size (mkInt 0) in\n\targs.(0) <- mkInt (get_pos res.rc1);\n\targs.(1) <- mkInt (get_pos res.rc2);\n\tlet l = ref res.rtail in\n\tfor i = 2 to size - 2 do\n\t  match !l with\n\t  | c::tl ->\n\t      args.(i) <- mkInt (get_pos c);\n\t      l := tl\n\t  | _ -> assert false\n\tdone;\n\tSmt_checker.Euf_Checker.Res (mkInt (get_pos c), mkArray args)\n    | Other other ->\n\tbegin match other with\n\t| ImmFlatten (c',f) -> Smt_checker.Euf_Checker.ImmFlatten (out_c c, out_c c', out_f f)\n        | True -> Smt_checker.Euf_Checker.CTrue (out_c c)\n\t| False -> Smt_checker.Euf_Checker.CFalse (out_c c)\n\t| BuildDef f -> Smt_checker.Euf_Checker.BuildDef (out_c c, out_f f)\n\t| BuildDef2 f -> Smt_checker.Euf_Checker.BuildDef2 (out_c c, out_f f)\n\t| BuildProj (f, i) -> Smt_checker.Euf_Checker.BuildProj (out_c c, out_f f, mkInt i)\n\t| ImmBuildDef c' -> Smt_checker.Euf_Checker.ImmBuildDef (out_c c, out_c c')\n\t| ImmBuildDef2 c' -> Smt_checker.Euf_Checker.ImmBuildDef2 (out_c c, out_c c')\n\t| ImmBuildProj(c', i) -> Smt_checker.Euf_Checker.ImmBuildProj (out_c c, out_c c',mkInt i)\n        | EqTr (f, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons (out_f f, l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqTr (out_c c, out_f f, res)\n        | EqCgr (f, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons ((match f with | Some f -> Smt_checker.Some (out_f f) | None -> Smt_checker.None), l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqCgr (out_c c, out_f f, res)\n        | EqCgrP (f1, f2, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons ((match f with | Some f -> Smt_checker.Some (out_f f) | None -> Smt_checker.None), l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqCgrP (out_c c, out_f f1, out_f f2, res)\n\t| LiaMicromega (cl,d) ->\n          let cl' = List.fold_right (fun f l -> Smt_checker.Cons (out_f f, l)) cl Smt_checker.Nil in\n          let c' = List.fold_right (fun f l -> Smt_checker.Cons (dump_proof_term f, l)) d Smt_checker.Nil in\n          Smt_checker.Euf_Checker.LiaMicromega (out_c c, cl', c')\n        | LiaDiseq l -> Smt_checker.Euf_Checker.LiaDiseq (out_c c, out_f l)\n        | SplArith (orig,res,l) ->\n          let res' = out_f res in\n          let l' = List.fold_right (fun f l -> Smt_checker.Cons (dump_proof_term f, l)) l Smt_checker.Nil in\n          Smt_checker.Euf_Checker.SplArith (out_c c, out_c orig, res', l')\n\t| SplDistinctElim (c',f) -> Smt_checker.Euf_Checker.SplDistinctElim (out_c c, out_c c', out_f f)\n\tend\n    | _ -> assert false in\n  let def_step =\n    Smt_checker.Euf_Checker.Res (mkInt 0, mkArray [|mkInt 0|]) in\n  let r = ref confl in\n  let nc = ref 0 in\n  while not (isRoot !r.kind) do r := prev !r; incr nc done;\n  let last_root = !r in\n  let size = !nc in\n  let max = (Parray.trunc_size (Uint63.of_int 4194303)) - 1 in\n  let q,r1 = size / max, size mod max in\n\n  let trace =\n    let len = if r1 = 0 then q + 1 else q + 2 in\n    Array.make len (mkArray [|def_step|]) in\n  for j = 0 to q - 1 do\n    let tracej = Array.make (Parray.trunc_size (Uint63.of_int 4194303)) def_step in\n    for i = 0 to max - 1 do\n      r := next !r;\n      tracej.(i) <- step_to_coq !r;\n    done;\n    trace.(j) <- mkArray tracej\n  done;\n  if r1 <> 0 then begin\n    let traceq = Array.make (r1 + 1) def_step in\n    for i = 0 to r1-1 do\n    r := next !r;\n    traceq.(i) <- step_to_coq !r;\n    done;\n    trace.(q) <- mkArray traceq\n  end;\n\n  (mkArray trace, last_root)\n\n\nlet btype_to_coq = function\n  | TZ ->        Smt_checker.Typ.TZ\n  | Tbool ->     Smt_checker.Typ.Tbool\n  | Tpositive -> Smt_checker.Typ.Tpositive\n  | Tindex i ->  Smt_checker.Typ.Tindex (mkInt (SmtAtom.indexed_type_index i))\n\n\nlet c_to_coq = function\n  | CO_xH -> Smt_checker.Atom.CO_xH\n  | CO_Z0 -> Smt_checker.Atom.CO_Z0\n\n\nlet u_to_coq = function\n  | UO_xO ->   Smt_checker.Atom.UO_xO\n  | UO_xI ->   Smt_checker.Atom.UO_xI\n  | UO_Zpos -> Smt_checker.Atom.UO_Zpos\n  | UO_Zneg -> Smt_checker.Atom.UO_Zneg\n  | UO_Zopp -> Smt_checker.Atom.UO_Zopp\n\n\nlet b_to_coq = function\n  | BO_Zplus ->  Smt_checker.Atom.BO_Zplus\n  | BO_Zminus -> Smt_checker.Atom.BO_Zminus\n  | BO_Zmult ->  Smt_checker.Atom.BO_Zmult\n  | BO_Zlt ->    Smt_checker.Atom.BO_Zlt\n  | BO_Zle ->    Smt_checker.Atom.BO_Zle\n  | BO_Zge ->    Smt_checker.Atom.BO_Zge\n  | BO_Zgt ->    Smt_checker.Atom.BO_Zgt\n  | BO_eq t ->   Smt_checker.Atom.BO_eq (btype_to_coq t)\n\n\nlet n_to_coq = function\n  | NO_distinct t -> btype_to_coq t\n\n\nlet i_to_coq i = mkInt (SmtAtom.indexed_op_index i)\n\n\nlet a_to_coq a =\n  let to_coq h = mkInt (Atom.index h) in\n  match a with\n    | Acop op -> Smt_checker.Atom.Acop (c_to_coq op)\n    | Auop (op,h) -> Smt_checker.Atom.Auop (u_to_coq op, to_coq h)\n    | Abop (op,h1,h2) ->\n      Smt_checker.Atom.Abop (b_to_coq op, to_coq h1, to_coq h2)\n    | Anop (op,ha) ->\n      let cop = n_to_coq op in\n      let cargs = Array.fold_right (fun h l -> Smt_checker.Cons (to_coq h, l)) ha Smt_checker.Nil in\n      Smt_checker.Atom.Anop (cop, cargs)\n    | Aapp (op,args) ->\n      let cop = i_to_coq op in\n      let cargs = Array.fold_right (fun h l -> Smt_checker.Cons (to_coq h, l)) args Smt_checker.Nil in\n      Smt_checker.Atom.Aapp (cop, cargs)\n\n\nlet atom_interp_tbl reify =\n  let t = Atom.to_array reify (Smt_checker.Atom.Acop Smt_checker.Atom.CO_xH) a_to_coq in\n  mkArray t\n\n\nlet form_to_coq hf = mkInt (Form.to_lit hf)\n\nlet args_to_coq args =\n  let cargs = Array.make (Array.length args + 1) (mkInt 0) in\n  Array.iteri (fun i hf -> cargs.(i) <- form_to_coq hf) args;\n  mkArray cargs\n\nlet pf_to_coq = function\n  | Fatom a -> Smt_checker.Form.Fatom (mkInt (Atom.index a))\n  | Fapp(op,args) ->\n    match op with\n      | Ftrue -> Smt_checker.Form.Ftrue\n      | Ffalse -> Smt_checker.Form.Ffalse\n      | Fand -> Smt_checker.Form.Fand (args_to_coq args)\n      | For  -> Smt_checker.Form.For (args_to_coq args)\n      | Fimp -> Smt_checker.Form.Fimp (args_to_coq args)\n      | Fxor -> if Array.length args = 2 then Smt_checker.Form.Fxor (form_to_coq args.(0), form_to_coq args.(1)) else assert false\n      | Fiff -> if Array.length args = 2 then Smt_checker.Form.Fiff (form_to_coq args.(0), form_to_coq args.(1)) else assert false\n      | Fite -> if Array.length args = 3 then Smt_checker.Form.Fite (form_to_coq args.(0), form_to_coq args.(1), form_to_coq args.(2)) else assert false\n      | Fnot2 i -> Smt_checker.Form.Fnot2 (mkInt i, form_to_coq args.(0))\n\n\nlet form_interp_tbl reify =\n  let (_,t) = Form.to_array reify Smt_checker.Form.Ftrue pf_to_coq in\n  mkArray t\n\n\n(* Importing from SMT-LIB v.2 without generating section variables *)\n\nlet count_btype = ref 0\nlet count_op = ref 0\n\n\nlet declare_sort sym =\n  let s = string_of_symbol sym in\n  let res = Tindex (dummy_indexed_type !count_btype) in\n  incr count_btype;\n  VeritSyntax.add_btype s res;\n  res\n\n\nlet declare_fun sym arg cod =\n  let s = string_of_symbol sym in\n  let tyl = List.map sort_of_sort arg in\n  let ty = sort_of_sort cod in\n  let op = dummy_indexed_op !count_op (Array.of_list (List.map fst tyl)) (fst ty) in\n  incr count_op;\n  VeritSyntax.add_fun s op;\n  op\n\n\nlet declare_commands ra rf acc = function\n  | CDeclareSort (_,sym,_) -> let _ = declare_sort sym in acc\n  | CDeclareFun (_,sym, (_, arg), cod) -> let _ = declare_fun sym arg cod in acc\n  | CAssert (_, t) -> (make_root ra rf t)::acc\n  | _ -> acc\n\n\nlet import_smtlib2 ra rf filename =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let commands = Smtlib2_parse.main Smtlib2_lex.token lexbuf in\n  close_in chan;\n  match commands with\n    | None -> []\n    | Some (Smtlib2_ast.Commands (_,(_,res))) ->\n      List.rev (List.fold_left (declare_commands ra rf) [] res)\n\n\n(* The final checker *)\n\nlet this_clear_all () =\n  Verit.clear_all ();\n  count_btype := 0;\n  count_op := 0\n\n\nlet checker fsmt fproof =\n  this_clear_all ();\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let roots = import_smtlib2 ra rf fsmt in\n  let (max_id, confl) = import_trace fproof None in\n  let (tres,last_root) = to_coq (fun i -> mkInt (SmtAtom.Form.to_lit i)) confl in\n  let certif =\n    Smt_checker.Euf_Checker.Certif (mkInt (max_id + 1), tres, mkInt (get_pos confl)) in\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    Smt_checker.Some (mkArray res) in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (SmtAtom.Form.to_lit j); incr i) roots;\n    mkArray res in\n\n  let t_atom = atom_interp_tbl ra in\n  let t_form = form_interp_tbl rf in\n\n  Smt_checker.Euf_Checker.checker_ext t_atom t_form rootsCstr used_rootsCstr certif\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1229,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1229, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1230,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1230, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1231,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1231, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1232,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":306,"character":2},"end":{"line":306,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1232, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Format\n\nopen SmtMisc\nopen CoqTerms\nopen SmtCertif\nopen SmtTrace\nopen SmtAtom\n\n\n(******************************************************************************)\n(* Given a lfsc trace build the corresponding certif and theorem             *)\n(******************************************************************************)\n\n(* Instantiate Converter with translator for SMTCoq *)\nmodule C = Converter.Make (Tosmtcoq)\n\nexception No_proof\n\n(* Hard coded signatures *)\nlet signatures =\n  let sigdir = try Sys.getenv \"LFSCSIGS\" with Not_found -> Sys.getcwd () in\n  [\"sat.plf\";\n   \"smt.plf\";\n   \"th_base.plf\";\n   \"th_int.plf\";\n   \"th_bv.plf\";\n   \"th_bv_bitblast.plf\";\n   \"th_bv_rewrites.plf\";\n   \"th_arrays.plf\" ]\n  |> List.map (Filename.concat sigdir)\n\n\nlet process_signatures_once =\n  let don = ref false in\n  fun () ->\n    if !don then ()\n    else\n      try\n        (* don := true; *)\n        List.iter (fun f ->\n            let chan = open_in f in\n            let lexbuf = Lexing.from_channel chan in\n            LfscParser.ignore_commands LfscLexer.main lexbuf;\n            close_in chan\n          ) signatures\n      with\n      | Ast.TypingError (t1, t2) ->\n        Structures.error\n          (asprintf \"@[<hov>LFSC typing error: expected %a, got %a@]@.\"\n             Ast.print_term t1\n             Ast.print_term t2)\n\n\nlet lfsc_parse_last lb =\n  printf \"Type-checking LFSC proof...@?\";\n  let t0 = Sys.time () in\n  let r = LfscParser.last_command LfscLexer.main lb in\n  let t1 = Sys.time () in\n  printf \" Done [%.3f s]@.\" (t1 -. t0);\n  r\n\nlet lfsc_parse_one lb =\n  printf \"Type-checking LFSC proof...@?\";\n  let t0 = Sys.time () in\n  let r = LfscParser.one_command LfscLexer.main lb in\n  let t1 = Sys.time () in\n  printf \" Done [%.3f s]@.\" (t1 -. t0);\n  r\n  \n\nlet import_trace first parse lexbuf =\n  Printexc.record_backtrace true;\n  process_signatures_once ();\n  try\n    match parse lexbuf with\n\n    | Some (Ast.Check p) ->\n      (* Ast.flatten_term p; *)\n      let confl_num = C.convert_pt p in\n      (* Afterwards, the SMTCoq libraries will produce the remaining, you do\n         not have to care *)\n      let first =\n        let aux = VeritSyntax.get_clause 1 in\n        match first, aux.value with\n        | Some (root,l), Some (fl::nil) ->\n          (* Format.eprintf \"Root: %a ,,,,,,\\n\\ *)\n          (*                 input: %a@.\" *)\n          (*   (Form.to_smt Atom.to_smt) l (Form.to_smt Atom.to_smt) fl; *)\n          if Form.equal l fl then\n            aux\n          else (\n            (* eprintf \"ADDING Flatten rule@.\"; *)\n            aux.kind <- Other (ImmFlatten(root,fl));\n            SmtTrace.link root aux;\n            root\n          )\n        | _,_ -> aux in\n      let confl = VeritSyntax.get_clause confl_num in\n      SmtTrace.select confl;\n      occur confl;\n      (alloc first, confl)\n\n    | _ -> raise No_proof\n\n  with\n  | Ast.TypingError (t1, t2) ->\n    Structures.error\n      (asprintf \"@[<hov>LFSC typing error: expected %a, got %a@]@.\"\n         Ast.print_term t1\n         Ast.print_term t2)\n\n\n\nlet import_trace_from_file first filename =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let p = import_trace first lfsc_parse_last lexbuf in\n  close_in chan;\n  p\n\n\n\nlet clear_all () =\n  SmtTrace.clear ();\n  SmtMaps.clear ();\n  VeritSyntax.clear ();\n  Tosmtcoq.clear ();\n  C.clear ()\n\n\nlet import_all fsmt fproof =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Tosmtcoq.ra in\n  let rf = Tosmtcoq.rf in\n  let roots = Smtlib2_genConstr.import_smtlib2 rt ro ra rf fsmt in\n  let (max_id, confl) = import_trace_from_file None fproof in\n  (rt, ro, ra, rf, roots, max_id, confl)\n\n\nlet parse_certif t_i t_func t_atom t_form root used_root trace fsmt fproof =\n  SmtCommands.parse_certif t_i t_func t_atom t_form root used_root trace\n    (import_all fsmt fproof)\n\nlet checker_debug fsmt fproof =\n  SmtCommands.checker_debug (import_all fsmt fproof)\n\nlet theorem name fsmt fproof =\n  SmtCommands.theorem name (import_all fsmt fproof)\n\n(* let checker fsmt fproof =\n *   SmtCommands.checker (import_all fsmt fproof) *)\n\n(* Same but print runtime *)\nlet checker fsmt fproof =\n  let c = import_all fsmt fproof in\n  printf \"Coq checker...@.\";\n  let t0 = Sys.time () in\n  let r = SmtCommands.checker c in\n  let t1 = Sys.time () in\n  printf \"Done (Coq) [%.3f s]@.\" (t1 -. t0);\n  r\n\n\n\n(******************************************************************************)\n(** Given a Coq formula build the proof                                       *)\n(******************************************************************************)\n\n\n(* module Form2 = struct *)\n(*   (\\* Just for printing *\\) *)\n\n(*   open Form *)\n\n(*   let rec to_smt atom_to_smt fmt f = *)\n(*     if is_pos f then to_smt_pform atom_to_smt fmt (pform f) *)\n(*     else fprintf fmt \"(not %a)\" (to_smt_pform atom_to_smt) (pform f) *)\n\n(*   and to_smt_pform atom_to_smt fmt = function *)\n(*     | Fatom a -> atom_to_smt fmt a *)\n(*     | Fapp (op,args) -> to_smt_op atom_to_smt op fmt (Array.to_list args) *)\n(*     | _ -> assert false *)\n\n(*   and to_smt_op atom_to_smt op fmt args = *)\n(*     match op, args with *)\n(*       | Ftrue, [] -> fprintf fmt \"true\" *)\n(*       | Ffalse, [] -> fprintf fmt \"false\" *)\n(*       | Fand, [x; y] -> *)\n(*         fprintf fmt \"(and %a %a)\" (to_smt atom_to_smt) x (to_smt atom_to_smt) y *)\n(*       | For, [x; y] -> *)\n(*         fprintf fmt \"(or %a %a)\" (to_smt atom_to_smt) x (to_smt atom_to_smt) y *)\n(*       | Fand, x :: rargs -> *)\n(*         fprintf fmt \"(and %a %a)\" (to_smt atom_to_smt) x *)\n(*           (to_smt_op atom_to_smt Fand) rargs *)\n(*       | For, x :: rargs -> *)\n(*         fprintf fmt \"(or %a %a)\" (to_smt atom_to_smt) x *)\n(*           (to_smt_op atom_to_smt For) rargs *)\n(*       (\\* andb and orb are left-associative in Coq *\\) *)\n(*       (\\* | Fand, _ -> left_assoc atom_to_smt Fand fmt (List.rev args) *\\) *)\n(*       (\\* | For, _ -> left_assoc atom_to_smt For fmt (List.rev args) *\\) *)\n(*       | Fxor, _ -> *)\n(*         fprintf fmt \"(xor%a)\" *)\n(*           (fun fmt -> List.iter (fprintf fmt \" %a\" (to_smt atom_to_smt))) args *)\n(*       | Fimp, _ -> *)\n(*         fprintf fmt \"(=>%a)\" *)\n(*           (fun fmt -> List.iter (fprintf fmt \" %a\" (to_smt atom_to_smt))) args *)\n(*       | Fiff, _ -> *)\n(*         fprintf fmt \"(=%a)\" *)\n(*           (fun fmt -> List.iter (fprintf fmt \" %a\" (to_smt atom_to_smt))) args *)\n(*       | Fite, _ -> *)\n(*         fprintf fmt \"(ite%a)\" *)\n(*           (fun fmt -> List.iter (fprintf fmt \" %a\" (to_smt atom_to_smt))) args *)\n(*       | Fnot2 _, _ -> *)\n(*         fprintf fmt \"(not (not %a))\" *)\n(*           (fun fmt -> List.iter (fprintf fmt \" %a\" (to_smt atom_to_smt))) args *)\n(*       | _ -> assert false *)\n\n(*   and left_assoc atom_to_smt op fmt args = *)\n(*     (\\* args is reversed *\\) *)\n(*     match op, args with *)\n(*     | Fand, [x; y] -> *)\n(*       fprintf fmt \"(and %a %a)\" (to_smt atom_to_smt) y (to_smt atom_to_smt) x *)\n(*     | For, [x; y] -> *)\n(*       fprintf fmt \"(or %a %a)\" (to_smt atom_to_smt) y (to_smt atom_to_smt) x *)\n(*     | Fand, last :: rargs -> *)\n(*       fprintf fmt \"(and %a %a)\" *)\n(*         (left_assoc atom_to_smt Fand) rargs (to_smt atom_to_smt) last *)\n(*     | For, last :: rargs -> *)\n(*       fprintf fmt \"(or %a %a)\" *)\n(*         (left_assoc atom_to_smt For) rargs (to_smt atom_to_smt) last *)\n(*     | _ -> assert false *)\n\n(* end *)\n\n\n(* module Atom2 = struct *)\n(*   (\\* Just for printing *\\) *)\n\n(*   open Atom *)\n  \n(*   let distrib x l = List.map (fun y -> (x,y)) l *)\n\n(*   let rec cross acc l = match l with *)\n(*     | [] | [_] -> List.rev acc *)\n(*     | x :: r -> *)\n(*       cross (List.rev_append (distrib x r) acc) r *)\n\n(*   let cross = cross [] *)\n  \n(*   let rec compute_int = function *)\n(*     | Acop c -> *)\n(*       (match c with *)\n(*        | CO_xH -> 1 *)\n(*        | CO_Z0 -> 0 *)\n(*        | CO_BV _ -> assert false) *)\n(*     | Auop (op,h) -> *)\n(*       (match op with *)\n(*        | UO_xO -> 2*(compute_hint h) *)\n(*        | UO_xI -> 2*(compute_hint h) + 1 *)\n(*        | UO_Zpos -> compute_hint h *)\n(*        | UO_Zneg -> - (compute_hint h) *)\n(*        | _ -> assert false) *)\n(*     | _ -> assert false *)\n\n(*   and compute_hint h = compute_int (atom h) *)\n\n(*   let to_smt_int fmt i = *)\n(*     let s1 = if i < 0 then \"(- \" else \"\" in *)\n(*     let s2 = if i < 0 then \")\" else \"\" in *)\n(*     let j = if i < 0 then -i else i in *)\n(*     fprintf fmt \"%s%i%s\" s1 j s2 *)\n\n(*   let rec to_smt fmt h = to_smt_atom fmt (atom h) *)\n\n(*   and to_smt_atom fmt = function *)\n(*     | Acop _ as a -> to_smt_int fmt (compute_int a) *)\n(*     | Auop (UO_Zopp,h) -> *)\n(*       fprintf fmt \"(- \"; *)\n(*       to_smt fmt h; *)\n(*       fprintf fmt \")\" *)\n(*     | Auop _ as a -> to_smt_int fmt (compute_int a) *)\n(*     | Abop (op,h1,h2) -> to_smt_bop fmt op h1 h2 *)\n(*     | Atop (op,h1,h2,h3) -> to_smt_bop fmt op h1 h2 h3 *)\n(*     | Anop (op,a) -> to_smt_nop fmt op a *)\n(*     | Aapp (op,a) -> *)\n(*       if Array.length a = 0 then ( *)\n(*         fprintf fmt \"op_%i\" (indexed_op_index op); *)\n(*       ) else ( *)\n(*         fprintf fmt \"(op_%i\" (indexed_op_index op); *)\n(*         Array.iter (fun h -> fprintf fmt \" \"; to_smt fmt h) a; *)\n(*         fprintf fmt \")\" *)\n(*       ) *)\n\n(*   and str_op = function *)\n(*       | BO_Zplus -> \"+\" *)\n(*       | BO_Zminus -> \"-\" *)\n(*       | BO_Zmult -> \"*\" *)\n(*       | BO_Zlt -> \"<\" *)\n(*       | BO_Zle -> \"<=\" *)\n(*       | BO_Zge -> \">=\" *)\n(*       | BO_Zgt -> \">\" *)\n(*       | BO_eq _ -> \"=\" *)\n  \n(*   and to_smt_bop fmt op h1 h2 = *)\n(*     match op with *)\n(*     | BO_Zlt -> fprintf fmt \"(not (>= %a %a)\" to_smt h1 to_smt h2 *)\n(*     | BO_Zle -> fprintf fmt \"(not (>= %a (+ %a 1))\" to_smt h1 to_smt h2 *)\n(*     | BO_Zgt -> fprintf fmt \"(>= %a (+ %a 1)\" to_smt h1 to_smt h2 *)\n(*     | _ -> fprintf fmt \"(%s %a %a)\" (str_op op) to_smt h1 to_smt h2 *)\n\n(*   and to_smt_nop fmt op a = *)\n(*     let rec pp fmt = function *)\n(*       | [] -> assert false *)\n(*       | [x, y] -> fprintf fmt \"(not (= %a %a))\" to_smt x to_smt y *)\n(*       | (x, y) :: r -> *)\n(*         fprintf fmt \"(and (not (= %a %a)) %a)\" to_smt x to_smt y pp r *)\n(*     in *)\n(*     let pairs = cross (Array.to_list a) in *)\n(*     pp fmt pairs *)\n\n(* end *)\n\nlet string_logic ro f =\n  let l = SL.union (Op.logic_ro ro) (Form.logic f) in\n  if SL.is_empty l then \"QF_SAT\"\n  else\n    sprintf \"QF_%s%s%s%s\"\n    (if SL.mem LArrays l then \"A\" else \"\")\n    (if SL.mem LUF l || SL.mem LLia l then \"UF\" else \"\")\n    (if SL.mem LBitvectors l then \"BV\" else \"\")\n    (if SL.mem LLia l then \"LIA\" else \"\")\n\n\n\nlet call_cvc4 env rt ro ra rf root _ =\n  let open Smtlib2_solver in\n  let fl = snd root in\n\n  let cvc4 = create [|\n      \"cvc4\";\n      \"--lang\"; \"smt2\";\n      \"--proof\";\n      \"--no-simplification\"; \"--fewer-preprocessing-holes\";\n      \"--no-bv-eq\"; \"--no-bv-ineq\"; \"--no-bv-algebraic\" |] in\n\n  set_option cvc4 \"print-success\" true;\n  set_option cvc4 \"produce-assignments\" true;\n  set_option cvc4 \"produce-proofs\" true;\n  set_logic cvc4 (string_logic ro fl);\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (SmtBtype.Tindex t);\n    declare_sort cvc4 s 0;\n  ) (SmtBtype.to_list rt);\n  \n  List.iter (fun (i,cod,dom,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    let args =\n      Array.fold_right\n        (fun t acc -> asprintf \"%a\" SmtBtype.to_smt t :: acc) cod [] in\n    let ret = asprintf \"%a\" SmtBtype.to_smt dom in\n    declare_fun cvc4 s args ret\n  ) (Op.to_list ro);\n\n  assume cvc4 (asprintf \"%a\" (Form.to_smt ~debug:false) fl);\n\n  let proof =\n    match check_sat cvc4 with\n    | Unsat ->\n      begin\n        try get_proof cvc4 (import_trace (Some root) lfsc_parse_one)\n        with\n        | Ast.CVC4Sat -> Structures.error \"CVC4 returned SAT\"\n        | No_proof -> Structures.error \"CVC4 did not generate a proof\"\n        | Failure s -> Structures.error (\"Importing of proof failed: \" ^ s)\n      end\n    | Sat ->\n      let smodel = get_model cvc4 in\n      Structures.error\n        (\"CVC4 returned sat. Here is the model:\\n\\n\" ^\n         SmtCommands.model_string env rt ro ra rf smodel)\n        (* (asprintf \"CVC4 returned sat. Here is the model:\\n%a\" SExpr.print smodel) *)\n  in\n\n  quit cvc4;\n  proof\n\n\n\nlet export out_channel rt ro l =\n  let fmt = formatter_of_out_channel out_channel in\n  fprintf fmt \"(set-logic %s)@.\" (string_logic ro l);\n\n  List.iter (fun (i,t) ->\n    let s = \"Tindex_\"^(string_of_int i) in\n    SmtMaps.add_btype s (SmtBtype.Tindex t);\n    fprintf fmt \"(declare-sort %s 0)@.\" s\n  ) (SmtBtype.to_list rt);\n\n  List.iter (fun (i,cod,dom,op) ->\n    let s = \"op_\"^(string_of_int i) in\n    SmtMaps.add_fun s op;\n    fprintf fmt \"(declare-fun %s (\" s;\n    let is_first = ref true in\n    Array.iter (fun t ->\n        if !is_first then is_first := false\n        else fprintf fmt \" \"; SmtBtype.to_smt fmt t\n      ) cod;\n    fprintf fmt \") %a)@.\" SmtBtype.to_smt dom;\n  ) (Op.to_list ro);\n\n  fprintf fmt \"(assert %a)@\\n(check-sat)@\\n(exit)@.\"\n    (Form.to_smt ~debug:false) l\n\n\n\nlet get_model_from_file filename =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  match SExprParser.sexps SExprLexer.main lexbuf with\n  | [SExpr.Atom \"sat\"; m] -> m\n  | _ -> Structures.error \"CVC4 returned SAT but no model\"\n\n\nlet call_cvc4_file env rt ro ra rf root =\n  let fl = snd root in\n  let (filename, outchan) = Filename.open_temp_file \"cvc4_coq\" \".smt2\" in\n  export outchan rt ro fl;\n  close_out outchan;\n  let bf = Filename.chop_extension filename in\n  let prooffilename = bf ^ \".lfsc\" in\n\n  (* let cvc4_cmd = *)\n  (*   \"cvc4 --proof --dump-proof -m --dump-model \\ *)\n  (*    --no-simplification --fewer-preprocessing-holes \\ *)\n  (*    --no-bv-eq --no-bv-ineq --no-bv-algebraic \" *)\n  (*   ^ filename ^ \" > \" ^ prooffilename in *)\n  (* CVC4 crashes when asking for both models and proofs *)\n  \n  let cvc4_cmd =\n    \"cvc4 --proof --dump-proof \\\n     --no-simplification --fewer-preprocessing-holes \\\n     --no-bv-eq --no-bv-ineq --no-bv-algebraic \"\n    ^ filename ^ \" > \" ^ prooffilename in\n  (* let clean_cmd = \"sed -i -e '1d' \" ^ prooffilename in *)\n  eprintf \"%s@.\" cvc4_cmd;\n  let t0 = Sys.time () in\n  let exit_code = Sys.command cvc4_cmd in\n  \n  let t1 = Sys.time () in\n  eprintf \"CVC4 = %.5f@.\" (t1-.t0);\n\n  if exit_code <> 0 then\n    Structures.error (\"CVC4 crashed: return code \"^string_of_int exit_code);\n\n  (* ignore (Sys.command clean_cmd); *)\n\n  try import_trace_from_file (Some root) prooffilename\n  with\n  | No_proof -> Structures.error \"CVC4 did not generate a proof\"\n  | Failure s -> Structures.error (\"Importing of proof failed: \" ^ s)\n  | Ast.CVC4Sat ->\n    let smodel = get_model_from_file prooffilename in\n    Structures.error\n      (\"CVC4 returned sat. Here is the model:\\n\\n\" ^\n       SmtCommands.model_string env rt ro ra rf smodel)\n\n\nlet cvc4_logic = \n  SL.of_list [LUF; LLia; LBitvectors; LArrays]\n\n\nlet tactic_gen vm_cast =\n  clear_all ();\n  let rt = SmtBtype.create () in\n  let ro = Op.create () in\n  let ra = Tosmtcoq.ra in\n  let rf = Tosmtcoq.rf in\n  let ra' = Tosmtcoq.ra in\n  let rf' = Tosmtcoq.rf in\n  SmtCommands.tactic call_cvc4 cvc4_logic rt ro ra rf ra' rf' vm_cast [] []\n  (* (\\* Currently, quantifiers are not handled by the cvc4 tactic: we pass\n   *    the same ra and rf twice to have everything reifed *\\)\n   * SmtCommands.tactic call_cvc4 cvc4_logic rt ro ra rf ra rf vm_cast [] [] *)\nlet tactic () = tactic_gen vm_cast_true\nlet tactic_no_check () = tactic_gen (fun _ -> vm_cast_true_no_check)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1233,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1233, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1234,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1234, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1235,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1235, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1236,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"},"range":{"start":{"line":137,"character":2},"end":{"line":137,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1236, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1237,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"},"range":{"start":{"line":109,"character":18},"end":{"line":109,"character":53}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1237, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1236}}
Read message 
{"jsonrpc":"2.0","id":1238,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"},"range":{"start":{"line":94,"character":18},"end":{"line":94,"character":45}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1238, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsc.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen Ast\nopen Format\nopen Builtin\nopen VeritPrinter\n\nlet _ = Printexc.record_backtrace true\n\n\n(* Captures the output and exit status of a unix command : aux func *)\nlet syscall cmd =\n  let ic, oc = Unix.open_process cmd in\n  let buf = Buffer.create 16 in\n  (try\n     while true do\n       Buffer.add_channel buf ic 1\n     done\n   with End_of_file -> ());\n  ignore(Unix.close_process (ic, oc));\n  Buffer.contents buf\n\n(* Set width of pretty printing boxes to number of columns *)\nlet vt_width =\n  try\n    let scol = syscall \"tput cols\" in\n    let w = int_of_string (String.trim scol) in\n    set_margin w;\n    w\n  with Not_found | Failure _ -> 80\n\n\nlet _ =\n  pp_set_margin std_formatter vt_width;\n  pp_set_margin err_formatter vt_width;\n  set_max_indent (get_margin () / 3)\n\n\n\nmodule C = Converter.Make (VeritPrinter)\n\n\n(* Hard coded signatures *)\nlet signatures =\n  let sigdir = try Sys.getenv \"LFSCSIGS\" with Not_found -> Sys.getcwd () in\n  [\"sat.plf\";\n   \"smt.plf\";\n   \"th_base.plf\";\n   \"th_int.plf\";\n   \"th_bv.plf\";\n   \"th_bv_bitblast.plf\";\n   \"th_bv_rewrites.plf\";\n   \"th_arrays.plf\" ]\n  |> List.map (Filename.concat sigdir)\n\n\nlet process_signatures () =\n  try\n    List.iter (fun f ->\n        let chan = open_in f in\n        let lexbuf = Lexing.from_channel chan in\n        LfscParser.ignore_commands LfscLexer.main lexbuf;\n        close_in chan\n      ) signatures\n  with\n  | Ast.TypingError (t1, t2) ->\n    eprintf \"@[<hov>LFSC typing error: expected %a, got %a@]@.\"\n      Ast.print_term t1\n      Ast.print_term t2\n\n\n(** Translate to veriT proof format and print pretty LFSC proof with colors *)\nlet pretty_to_verit () =\n  process_signatures ();\n  let chan =\n    try\n      let filename = Sys.argv.(1) in\n      open_in filename\n    with Invalid_argument _ -> stdin\n  in\n  let buf = Lexing.from_channel chan in\n\n  try\n    let proof = LfscParser.proof LfscLexer.main buf in\n\n    printf \"LFSC proof:\\n\\n%a\\n\\n@.\" print_proof proof;\n\n    printf \"Verit proof:\\n@.\";\n    \n    match List.rev proof with\n    | Check p :: _ ->\n      flatten_term p;\n      C.convert_pt p |> ignore\n    | _ -> eprintf \"No proof@.\"; exit 1\n    \n\n  with Ast.TypingError (t1, t2) ->\n    eprintf \"@[<hov>Typing error: expected %a, got %a@]@.\"\n      Ast.print_term t1\n      Ast.print_term t2\n\n\n(** Translate to veriT proof format *)\nlet to_verit () =\n  process_signatures ();\n  let chan =\n    try\n      let filename = Sys.argv.(1) in\n      open_in filename\n    with Invalid_argument _ -> stdin\n  in\n  let buf = Lexing.from_channel chan in\n\n  eprintf \"Type-checking LFSC proof.@.\";\n  try\n\n    match LfscParser.last_command LfscLexer.main buf with\n    | Some (Check p) ->\n      (* eprintf \"Flattening pointer structures...@.\"; *)\n      (* flatten_term p; *)\n      (* eprintf \"Done (flatten)@.\"; *)\n      C.convert_pt p |> ignore\n    | _ -> eprintf \"No proof@.\"; exit 1\n\n  with\n  | Ast.TypingError (t1, t2) as e ->\n    let backtrace = Printexc.get_backtrace () in\n    eprintf \"Fatal error: %s@.\" (Printexc.to_string e);\n    eprintf \"Backtrace:@\\n%s@.\" backtrace;\n\n    eprintf \"@[<hov>Typing error: expected %a, got %a@]@.\"\n      Ast.print_term t1\n      Ast.print_term t2\n  | Ast.CVC4Sat ->\n    eprintf \"CVC4 returned SAT@.\"; exit 1\n\n\n\nlet _ = to_verit ()\n\n\n\n\n(* \n   Local Variables:\n   compile-command: \"make\"\n   indent-tabs-mode: nil\n   End: \n*)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1239,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1239, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1240,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0309944152832ms
Sending response {"id": 1240, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1241,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1241, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1242,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"},"range":{"start":{"line":81,"character":17},"end":{"line":81,"character":78}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1242, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1239}}
Read message 
{"jsonrpc":"2.0","id":1243,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"},"range":{"start":{"line":49,"character":27},"end":{"line":49,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1243, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1242}}
Read message 
{"jsonrpc":"2.0","id":1244,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"},"range":{"start":{"line":15,"character":5},"end":{"line":15,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1244, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1245,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"},"range":{"start":{"line":97,"character":12},"end":{"line":97,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1245, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/lfsctosmtcoq.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen Ast\nopen Builtin\nopen Format\nopen Translator_sig\nopen SmtBtype\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\n\ntype lit = SmtAtom.Form.t\n\ntype clause = lit list\n\nlet lit_of_atom_form_lit rf af = Form.lit_of_atom_form_lit rf (true, af)\n\nlet show_veritproof =\n  try ignore (Sys.getenv \"DONTSHOWVERIT\"); false\n  with Not_found -> true\n\n\nmodule HS = Hstring.H\n(* module HT = Hashtbl.Make (Term) *)\nmodule HCl = Hashtbl\n\nmodule HT = struct\n  module M = Map.Make (Term)\n  let create _ = ref M.empty\n  let add h k v = h := M.add k v !h\n  let find h k = M.find k !h\n  let clear h = h := M.empty\n  (* let iter f h = M.iter f !h *)\nend\n\n\n\nlet clauses_ids = HCl.create 201\nlet ids_clauses = Hashtbl.create 201\nlet propvars = HT.create 201\nlet inputs : int HS.t = HS.create 13\nlet alias_tbl = HS.create 17\nlet memo_terms = HT.create 31\n(* let termalias_tbl = HT.create 17 *)\n\nlet cl_cpt = ref 0\n\n\nlet get_rule = function\n  | Reso -> VeritSyntax.Reso\n  | Weak -> VeritSyntax.Weak\n  | Or -> VeritSyntax.Or\n  | Orp -> VeritSyntax.Orp\n  | Imp -> VeritSyntax.Imp\n  | Impp -> VeritSyntax.Impp\n  | Nand -> VeritSyntax.Nand\n  | Andn -> VeritSyntax.Andn\n  | Nimp1 -> VeritSyntax.Nimp1\n  | Nimp2 -> VeritSyntax.Nimp2\n  | Impn1 -> VeritSyntax.Impn1\n  | Impn2 -> VeritSyntax.Impn2\n  | Nor -> VeritSyntax.Nor\n  | Orn -> VeritSyntax.Orn\n  | And -> VeritSyntax.And\n  | Andp -> VeritSyntax.Andp\n  | Equ1 -> VeritSyntax.Equ1\n  | Equ2 -> VeritSyntax.Equ2\n  | Nequ1 -> VeritSyntax.Nequ1\n  | Nequ2 -> VeritSyntax.Nequ2\n  | Equp1 -> VeritSyntax.Equp1\n  | Equp2 -> VeritSyntax.Equp2\n  | Equn1 -> VeritSyntax.Equn1\n  | Equn2 -> VeritSyntax.Equn2\n  | Xor1 -> VeritSyntax.Xor1\n  | Xor2 -> VeritSyntax.Xor2\n  | Xorp1 -> VeritSyntax.Xorp1\n  | Xorp2 -> VeritSyntax.Xorp2\n  | Xorn1 -> VeritSyntax.Xorn1\n  | Xorn2 -> VeritSyntax.Xorn2\n  | Nxor1 -> VeritSyntax.Nxor1\n  | Nxor2 -> VeritSyntax.Nxor2\n  | Itep1 -> VeritSyntax.Itep1\n  | Itep2 -> VeritSyntax.Itep2\n  | Iten1 -> VeritSyntax.Iten1\n  | Iten2 -> VeritSyntax.Iten2\n  | Ite1 -> VeritSyntax.Ite1\n  | Ite2 -> VeritSyntax.Ite2\n  | Nite1 -> VeritSyntax.Nite1\n  | Nite2 -> VeritSyntax.Nite2\n  | Eqtr -> VeritSyntax.Eqtr\n  | Eqcp -> VeritSyntax.Eqcp\n  | Eqco -> VeritSyntax.Eqco\n  | Eqre -> VeritSyntax.Eqre\n  | Lage -> VeritSyntax.Lage\n  | Flat -> VeritSyntax.Flat\n  | Hole -> VeritSyntax.Hole\n  | True -> VeritSyntax.True\n  | Fals -> VeritSyntax.Fals\n  | Bbva -> VeritSyntax.Bbva\n  | Bbconst -> VeritSyntax.Bbconst\n  | Bbeq -> VeritSyntax.Bbeq\n  | Bbdis -> VeritSyntax.Bbdis\n  | Bbop -> VeritSyntax.Bbop\n  | Bbadd -> VeritSyntax.Bbadd\n  | Bbmul -> VeritSyntax.Bbmul\n  | Bbult -> VeritSyntax.Bbult\n  | Bbslt -> VeritSyntax.Bbslt\n  | Bbshl -> VeritSyntax.Bbshl\n  | Bbshr -> VeritSyntax.Bbshr\n  | Bbnot -> VeritSyntax.Bbnot\n  | Bbneg -> VeritSyntax.Bbneg\n  | Bbconc -> VeritSyntax.Bbconc\n  | Bbextr -> VeritSyntax.Bbextr\n  | Bbzext -> VeritSyntax.Bbzext\n  | Bbsext -> VeritSyntax.Bbsext\n  | Row1 -> VeritSyntax.Row1\n  | Row2 -> VeritSyntax.Row2\n  | Exte -> VeritSyntax.Exte\n\nlet string_of_rule = function\n  | Reso -> \"resolution\"\n  | Weak -> \"weaken\"\n  | Or -> \"or\"\n  | Orp -> \"or_pos\"\n  | Imp -> \"implies\"\n  | Impp -> \"implies_pos\"\n  | Nand -> \"not_and\"\n  | Andn -> \"and_neg\"\n  | Nimp1 -> \"not_implies1\"\n  | Nimp2 -> \"not_implies2\"\n  | Impn1 -> \"implies_neg1\"\n  | Impn2 -> \"implies_neg2\"\n  | Nor -> \"not_or\"\n  | Orn -> \"or_neg\"\n  | And -> \"and\"\n  | Andp -> \"and_pos\"\n  | Equ1 -> \"equiv1\"\n  | Equ2 -> \"equiv2\"\n  | Nequ1 -> \"not_equiv1\"\n  | Nequ2 -> \"not_equiv2\"\n  | Equp1 -> \"equiv_pos1\"\n  | Equp2 -> \"equiv_pos2\"\n  | Equn1 -> \"equiv_neg1\"\n  | Equn2 -> \"equiv_neg2\"\n  | Xor1 -> \"xor1\"\n  | Xor2 -> \"xor2\"\n  | Xorp1 -> \"xor_pos1\"\n  | Xorp2 -> \"xor_pos2\"\n  | Xorn1 -> \"xor_neg1\"\n  | Xorn2 -> \"xor_neg2\"\n  | Nxor1 -> \"not_xor1\"\n  | Nxor2 -> \"not_xor2\"\n  | Itep1 -> \"ite_pos1\"\n  | Itep2 -> \"ite_pos2\"\n  | Iten1 -> \"ite_neg1\"\n  | Iten2 -> \"ite_neg2\"\n  | Ite1 -> \"ite1\"\n  | Ite2 -> \"ite2\"\n  | Nite1 -> \"not_ite1\"\n  | Nite2 -> \"not_ite2\"\n  | Eqtr -> \"eq_transitive\"\n  | Eqcp -> \"eq_congruent_pred\"\n  | Eqco -> \"eq_congruent\"\n  | Eqre -> \"eq_reflexive\"\n  | Lage -> \"la_generic\"\n  | Flat -> \"flatten\"\n  | Hole -> \"hole\"\n  | True -> \"true\"\n  | Fals -> \"false\"\n  | Bbva -> \"bbvar\"\n  | Bbconst -> \"bbconst\"\n  | Bbeq -> \"bbeq\"\n  | Bbdis -> \"bv_const_neq\"\n  | Bbop -> \"bbop\"\n  | Bbadd -> \"bbadd\"\n  | Bbmul -> \"bbmul\"\n  | Bbult -> \"bbult\"\n  | Bbslt -> \"bbslt\"\n  | Bbshl -> \"bbshl\"\n  | Bbshr -> \"bbshr\"\n  | Bbnot -> \"bbnot\"\n  | Bbneg -> \"bbneg\"\n  | Bbconc -> \"bbconcat\"\n  | Bbextr -> \"bbextract\"\n  | Bbzext -> \"bbzextend\"\n  | Bbsext -> \"bbsextend\"\n  | Row1 -> \"row1\"\n  | Row2 -> \"row2\" \n  | Exte -> \"ext\" \n\n\nlet bit_to_bool t = match name t with\n  | Some n when n == H.b0 -> false\n  | Some n when n == H.b1 -> true\n  | _ -> assert false\n\nlet rec const_bv_aux acc t = match name t with\n  | Some n when n == H.bvn -> acc\n  | _ ->\n    match app_name t with\n    | Some (n, [b; t]) when n == H.bvc -> const_bv_aux (bit_to_bool b :: acc) t\n    | _ -> assert false\n\nlet const_bv t =\n  let bv_list = const_bv_aux [] t in\n  Form.Atom (Atom.mk_bvconst ra bv_list)\n\n\nlet rec term_smtcoq_old t =\n  match value t with\n  | Const {sname=Name n} when n == H.ttrue -> Form.Form Form.pform_true\n  | Const {sname=Name n} when n == H.tfalse -> Form.Form Form.pform_false\n  | Const {sname=Name n} when n == H.bvn -> const_bv t\n  | Const {sname=Name n} ->\n    begin\n      try\n        term_smtcoq  (HS.find alias_tbl n)\n      with Not_found ->\n        Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun (Hstring.view n),[||])))\n    end\n  | Int bi -> Form.Atom (Atom.hatom_Z_of_bigint ra bi)\n  | App _ ->\n    begin match app_name t with\n      | Some (n, [f]) when n == H.not_ ->\n        Form.Lit (Form.neg (lit_of_atom_form_lit rf (term_smtcoq f)))\n      | Some (n, args) when n == H.and_ -> Form.Form (Fapp (Fand, args_smtcoq args))\n      | Some (n, args) when n == H.or_ -> Form.Form (Fapp (For, args_smtcoq args))\n      | Some (n, args) when n == H.impl_ -> Form.Form (Fapp (Fimp, args_smtcoq args))\n      | Some (n, args) when n == H.xor_ -> Form.Form (Fapp (Fxor, args_smtcoq args))\n      | Some (n, args) when n == H.ite || n == H.ifte_ ->\n        Form.Form (Fapp (Fite, args_smtcoq args))\n      | Some (n, args) when n == H.iff -> Form.Form (Fapp (Fiff, args_smtcoq args))\n      | Some (n, [_; a; b]) when n == H.eq ->\n        let h1, h2 = term_smtcoq_atom a, term_smtcoq_atom b in\n        Form.Atom (Atom.mk_eq_sym ra (Atom.type_of h1) h1 h2)\n      | Some (n, _) when n == H.apply -> uncurry [] t\n      | Some (n, [p]) when n == H.p_app -> term_smtcoq p\n      | Some (n, [{value = Int bi}]) when n == H.a_int ->\n        Form.Atom (Atom.hatom_Z_of_bigint ra bi)\n      | Some (n, [ni]) when n == H.a_int ->\n        begin match app_name ni with\n          | Some (n, [{value = Int bi}]) when n == H.uminus ->\n            Form.Atom (Atom.hatom_Z_of_bigint ra (Big_int.minus_big_int bi))\n          | _ -> assert false\n        end\n      | Some (n, [_; v]) when n == H.a_var_bv -> term_smtcoq v\n      | Some (n, _) when n == H.bvc -> const_bv t\n      | Some (n, [_; v]) when n == H.a_bv -> term_smtcoq v\n      | Some (b, [a; {value = Int n}]) when b == H.bitof ->\n         (let ha = term_smtcoq_atom a in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bitof ra s (Big_int.int_of_big_int n) ha)\n            | _ -> assert false)\n      | Some (n, [_; a; bb]) when n == H.bblast_term ->\n        Form.Form (FbbT ((term_smtcoq_atom a), bblt_lits [] bb))\n      | Some (n, [_; a]) when n == H.bvnot ->\n         (let ha = term_smtcoq_atom a in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvnot ra s ha)\n            | _ -> assert false)\n      | Some (n, [_; a]) when n == H.bvneg ->\n         (let ha = term_smtcoq_atom a in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvneg ra s ha)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvand ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvand ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvor ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvor ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvxor ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvxor ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvadd ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvadd ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvmul ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvmult ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvult ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvult ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvslt ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvslt ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvule ->\n        (let ha = term_smtcoq_atom a in\n         let hb = term_smtcoq_atom b in\n         match Atom.type_of ha with\n         | TBV s ->\n           let a = Form.Atom (Atom.mk_bvult ra s hb ha) in\n           Form.Lit (Form.neg (lit_of_atom_form_lit rf a))\n         | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvsle ->\n        (let ha = term_smtcoq_atom a in\n         let hb = term_smtcoq_atom b in\n         match Atom.type_of ha with\n         | TBV s ->\n           let a = Form.Atom (Atom.mk_bvslt ra s hb ha) in\n           Form.Lit (Form.neg (lit_of_atom_form_lit rf a))\n         | _ -> assert false)         \n      | Some (n, [_; _; _; a; b]) when n == H.concat ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha, Atom.type_of hb with\n            | TBV s1, TBV s2 -> Form.Atom (Atom.mk_bvconcat ra s1 s2 ha hb)\n            | _ -> assert false)\n      | Some (n, [_; {value = Int bj}; {value = Int bi}; _; a])\n        when n == H.extract ->\n        (let ha = term_smtcoq_atom a in\n         let i = Big_int.int_of_big_int bi in\n         let j = Big_int.int_of_big_int bj in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvextr ra ~s ~i ~n:(j-i+1) ha)\n            | _ -> assert false)\n      | Some (n, [_; {value = Int bi}; _; a])\n        when n == H.zero_extend ->\n        (let ha = term_smtcoq_atom a in\n         let n = Big_int.int_of_big_int bi in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvzextn ra ~s ~n ha)\n            | _ -> assert false)\n      | Some (n, [_; {value = Int bi}; _; a])\n        when n == H.sign_extend ->\n        (let ha = term_smtcoq_atom a in\n         let n = Big_int.int_of_big_int bi in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvsextn ra ~s ~n ha)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvshl ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvshl ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvlshr ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvshr ra s ha hb)\n            | _ -> assert false)\n\n      | Some (n, [a; b]) when n == H.lt_Int ->\n        Form.Atom (Atom.mk_lt ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.le_Int ->\n        Form.Atom (Atom.mk_le ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.gt_Int ->\n        Form.Atom (Atom.mk_gt ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.ge_Int ->\n        Form.Atom (Atom.mk_ge ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.plus_Int ->\n        Form.Atom (Atom.mk_plus ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.minus_Int ->\n        Form.Atom (Atom.mk_minus ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.times_Int ->\n        Form.Atom (Atom.mk_mult ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a]) when n == H.uminus_Int ->\n        Form.Atom (Atom.mk_opp ra (term_smtcoq_atom a))\n      | Some (n, _) ->\n        Format.eprintf \"\\nTerm: %a\\n@.\" print_term t;\n        failwith (\"LFSC function symbol \"^Hstring.view n^\" not supported.\")\n      | _ -> assert false\n    end\n\n  | Rat _ -> failwith (\"LFSC rationals not supported\")\n  | Type -> failwith (\"LFSC Type not supported\")\n  | Kind -> failwith (\"LFSC Kind not supported\")\n  | Mpz -> failwith (\"LFSC mpz not supported\")\n  | Mpq -> failwith (\"LFSC mpq not supported\")\n  | Pi _ -> failwith (\"LFSC pi abstractions not supported\")\n  | Lambda _ -> failwith (\"LFSC lambda abstractions not supported\")\n  | Hole _ -> failwith (\"LFSC holes not supported\")\n  | Ptr _ -> failwith (\"LFSC Ptr not supported\")\n  | SideCond _ -> failwith (\"LFSC side conditions not supported\")\n  | _ -> assert false\n\n\nand term_smtcoq t =\n  try HT.find memo_terms t\n  with Not_found ->\n    let v = term_smtcoq_old t in\n    HT.add memo_terms t v;\n    v\n\n\nand term_smtcoq_atom a = match term_smtcoq a with\n  | Form.Atom h -> h\n  | _ ->  assert false\n\nand args_smtcoq args =\n  List.map (fun t -> lit_of_atom_form_lit rf (term_smtcoq t)) args\n  |> Array.of_list\n\nand uncurry acc t = match app_name t, acc with\n  | Some (n, [_; _; f; a]), _ when n == H.apply ->\n    uncurry (term_smtcoq_atom a :: acc) f\n  | Some (n, [_; _]) , [h1; h2] when n == H.read ->\n    (match Atom.type_of h1 with\n     | TFArray (ti,te) -> Form.Atom (Atom.mk_select ra ti te h1 h2)\n     | _ -> assert false)\n  | Some (n, [_; _]) , [h1; h2; h3] when n == H.write ->\n    (match Atom.type_of h1 with\n     | TFArray (ti,te) -> Form.Atom (Atom.mk_store ra ti te h1 h2 h3)\n     | _ -> assert false)\n  | Some (n, [_; _]) , [h1; h2] when n == H.diff ->\n    (match Atom.type_of h1 with\n     | TFArray (ti,te) -> Form.Atom (Atom.mk_diffarray ra ti te h1 h2)\n     | _ -> assert false)\n  | None, _ ->\n    (match name t with\n     | Some n ->\n       let args = Array.of_list acc in\n       Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun (Hstring.view n), args)))\n     | _ -> assert false)\n  | _ ->\n    eprintf \"uncurry fail: %a@.\" Ast.print_term t;\n    assert false\n\n(* Endianness dependant: LFSC big endian -> SMTCoq little endian *)\nand bblt_lits acc t = match name t with\n  | Some n when n == H.bbltn -> acc\n  | _ -> match app_name t with\n    | Some (n, [f; r]) when n == H.bbltc ->\n      bblt_lits (lit_of_atom_form_lit rf (term_smtcoq f) :: acc) r\n    | _ -> assert false\n\n\nlet term_smtcoq t =\n  (* eprintf \"translate term %a@.\" Ast.print_term t; *)\n  lit_of_atom_form_lit rf (term_smtcoq t)\n\n\nlet rec clause_smtcoq acc t = match name t with\n  | Some n when n == H.cln || n == H.tfalse -> acc\n  | Some _ -> term_smtcoq t :: acc\n  | None ->\n    match app_name t with\n    | Some (n, [v]) when n == H.pos ->\n      let t = HT.find propvars (deref v) in\n      term_smtcoq t :: acc\n    | Some (n, [v]) when n == H.neg ->\n      let t = HT.find propvars (deref v) in\n      Form.neg (term_smtcoq t) :: acc\n    | Some (n, [a; cl]) when n == H.clc ->\n      clause_smtcoq (clause_smtcoq acc a) cl\n    | Some (n, [a; b]) when n == H.or_ -> clause_smtcoq (clause_smtcoq acc a) b\n    | _ -> term_smtcoq t :: acc\n\n\nlet to_clause = clause_smtcoq [] \n\n\nlet print_clause fmt cl =\n  fprintf fmt \"(\";\n  List.iter (fprintf fmt \"%a \" (Form.to_smt ~debug:false)) cl;\n  fprintf fmt \")\"\n\n\n\ntype clause_res_id = NewCl of int | OldCl of int\n\n\nlet register_clause_id cl id =\n  HCl.add clauses_ids cl id;\n  Hashtbl.add ids_clauses id cl\n\n\n(* let register_termclause_id t id =\n *   register_clause_id (to_clause t) id *)\n\n\nlet new_clause_id ?(reuse=true) cl =\n  try\n    if not reuse then raise Not_found;\n    OldCl (HCl.find clauses_ids cl)\n  with Not_found ->\n    incr cl_cpt;\n    let id = !cl_cpt in\n    register_clause_id cl id;\n    NewCl id\n\n\nlet mk_clause ?(reuse=true) rule cl args =\n  match new_clause_id ~reuse cl with\n  | NewCl id ->\n    if show_veritproof then\n      eprintf \"%d:(%s %a %a)@.\" id (string_of_rule rule)\n        print_clause cl\n        (fun fmt -> List.iter (fprintf fmt \" %d\")) args;\n    VeritSyntax.mk_clause (id, (get_rule rule), cl, args)\n  | OldCl id ->\n    (* Format.eprintf \"old_clause %d@.\" id; *)\n    id\n\n\nlet mk_clause_cl ?(reuse=true) rule cl args =\n  mk_clause ~reuse rule (List.map term_smtcoq cl) args\n\n\nlet mk_input name formula =\n  let cl = [term_smtcoq formula] in\n  match new_clause_id cl with\n   | NewCl id ->\n     register_clause_id cl id;\n     HS.add inputs name id;\n     if show_veritproof then eprintf \"%d:input  %a@.\" id print_clause cl;\n     VeritSyntax.mk_clause (id, VeritSyntax.Inpu, cl, []) |> ignore\n   | OldCl _ -> ()\n\n\nlet mk_admit_preproc name formula =\n  let cl = [term_smtcoq formula] in\n  match new_clause_id cl with\n   | NewCl id ->\n     register_clause_id cl id;\n     HS.add inputs name id;\n     if show_veritproof then eprintf \"%d:hole  %a@.\" id print_clause cl;\n     VeritSyntax.mk_clause (id, VeritSyntax.Hole, cl, []) |> ignore\n   | OldCl _ -> ()\n\n\nlet register_prop_abstr vt formula = HT.add propvars vt formula\n\n\nlet register_alias name_index t = HS.add alias_tbl name_index t\n\n\n(* let register_termalias a t = HT.add termalias_tbl a t *)\n\n\nlet get_clause_id cl =\n  try HCl.find clauses_ids cl with Not_found -> assert false\n\n\nlet get_input_id h = HS.find inputs h\n\n\nlet register_decl name formula =\n  let cl = [term_smtcoq formula] in\n  match new_clause_id cl with\n  | NewCl id | OldCl id ->\n    (* eprintf \"register decl %d@.\" id; *)\n    HS.add inputs name id\n\nlet register_decl_id name id =\n  (* eprintf \"register_decl %s : %d@.\" name id; *)\n  HS.add inputs name id\n\n\n\nlet clear () =\n  Atom.clear ra;\n  Form.clear rf;\n  HCl.clear clauses_ids;\n  Hashtbl.clear ids_clauses;\n  HT.clear propvars;\n  HS.clear inputs;\n  HS.clear alias_tbl;\n  HT.clear memo_terms;\n  (* HT.clear termalias_tbl; *)\n  cl_cpt := 0\n  \n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1246,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1246, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1247,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0247955322266ms
Sending response {"id": 1247, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1248,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1248, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1249,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"range":{"start":{"line":30,"character":34},"end":{"line":30,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1249, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1246}}
Read message 
{"jsonrpc":"2.0","id":1250,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"range":{"start":{"line":72,"character":13},"end":{"line":72,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1250, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1249}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtMisc\nopen SmtCertif\nopen SmtCommands\nopen SmtForm\nopen SmtAtom\nopen SmtTrace\nopen Verit\nopen Smtlib2_ast\nopen Smtlib2_genConstr\n(* open Smt_checker *)\n\n\nmodule Mc = Structures.Micromega_plugin_Certificate.Mc\n\n\nlet mkInt = ExtrNative.of_int\nlet mkArray = ExtrNative.of_array\n\n\nlet rec dump_nat x =\n  match x with\n    | Mc.O -> Smt_checker.O\n    | Mc.S p -> Smt_checker.S (dump_nat p)\n\n\nlet rec dump_positive x =\n  match x with\n    | Mc.XH -> Smt_checker.XH\n    | Mc.XO p -> Smt_checker.XO (dump_positive p)\n    | Mc.XI p -> Smt_checker.XI (dump_positive p)\n\n\nlet dump_z x =\n  match x with\n    | Mc.Z0 -> Smt_checker.Z0\n    | Mc.Zpos p -> Smt_checker.Zpos (dump_positive p)\n    | Mc.Zneg p -> Smt_checker.Zneg (dump_positive p)\n\n\nlet dump_pol e =\n  let rec dump_pol e =\n    match e with\n      | Mc.Pc n -> Smt_checker.Pc (dump_z n)\n      | Mc.Pinj(p,pol) -> Smt_checker.Pinj (dump_positive p, dump_pol pol)\n      | Mc.PX(pol1,p,pol2) -> Smt_checker.PX (dump_pol pol1, dump_positive p, dump_pol pol2) in\n  dump_pol e\n\n\nlet dump_psatz e =\n  let rec dump_cone e =\n    match e with\n      | Mc.PsatzIn n -> Smt_checker.PsatzIn (dump_nat n)\n      | Mc.PsatzMulC(e,c) -> Smt_checker.PsatzMulC (dump_pol e, dump_cone c)\n      | Mc.PsatzSquare e -> Smt_checker.PsatzSquare (dump_pol e)\n      | Mc.PsatzAdd(e1,e2) -> Smt_checker.PsatzAdd (dump_cone e1, dump_cone e2)\n      | Mc.PsatzMulE(e1,e2) -> Smt_checker.PsatzMulE (dump_cone e1, dump_cone e2)\n      | Mc.PsatzC p -> Smt_checker.PsatzC (dump_z p)\n      | Mc.PsatzZ -> Smt_checker.PsatzZ in\n  dump_cone e\n\n\nlet rec dump_list dump_elt l =\n  match l with\n    | [] -> Smt_checker.Nil\n    | e :: l -> Smt_checker.Cons (dump_elt e, dump_list dump_elt l)\n\n\nlet rec dump_proof_term = function\n  | Micromega.DoneProof -> Smt_checker.DoneProof\n  | Micromega.RatProof(cone,rst) ->\n    Smt_checker.RatProof (dump_psatz cone, dump_proof_term rst)\n  | Micromega.CutProof(cone,prf) ->\n    Smt_checker.CutProof (dump_psatz cone, dump_proof_term prf)\n  | Micromega.EnumProof(c1,c2,prfs) ->\n    Smt_checker.EnumProof (dump_psatz c1, dump_psatz c2, dump_list dump_proof_term prfs)\n\n\n\nlet to_coq to_lit confl =\n  let out_f f = to_lit f in\n  let out_c c = mkInt (get_pos c) in\n  let step_to_coq c =\n    match c.kind with\n    | Res res ->\n\tlet size = List.length res.rtail + 3 in\n\tlet args = Array.make size (mkInt 0) in\n\targs.(0) <- mkInt (get_pos res.rc1);\n\targs.(1) <- mkInt (get_pos res.rc2);\n\tlet l = ref res.rtail in\n\tfor i = 2 to size - 2 do\n\t  match !l with\n\t  | c::tl ->\n\t      args.(i) <- mkInt (get_pos c);\n\t      l := tl\n\t  | _ -> assert false\n\tdone;\n\tSmt_checker.Euf_Checker.Res (mkInt (get_pos c), mkArray args)\n    | Other other ->\n\tbegin match other with\n\t| ImmFlatten (c',f) -> Smt_checker.Euf_Checker.ImmFlatten (out_c c, out_c c', out_f f)\n        | True -> Smt_checker.Euf_Checker.CTrue (out_c c)\n\t| False -> Smt_checker.Euf_Checker.CFalse (out_c c)\n\t| BuildDef f -> Smt_checker.Euf_Checker.BuildDef (out_c c, out_f f)\n\t| BuildDef2 f -> Smt_checker.Euf_Checker.BuildDef2 (out_c c, out_f f)\n\t| BuildProj (f, i) -> Smt_checker.Euf_Checker.BuildProj (out_c c, out_f f, mkInt i)\n\t| ImmBuildDef c' -> Smt_checker.Euf_Checker.ImmBuildDef (out_c c, out_c c')\n\t| ImmBuildDef2 c' -> Smt_checker.Euf_Checker.ImmBuildDef2 (out_c c, out_c c')\n\t| ImmBuildProj(c', i) -> Smt_checker.Euf_Checker.ImmBuildProj (out_c c, out_c c',mkInt i)\n        | EqTr (f, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons (out_f f, l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqTr (out_c c, out_f f, res)\n        | EqCgr (f, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons ((match f with | Some f -> Smt_checker.Some (out_f f) | None -> Smt_checker.None), l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqCgr (out_c c, out_f f, res)\n        | EqCgrP (f1, f2, fl) ->\n          let res = List.fold_right (fun f l -> Smt_checker.Cons ((match f with | Some f -> Smt_checker.Some (out_f f) | None -> Smt_checker.None), l)) fl Smt_checker.Nil in\n          Smt_checker.Euf_Checker.EqCgrP (out_c c, out_f f1, out_f f2, res)\n\t| LiaMicromega (cl,d) ->\n          let cl' = List.fold_right (fun f l -> Smt_checker.Cons (out_f f, l)) cl Smt_checker.Nil in\n          let c' = List.fold_right (fun f l -> Smt_checker.Cons (dump_proof_term f, l)) d Smt_checker.Nil in\n          Smt_checker.Euf_Checker.LiaMicromega (out_c c, cl', c')\n        | LiaDiseq l -> Smt_checker.Euf_Checker.LiaDiseq (out_c c, out_f l)\n        | SplArith (orig,res,l) ->\n          let res' = out_f res in\n          let l' = List.fold_right (fun f l -> Smt_checker.Cons (dump_proof_term f, l)) l Smt_checker.Nil in\n          Smt_checker.Euf_Checker.SplArith (out_c c, out_c orig, res', l')\n\t| SplDistinctElim (c',f) -> Smt_checker.Euf_Checker.SplDistinctElim (out_c c, out_c c', out_f f)\n\tend\n    | _ -> assert false in\n  let def_step =\n    Smt_checker.Euf_Checker.Res (mkInt 0, mkArray [|mkInt 0|]) in\n  let r = ref confl in\n  let nc = ref 0 in\n  while not (isRoot !r.kind) do r := prev !r; incr nc done;\n  let last_root = !r in\n  let size = !nc in\n  let max = (Parray.trunc_size (Uint63.of_int 4194303)) - 1 in\n  let q,r1 = size / max, size mod max in\n\n  let trace =\n    let len = if r1 = 0 then q + 1 else q + 2 in\n    Array.make len (mkArray [|def_step|]) in\n  for j = 0 to q - 1 do\n    let tracej = Array.make (Parray.trunc_size (Uint63.of_int 4194303)) def_step in\n    for i = 0 to max - 1 do\n      r := next !r;\n      tracej.(i) <- step_to_coq !r;\n    done;\n    trace.(j) <- mkArray tracej\n  done;\n  if r1 <> 0 then begin\n    let traceq = Array.make (r1 + 1) def_step in\n    for i = 0 to r1-1 do\n    r := next !r;\n    traceq.(i) <- step_to_coq !r;\n    done;\n    trace.(q) <- mkArray traceq\n  end;\n\n  (mkArray trace, last_root)\n\n\nlet btype_to_coq = function\n  | TZ ->        Smt_checker.Typ.TZ\n  | Tbool ->     Smt_checker.Typ.Tbool\n  | Tpositive -> Smt_checker.Typ.Tpositive\n  | Tindex i ->  Smt_checker.Typ.Tindex (mkInt (SmtAtom.indexed_type_index i))\n\n\nlet c_to_coq = function\n  | CO_xH -> Smt_checker.Atom.CO_xH\n  | CO_Z0 -> Smt_checker.Atom.CO_Z0\n\n\nlet u_to_coq = function\n  | UO_xO ->   Smt_checker.Atom.UO_xO\n  | UO_xI ->   Smt_checker.Atom.UO_xI\n  | UO_Zpos -> Smt_checker.Atom.UO_Zpos\n  | UO_Zneg -> Smt_checker.Atom.UO_Zneg\n  | UO_Zopp -> Smt_checker.Atom.UO_Zopp\n\n\nlet b_to_coq = function\n  | BO_Zplus ->  Smt_checker.Atom.BO_Zplus\n  | BO_Zminus -> Smt_checker.Atom.BO_Zminus\n  | BO_Zmult ->  Smt_checker.Atom.BO_Zmult\n  | BO_Zlt ->    Smt_checker.Atom.BO_Zlt\n  | BO_Zle ->    Smt_checker.Atom.BO_Zle\n  | BO_Zge ->    Smt_checker.Atom.BO_Zge\n  | BO_Zgt ->    Smt_checker.Atom.BO_Zgt\n  | BO_eq t ->   Smt_checker.Atom.BO_eq (btype_to_coq t)\n\n\nlet n_to_coq = function\n  | NO_distinct t -> btype_to_coq t\n\n\nlet i_to_coq i = mkInt (SmtAtom.indexed_op_index i)\n\n\nlet a_to_coq a =\n  let to_coq h = mkInt (Atom.index h) in\n  match a with\n    | Acop op -> Smt_checker.Atom.Acop (c_to_coq op)\n    | Auop (op,h) -> Smt_checker.Atom.Auop (u_to_coq op, to_coq h)\n    | Abop (op,h1,h2) ->\n      Smt_checker.Atom.Abop (b_to_coq op, to_coq h1, to_coq h2)\n    | Anop (op,ha) ->\n      let cop = n_to_coq op in\n      let cargs = Array.fold_right (fun h l -> Smt_checker.Cons (to_coq h, l)) ha Smt_checker.Nil in\n      Smt_checker.Atom.Anop (cop, cargs)\n    | Aapp (op,args) ->\n      let cop = i_to_coq op in\n      let cargs = Array.fold_right (fun h l -> Smt_checker.Cons (to_coq h, l)) args Smt_checker.Nil in\n      Smt_checker.Atom.Aapp (cop, cargs)\n\n\nlet atom_interp_tbl reify =\n  let t = Atom.to_array reify (Smt_checker.Atom.Acop Smt_checker.Atom.CO_xH) a_to_coq in\n  mkArray t\n\n\nlet form_to_coq hf = mkInt (Form.to_lit hf)\n\nlet args_to_coq args =\n  let cargs = Array.make (Array.length args + 1) (mkInt 0) in\n  Array.iteri (fun i hf -> cargs.(i) <- form_to_coq hf) args;\n  mkArray cargs\n\nlet pf_to_coq = function\n  | Fatom a -> Smt_checker.Form.Fatom (mkInt (Atom.index a))\n  | Fapp(op,args) ->\n    match op with\n      | Ftrue -> Smt_checker.Form.Ftrue\n      | Ffalse -> Smt_checker.Form.Ffalse\n      | Fand -> Smt_checker.Form.Fand (args_to_coq args)\n      | For  -> Smt_checker.Form.For (args_to_coq args)\n      | Fimp -> Smt_checker.Form.Fimp (args_to_coq args)\n      | Fxor -> if Array.length args = 2 then Smt_checker.Form.Fxor (form_to_coq args.(0), form_to_coq args.(1)) else assert false\n      | Fiff -> if Array.length args = 2 then Smt_checker.Form.Fiff (form_to_coq args.(0), form_to_coq args.(1)) else assert false\n      | Fite -> if Array.length args = 3 then Smt_checker.Form.Fite (form_to_coq args.(0), form_to_coq args.(1), form_to_coq args.(2)) else assert false\n      | Fnot2 i -> Smt_checker.Form.Fnot2 (mkInt i, form_to_coq args.(0))\n\n\nlet form_interp_tbl reify =\n  let (_,t) = Form.to_array reify Smt_checker.Form.Ftrue pf_to_coq in\n  mkArray t\n\n\n(* Importing from SMT-LIB v.2 without generating section variables *)\n\nlet count_btype = ref 0\nlet count_op = ref 0\n\n\nlet declare_sort sym =\n  let s = string_of_symbol sym in\n  let res = Tindex (dummy_indexed_type !count_btype) in\n  incr count_btype;\n  VeritSyntax.add_btype s res;\n  res\n\n\nlet declare_fun sym arg cod =\n  let s = string_of_symbol sym in\n  let tyl = List.map sort_of_sort arg in\n  let ty = sort_of_sort cod in\n  let op = dummy_indexed_op !count_op (Array.of_list (List.map fst tyl)) (fst ty) in\n  incr count_op;\n  VeritSyntax.add_fun s op;\n  op\n\n\nlet declare_commands ra rf acc = function\n  | CDeclareSort (_,sym,_) -> let _ = declare_sort sym in acc\n  | CDeclareFun (_,sym, (_, arg), cod) -> let _ = declare_fun sym arg cod in acc\n  | CAssert (_, t) -> (make_root ra rf t)::acc\n  | _ -> acc\n\n\nlet import_smtlib2 ra rf filename =\n  let chan = open_in filename in\n  let lexbuf = Lexing.from_channel chan in\n  let commands = Smtlib2_parse.main Smtlib2_lex.token lexbuf in\n  close_in chan;\n  match commands with\n    | None -> []\n    | Some (Smtlib2_ast.Commands (_,(_,res))) ->\n      List.rev (List.fold_left (declare_commands ra rf) [] res)\n\n\n(* The final checker *)\n\nlet this_clear_all () =\n  Verit.clear_all ();\n  count_btype := 0;\n  count_op := 0\n\n\nlet checker fsmt fproof =\n  this_clear_all ();\n  let ra = VeritSyntax.ra in\n  let rf = VeritSyntax.rf in\n  let roots = import_smtlib2 ra rf fsmt in\n  let (max_id, confl) = import_trace fproof None in\n  let (tres,last_root) = to_coq (fun i -> mkInt (SmtAtom.Form.to_lit i)) confl in\n  let certif =\n    Smt_checker.Euf_Checker.Certif (mkInt (max_id + 1), tres, mkInt (get_pos confl)) in\n  let used_roots = compute_roots roots last_root in\n  let used_rootsCstr =\n    let l = List.length used_roots in\n    let res = Array.make (l + 1) (mkInt 0) in\n    let i = ref (l-1) in\n    List.iter (fun j -> res.(!i) <- mkInt j; decr i) used_roots;\n    Smt_checker.Some (mkArray res) in\n  let rootsCstr =\n    let res = Array.make (List.length roots + 1) (mkInt 0) in\n    let i = ref 0 in\n    List.iter (fun j -> res.(!i) <- mkInt (SmtAtom.Form.to_lit j); incr i) roots;\n    mkArray res in\n\n  let t_atom = atom_interp_tbl ra in\n  let t_form = form_interp_tbl rf in\n\n  Smt_checker.Euf_Checker.checker_ext t_atom t_form rootsCstr used_rootsCstr certif\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1251,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1251, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1252,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1252, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1253,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1253, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1254,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1254, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1251}}
Read message 
{"jsonrpc":"2.0","id":1255,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":281,"character":2},"end":{"line":281,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1255, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1254}}
Read message 
{"jsonrpc":"2.0","id":1256,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":313,"character":11},"end":{"line":313,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1256, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1257,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"},"range":{"start":{"line":314,"character":11},"end":{"line":314,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1257, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/extraction/verit_checker.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen Ast\nopen Builtin\nopen Format\nopen Translator_sig\nopen SmtBtype\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\n\ntype lit = SmtAtom.Form.t\n\ntype clause = lit list\n\nlet lit_of_atom_form_lit rf af = Form.lit_of_atom_form_lit rf (true, af)\n\nlet show_veritproof =\n  try ignore (Sys.getenv \"DONTSHOWVERIT\"); false\n  with Not_found -> true\n\n\nmodule HS = Hstring.H\n(* module HT = Hashtbl.Make (Term) *)\nmodule HCl = Hashtbl\n\nmodule HT = struct\n  module M = Map.Make (Term)\n  let create _ = ref M.empty\n  let add h k v = h := M.add k v !h\n  let find h k = M.find k !h\n  let clear h = h := M.empty\n  (* let iter f h = M.iter f !h *)\nend\n\n\n\nlet clauses_ids = HCl.create 201\nlet ids_clauses = Hashtbl.create 201\nlet propvars = HT.create 201\nlet inputs : int HS.t = HS.create 13\nlet alias_tbl = HS.create 17\nlet memo_terms = HT.create 31\n(* let termalias_tbl = HT.create 17 *)\n\nlet cl_cpt = ref 0\n\n\nlet get_rule = function\n  | Reso -> VeritSyntax.Reso\n  | Weak -> VeritSyntax.Weak\n  | Or -> VeritSyntax.Or\n  | Orp -> VeritSyntax.Orp\n  | Imp -> VeritSyntax.Imp\n  | Impp -> VeritSyntax.Impp\n  | Nand -> VeritSyntax.Nand\n  | Andn -> VeritSyntax.Andn\n  | Nimp1 -> VeritSyntax.Nimp1\n  | Nimp2 -> VeritSyntax.Nimp2\n  | Impn1 -> VeritSyntax.Impn1\n  | Impn2 -> VeritSyntax.Impn2\n  | Nor -> VeritSyntax.Nor\n  | Orn -> VeritSyntax.Orn\n  | And -> VeritSyntax.And\n  | Andp -> VeritSyntax.Andp\n  | Equ1 -> VeritSyntax.Equ1\n  | Equ2 -> VeritSyntax.Equ2\n  | Nequ1 -> VeritSyntax.Nequ1\n  | Nequ2 -> VeritSyntax.Nequ2\n  | Equp1 -> VeritSyntax.Equp1\n  | Equp2 -> VeritSyntax.Equp2\n  | Equn1 -> VeritSyntax.Equn1\n  | Equn2 -> VeritSyntax.Equn2\n  | Xor1 -> VeritSyntax.Xor1\n  | Xor2 -> VeritSyntax.Xor2\n  | Xorp1 -> VeritSyntax.Xorp1\n  | Xorp2 -> VeritSyntax.Xorp2\n  | Xorn1 -> VeritSyntax.Xorn1\n  | Xorn2 -> VeritSyntax.Xorn2\n  | Nxor1 -> VeritSyntax.Nxor1\n  | Nxor2 -> VeritSyntax.Nxor2\n  | Itep1 -> VeritSyntax.Itep1\n  | Itep2 -> VeritSyntax.Itep2\n  | Iten1 -> VeritSyntax.Iten1\n  | Iten2 -> VeritSyntax.Iten2\n  | Ite1 -> VeritSyntax.Ite1\n  | Ite2 -> VeritSyntax.Ite2\n  | Nite1 -> VeritSyntax.Nite1\n  | Nite2 -> VeritSyntax.Nite2\n  | Eqtr -> VeritSyntax.Eqtr\n  | Eqcp -> VeritSyntax.Eqcp\n  | Eqco -> VeritSyntax.Eqco\n  | Eqre -> VeritSyntax.Eqre\n  | Lage -> VeritSyntax.Lage\n  | Flat -> VeritSyntax.Flat\n  | Hole -> VeritSyntax.Hole\n  | True -> VeritSyntax.True\n  | Fals -> VeritSyntax.Fals\n  | Bbva -> VeritSyntax.Bbva\n  | Bbconst -> VeritSyntax.Bbconst\n  | Bbeq -> VeritSyntax.Bbeq\n  | Bbdis -> VeritSyntax.Bbdis\n  | Bbop -> VeritSyntax.Bbop\n  | Bbadd -> VeritSyntax.Bbadd\n  | Bbmul -> VeritSyntax.Bbmul\n  | Bbult -> VeritSyntax.Bbult\n  | Bbslt -> VeritSyntax.Bbslt\n  | Bbshl -> VeritSyntax.Bbshl\n  | Bbshr -> VeritSyntax.Bbshr\n  | Bbnot -> VeritSyntax.Bbnot\n  | Bbneg -> VeritSyntax.Bbneg\n  | Bbconc -> VeritSyntax.Bbconc\n  | Bbextr -> VeritSyntax.Bbextr\n  | Bbzext -> VeritSyntax.Bbzext\n  | Bbsext -> VeritSyntax.Bbsext\n  | Row1 -> VeritSyntax.Row1\n  | Row2 -> VeritSyntax.Row2\n  | Exte -> VeritSyntax.Exte\n\nlet string_of_rule = function\n  | Reso -> \"resolution\"\n  | Weak -> \"weaken\"\n  | Or -> \"or\"\n  | Orp -> \"or_pos\"\n  | Imp -> \"implies\"\n  | Impp -> \"implies_pos\"\n  | Nand -> \"not_and\"\n  | Andn -> \"and_neg\"\n  | Nimp1 -> \"not_implies1\"\n  | Nimp2 -> \"not_implies2\"\n  | Impn1 -> \"implies_neg1\"\n  | Impn2 -> \"implies_neg2\"\n  | Nor -> \"not_or\"\n  | Orn -> \"or_neg\"\n  | And -> \"and\"\n  | Andp -> \"and_pos\"\n  | Equ1 -> \"equiv1\"\n  | Equ2 -> \"equiv2\"\n  | Nequ1 -> \"not_equiv1\"\n  | Nequ2 -> \"not_equiv2\"\n  | Equp1 -> \"equiv_pos1\"\n  | Equp2 -> \"equiv_pos2\"\n  | Equn1 -> \"equiv_neg1\"\n  | Equn2 -> \"equiv_neg2\"\n  | Xor1 -> \"xor1\"\n  | Xor2 -> \"xor2\"\n  | Xorp1 -> \"xor_pos1\"\n  | Xorp2 -> \"xor_pos2\"\n  | Xorn1 -> \"xor_neg1\"\n  | Xorn2 -> \"xor_neg2\"\n  | Nxor1 -> \"not_xor1\"\n  | Nxor2 -> \"not_xor2\"\n  | Itep1 -> \"ite_pos1\"\n  | Itep2 -> \"ite_pos2\"\n  | Iten1 -> \"ite_neg1\"\n  | Iten2 -> \"ite_neg2\"\n  | Ite1 -> \"ite1\"\n  | Ite2 -> \"ite2\"\n  | Nite1 -> \"not_ite1\"\n  | Nite2 -> \"not_ite2\"\n  | Eqtr -> \"eq_transitive\"\n  | Eqcp -> \"eq_congruent_pred\"\n  | Eqco -> \"eq_congruent\"\n  | Eqre -> \"eq_reflexive\"\n  | Lage -> \"la_generic\"\n  | Flat -> \"flatten\"\n  | Hole -> \"hole\"\n  | True -> \"true\"\n  | Fals -> \"false\"\n  | Bbva -> \"bbvar\"\n  | Bbconst -> \"bbconst\"\n  | Bbeq -> \"bbeq\"\n  | Bbdis -> \"bv_const_neq\"\n  | Bbop -> \"bbop\"\n  | Bbadd -> \"bbadd\"\n  | Bbmul -> \"bbmul\"\n  | Bbult -> \"bbult\"\n  | Bbslt -> \"bbslt\"\n  | Bbshl -> \"bbshl\"\n  | Bbshr -> \"bbshr\"\n  | Bbnot -> \"bbnot\"\n  | Bbneg -> \"bbneg\"\n  | Bbconc -> \"bbconcat\"\n  | Bbextr -> \"bbextract\"\n  | Bbzext -> \"bbzextend\"\n  | Bbsext -> \"bbsextend\"\n  | Row1 -> \"row1\"\n  | Row2 -> \"row2\" \n  | Exte -> \"ext\" \n\n\nlet bit_to_bool t = match name t with\n  | Some n when n == H.b0 -> false\n  | Some n when n == H.b1 -> true\n  | _ -> assert false\n\nlet rec const_bv_aux acc t = match name t with\n  | Some n when n == H.bvn -> acc\n  | _ ->\n    match app_name t with\n    | Some (n, [b; t]) when n == H.bvc -> const_bv_aux (bit_to_bool b :: acc) t\n    | _ -> assert false\n\nlet const_bv t =\n  let bv_list = const_bv_aux [] t in\n  Form.Atom (Atom.mk_bvconst ra bv_list)\n\n\nlet rec term_smtcoq_old t =\n  match value t with\n  | Const {sname=Name n} when n == H.ttrue -> Form.Form Form.pform_true\n  | Const {sname=Name n} when n == H.tfalse -> Form.Form Form.pform_false\n  | Const {sname=Name n} when n == H.bvn -> const_bv t\n  | Const {sname=Name n} ->\n    begin\n      try\n        term_smtcoq  (HS.find alias_tbl n)\n      with Not_found ->\n        Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun (Hstring.view n),[||])))\n    end\n  | Int bi -> Form.Atom (Atom.hatom_Z_of_bigint ra bi)\n  | App _ ->\n    begin match app_name t with\n      | Some (n, [f]) when n == H.not_ ->\n        Form.Lit (Form.neg (lit_of_atom_form_lit rf (term_smtcoq f)))\n      | Some (n, args) when n == H.and_ -> Form.Form (Fapp (Fand, args_smtcoq args))\n      | Some (n, args) when n == H.or_ -> Form.Form (Fapp (For, args_smtcoq args))\n      | Some (n, args) when n == H.impl_ -> Form.Form (Fapp (Fimp, args_smtcoq args))\n      | Some (n, args) when n == H.xor_ -> Form.Form (Fapp (Fxor, args_smtcoq args))\n      | Some (n, args) when n == H.ite || n == H.ifte_ ->\n        Form.Form (Fapp (Fite, args_smtcoq args))\n      | Some (n, args) when n == H.iff -> Form.Form (Fapp (Fiff, args_smtcoq args))\n      | Some (n, [_; a; b]) when n == H.eq ->\n        let h1, h2 = term_smtcoq_atom a, term_smtcoq_atom b in\n        Form.Atom (Atom.mk_eq_sym ra (Atom.type_of h1) h1 h2)\n      | Some (n, _) when n == H.apply -> uncurry [] t\n      | Some (n, [p]) when n == H.p_app -> term_smtcoq p\n      | Some (n, [{value = Int bi}]) when n == H.a_int ->\n        Form.Atom (Atom.hatom_Z_of_bigint ra bi)\n      | Some (n, [ni]) when n == H.a_int ->\n        begin match app_name ni with\n          | Some (n, [{value = Int bi}]) when n == H.uminus ->\n            Form.Atom (Atom.hatom_Z_of_bigint ra (Big_int.minus_big_int bi))\n          | _ -> assert false\n        end\n      | Some (n, [_; v]) when n == H.a_var_bv -> term_smtcoq v\n      | Some (n, _) when n == H.bvc -> const_bv t\n      | Some (n, [_; v]) when n == H.a_bv -> term_smtcoq v\n      | Some (b, [a; {value = Int n}]) when b == H.bitof ->\n         (let ha = term_smtcoq_atom a in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bitof ra s (Big_int.int_of_big_int n) ha)\n            | _ -> assert false)\n      | Some (n, [_; a; bb]) when n == H.bblast_term ->\n        Form.Form (FbbT ((term_smtcoq_atom a), bblt_lits [] bb))\n      | Some (n, [_; a]) when n == H.bvnot ->\n         (let ha = term_smtcoq_atom a in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvnot ra s ha)\n            | _ -> assert false)\n      | Some (n, [_; a]) when n == H.bvneg ->\n         (let ha = term_smtcoq_atom a in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvneg ra s ha)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvand ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvand ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvor ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvor ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvxor ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvxor ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvadd ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvadd ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvmul ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvmult ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvult ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvult ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvslt ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvslt ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvule ->\n        (let ha = term_smtcoq_atom a in\n         let hb = term_smtcoq_atom b in\n         match Atom.type_of ha with\n         | TBV s ->\n           let a = Form.Atom (Atom.mk_bvult ra s hb ha) in\n           Form.Lit (Form.neg (lit_of_atom_form_lit rf a))\n         | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvsle ->\n        (let ha = term_smtcoq_atom a in\n         let hb = term_smtcoq_atom b in\n         match Atom.type_of ha with\n         | TBV s ->\n           let a = Form.Atom (Atom.mk_bvslt ra s hb ha) in\n           Form.Lit (Form.neg (lit_of_atom_form_lit rf a))\n         | _ -> assert false)         \n      | Some (n, [_; _; _; a; b]) when n == H.concat ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha, Atom.type_of hb with\n            | TBV s1, TBV s2 -> Form.Atom (Atom.mk_bvconcat ra s1 s2 ha hb)\n            | _ -> assert false)\n      | Some (n, [_; {value = Int bj}; {value = Int bi}; _; a])\n        when n == H.extract ->\n        (let ha = term_smtcoq_atom a in\n         let i = Big_int.int_of_big_int bi in\n         let j = Big_int.int_of_big_int bj in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvextr ra ~s ~i ~n:(j-i+1) ha)\n            | _ -> assert false)\n      | Some (n, [_; {value = Int bi}; _; a])\n        when n == H.zero_extend ->\n        (let ha = term_smtcoq_atom a in\n         let n = Big_int.int_of_big_int bi in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvzextn ra ~s ~n ha)\n            | _ -> assert false)\n      | Some (n, [_; {value = Int bi}; _; a])\n        when n == H.sign_extend ->\n        (let ha = term_smtcoq_atom a in\n         let n = Big_int.int_of_big_int bi in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvsextn ra ~s ~n ha)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvshl ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvshl ra s ha hb)\n            | _ -> assert false)\n      | Some (n, [_; a; b]) when n == H.bvlshr ->\n         (let ha = term_smtcoq_atom a in\n          let hb = term_smtcoq_atom b in\n          match Atom.type_of ha with\n            | TBV s -> Form.Atom (Atom.mk_bvshr ra s ha hb)\n            | _ -> assert false)\n\n      | Some (n, [a; b]) when n == H.lt_Int ->\n        Form.Atom (Atom.mk_lt ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.le_Int ->\n        Form.Atom (Atom.mk_le ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.gt_Int ->\n        Form.Atom (Atom.mk_gt ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.ge_Int ->\n        Form.Atom (Atom.mk_ge ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.plus_Int ->\n        Form.Atom (Atom.mk_plus ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.minus_Int ->\n        Form.Atom (Atom.mk_minus ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a; b]) when n == H.times_Int ->\n        Form.Atom (Atom.mk_mult ra (term_smtcoq_atom a) (term_smtcoq_atom b))\n      | Some (n, [a]) when n == H.uminus_Int ->\n        Form.Atom (Atom.mk_opp ra (term_smtcoq_atom a))\n      | Some (n, _) ->\n        Format.eprintf \"\\nTerm: %a\\n@.\" print_term t;\n        failwith (\"LFSC function symbol \"^Hstring.view n^\" not supported.\")\n      | _ -> assert false\n    end\n\n  | Rat _ -> failwith (\"LFSC rationals not supported\")\n  | Type -> failwith (\"LFSC Type not supported\")\n  | Kind -> failwith (\"LFSC Kind not supported\")\n  | Mpz -> failwith (\"LFSC mpz not supported\")\n  | Mpq -> failwith (\"LFSC mpq not supported\")\n  | Pi _ -> failwith (\"LFSC pi abstractions not supported\")\n  | Lambda _ -> failwith (\"LFSC lambda abstractions not supported\")\n  | Hole _ -> failwith (\"LFSC holes not supported\")\n  | Ptr _ -> failwith (\"LFSC Ptr not supported\")\n  | SideCond _ -> failwith (\"LFSC side conditions not supported\")\n  | _ -> assert false\n\n\nand term_smtcoq t =\n  try HT.find memo_terms t\n  with Not_found ->\n    let v = term_smtcoq_old t in\n    HT.add memo_terms t v;\n    v\n\n\nand term_smtcoq_atom a = match term_smtcoq a with\n  | Form.Atom h -> h\n  | _ ->  assert false\n\nand args_smtcoq args =\n  List.map (fun t -> lit_of_atom_form_lit rf (term_smtcoq t)) args\n  |> Array.of_list\n\nand uncurry acc t = match app_name t, acc with\n  | Some (n, [_; _; f; a]), _ when n == H.apply ->\n    uncurry (term_smtcoq_atom a :: acc) f\n  | Some (n, [_; _]) , [h1; h2] when n == H.read ->\n    (match Atom.type_of h1 with\n     | TFArray (ti,te) -> Form.Atom (Atom.mk_select ra ti te h1 h2)\n     | _ -> assert false)\n  | Some (n, [_; _]) , [h1; h2; h3] when n == H.write ->\n    (match Atom.type_of h1 with\n     | TFArray (ti,te) -> Form.Atom (Atom.mk_store ra ti te h1 h2 h3)\n     | _ -> assert false)\n  | Some (n, [_; _]) , [h1; h2] when n == H.diff ->\n    (match Atom.type_of h1 with\n     | TFArray (ti,te) -> Form.Atom (Atom.mk_diffarray ra ti te h1 h2)\n     | _ -> assert false)\n  | None, _ ->\n    (match name t with\n     | Some n ->\n       let args = Array.of_list acc in\n       Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun (Hstring.view n), args)))\n     | _ -> assert false)\n  | _ ->\n    eprintf \"uncurry fail: %a@.\" Ast.print_term t;\n    assert false\n\n(* Endianness dependant: LFSC big endian -> SMTCoq little endian *)\nand bblt_lits acc t = match name t with\n  | Some n when n == H.bbltn -> acc\n  | _ -> match app_name t with\n    | Some (n, [f; r]) when n == H.bbltc ->\n      bblt_lits (lit_of_atom_form_lit rf (term_smtcoq f) :: acc) r\n    | _ -> assert false\n\n\nlet term_smtcoq t =\n  (* eprintf \"translate term %a@.\" Ast.print_term t; *)\n  lit_of_atom_form_lit rf (term_smtcoq t)\n\n\nlet rec clause_smtcoq acc t = match name t with\n  | Some n when n == H.cln || n == H.tfalse -> acc\n  | Some _ -> term_smtcoq t :: acc\n  | None ->\n    match app_name t with\n    | Some (n, [v]) when n == H.pos ->\n      let t = HT.find propvars (deref v) in\n      term_smtcoq t :: acc\n    | Some (n, [v]) when n == H.neg ->\n      let t = HT.find propvars (deref v) in\n      Form.neg (term_smtcoq t) :: acc\n    | Some (n, [a; cl]) when n == H.clc ->\n      clause_smtcoq (clause_smtcoq acc a) cl\n    | Some (n, [a; b]) when n == H.or_ -> clause_smtcoq (clause_smtcoq acc a) b\n    | _ -> term_smtcoq t :: acc\n\n\nlet to_clause = clause_smtcoq [] \n\n\nlet print_clause fmt cl =\n  fprintf fmt \"(\";\n  List.iter (fprintf fmt \"%a \" (Form.to_smt ~debug:false)) cl;\n  fprintf fmt \")\"\n\n\n\ntype clause_res_id = NewCl of int | OldCl of int\n\n\nlet register_clause_id cl id =\n  HCl.add clauses_ids cl id;\n  Hashtbl.add ids_clauses id cl\n\n\n(* let register_termclause_id t id =\n *   register_clause_id (to_clause t) id *)\n\n\nlet new_clause_id ?(reuse=true) cl =\n  try\n    if not reuse then raise Not_found;\n    OldCl (HCl.find clauses_ids cl)\n  with Not_found ->\n    incr cl_cpt;\n    let id = !cl_cpt in\n    register_clause_id cl id;\n    NewCl id\n\n\nlet mk_clause ?(reuse=true) rule cl args =\n  match new_clause_id ~reuse cl with\n  | NewCl id ->\n    if show_veritproof then\n      eprintf \"%d:(%s %a %a)@.\" id (string_of_rule rule)\n        print_clause cl\n        (fun fmt -> List.iter (fprintf fmt \" %d\")) args;\n    VeritSyntax.mk_clause (id, (get_rule rule), cl, args)\n  | OldCl id ->\n    (* Format.eprintf \"old_clause %d@.\" id; *)\n    id\n\n\nlet mk_clause_cl ?(reuse=true) rule cl args =\n  mk_clause ~reuse rule (List.map term_smtcoq cl) args\n\n\nlet mk_input name formula =\n  let cl = [term_smtcoq formula] in\n  match new_clause_id cl with\n   | NewCl id ->\n     register_clause_id cl id;\n     HS.add inputs name id;\n     if show_veritproof then eprintf \"%d:input  %a@.\" id print_clause cl;\n     VeritSyntax.mk_clause (id, VeritSyntax.Inpu, cl, []) |> ignore\n   | OldCl _ -> ()\n\n\nlet mk_admit_preproc name formula =\n  let cl = [term_smtcoq formula] in\n  match new_clause_id cl with\n   | NewCl id ->\n     register_clause_id cl id;\n     HS.add inputs name id;\n     if show_veritproof then eprintf \"%d:hole  %a@.\" id print_clause cl;\n     VeritSyntax.mk_clause (id, VeritSyntax.Hole, cl, []) |> ignore\n   | OldCl _ -> ()\n\n\nlet register_prop_abstr vt formula = HT.add propvars vt formula\n\n\nlet register_alias name_index t = HS.add alias_tbl name_index t\n\n\n(* let register_termalias a t = HT.add termalias_tbl a t *)\n\n\nlet get_clause_id cl =\n  try HCl.find clauses_ids cl with Not_found -> assert false\n\n\nlet get_input_id h = HS.find inputs h\n\n\nlet register_decl name formula =\n  let cl = [term_smtcoq formula] in\n  match new_clause_id cl with\n  | NewCl id | OldCl id ->\n    (* eprintf \"register decl %d@.\" id; *)\n    HS.add inputs name id\n\nlet register_decl_id name id =\n  (* eprintf \"register_decl %s : %d@.\" name id; *)\n  HS.add inputs name id\n\n\n\nlet clear () =\n  Atom.clear ra;\n  Form.clear rf;\n  HCl.clear clauses_ids;\n  Hashtbl.clear ids_clauses;\n  HT.clear propvars;\n  HS.clear inputs;\n  HS.clear alias_tbl;\n  HT.clear memo_terms;\n  (* HT.clear termalias_tbl; *)\n  cl_cpt := 0\n  \n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1258,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1258, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1259,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1259, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1260,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1260, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1261,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"range":{"start":{"line":65,"character":11},"end":{"line":65,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1261, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1262,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"position":{"line":42,"character":3}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 1262, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1263,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"position":{"line":44,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 1263, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1264,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"},"range":{"start":{"line":540,"character":5},"end":{"line":540,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0162124633789ms
Sending response {"id": 1264, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1265,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 1265, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1266,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0350475311279ms
Sending response {"id": 1266, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1267,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1267, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1268,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":79,"character":24},"end":{"line":79,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1268, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1269,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":117,"character":17},"end":{"line":117,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 1269, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/lfsc/tosmtcoq.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\nopen SmtForm\nopen SmtCertif\nopen SmtTrace\n\n\n(*** Syntax of veriT proof traces ***)\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\n\n\n(* About equality *)\n\nlet get_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,a,b) -> (a,b)\n      | _ -> failwith \"VeritSyntax.get_eq: equality was expected\")\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet get_at l =\n  match Form.pform l with\n  | Fatom ha -> ha\n  | _ -> failwith \"VeritSyntax.get_eq: equality was expected\"\n\nlet is_eq l =\n  match Form.pform l with\n  | Fatom ha ->\n     (match Atom.atom ha with\n      | Abop (BO_eq _,_,_) -> true\n      | _ -> false)\n  | _ -> failwith \"VeritSyntax.get_eq: atom was expected\"\n\n\n(* Transitivity *)\n\nlet rec list_find_remove p = function\n    [] -> raise Not_found\n  | h::t -> if p h\n            then h, t\n            else let (a, rest) = list_find_remove p t in\n                 a, h::rest\n\nlet rec process_trans a b prem res =\n  if List.length prem = 0 then (\n    assert (Atom.equal a b);\n    List.rev res\n  ) else\n    let ((l,(c,c')),prem) =\n      (* Search if there is a trivial reflexivity premice *)\n      try list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) && (Atom.equal b' b))) prem\n      (* If not, search for the equality [l:c = c'] s.t. [c = b] or [c' = b] *)\n      with | Not_found -> list_find_remove (fun (l,(a',b')) -> ((Atom.equal a' b) || (Atom.equal b' b))) prem in\n    let c = if Atom.equal c b then c' else c in\n    process_trans a c prem (l::res)\n\n\nlet mkTrans p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    let cert = (process_trans a b prem_val []) in\n    Other (EqTr (c,cert))\n  |_ -> failwith \"VeritSyntax.mkTrans: no conclusion or more than one conclusion in transitivity\"\n\n\n(* Congruence *)\n\nlet rec process_congr a_args b_args prem res =\n  match a_args,b_args with\n  | a::a_args,b::b_args ->\n     (* if a = b *)\n     (* then process_congr a_args b_args prem (None::res) *)\n     (* else *)\n     let (l,(a',b')) = List.find (fun (l,(a',b')) -> ((Atom.equal a a') && (Atom.equal b b'))||((Atom.equal a b') && (Atom.equal b a'))) prem in\n     process_congr a_args b_args prem ((Some l)::res)\n  | [],[] -> List.rev res\n  | _ -> failwith \"VeritSyntax.process_congr: incorrect number of arguments in function application\"\n\n\nlet mkCongr p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  match concl with\n  |[c] ->\n    let a,b = get_eq c in\n    let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n    (match Atom.atom a, Atom.atom b with\n     | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n        let a_args = [a1;a2] in\n        let b_args = [b1;b2] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Auop (aop,a), Auop (bop,b) when (aop = bop) ->\n        let a_args = [a] in\n        let b_args = [b] in\n        let cert = process_congr a_args b_args prem_val [] in\n        Other (EqCgr (c,cert))\n     | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n        if indexed_op_index a_f = indexed_op_index b_f then\n          let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n          Other (EqCgr (c,cert))\n        else failwith \"VeritSyntax.mkCongr: left function is different from right fucntion\"\n     | _, _ -> failwith \"VeritSyntax.mkCongr: atoms are not applications\")\n  |_ -> failwith \"VeritSyntax.mkCongr: no conclusion or more than one conclusion in congruence\"\n\n\nlet mkCongrPred p =\n  let (concl,prem) = List.partition Form.is_pos p in\n  let (prem,prem_P) = List.partition is_eq prem in\n  match concl with\n  |[c] ->\n    (match prem_P with\n     |[p_p] ->\n       let prem_val = List.map (fun l -> (l,get_eq l)) prem in\n       (match Atom.atom (get_at c), Atom.atom (get_at p_p) with\n        | Abop(aop,a1,a2), Abop(bop,b1,b2) when (aop = bop) ->\n           let a_args = [a1;a2] in\n           let b_args = [b1;b2] in\n           let cert = process_congr a_args b_args prem_val [] in\n           Other (EqCgrP (p_p,c,cert))\n        | Aapp (a_f,a_args), Aapp (b_f,b_args) ->\n           if indexed_op_index a_f = indexed_op_index b_f then\n             let cert = process_congr (Array.to_list a_args) (Array.to_list b_args) prem_val [] in\n             Other (EqCgrP (p_p,c,cert))\n           else failwith \"VeritSyntax.mkCongrPred: unmatching predicates\"\n        | _ -> failwith \"VeritSyntax.mkCongrPred : not pred app\")\n     |_ ->  failwith \"VeritSyntax.mkCongr: no or more than one predicate app premise in congruence\")\n  |[] ->  failwith \"VeritSyntax.mkCongrPred: no conclusion in congruence\"\n  |_ -> failwith \"VeritSyntax.mkCongrPred: more than one conclusion in congruence\"\n\n\n(* Linear arithmetic *)\n\nlet mkMicromega cl =\n  let _tbl, _f, cert = Lia.build_lia_certif cl in\n  let c =\n    match cert with\n    | None -> failwith \"VeritSyntax.mkMicromega: micromega can't solve this\"\n    | Some c -> c in\n  Other (LiaMicromega (cl,c))\n\n\nlet mkSplArith orig cl =\n  let res =\n    match cl with\n    | res::nil -> res\n    | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the resulting clause\" in\n  try\n    let orig' =\n      match orig.value with\n      | Some [orig'] -> orig'\n      | _ -> failwith \"VeritSyntax.mkSplArith: wrong number of literals in the premise clause\" in\n    let _tbl, _f, cert = Lia.build_lia_certif [Form.neg orig';res] in\n    let c =\n      match cert with\n      | None -> failwith \"VeritSyntax.mkSplArith: micromega can't solve this\"\n      | Some c -> c in\n    Other (SplArith (orig,res,c))\n  with\n  | _ -> Other (ImmFlatten (orig, res))\n\n\n(* Elimination of operators *)\n\nlet mkDistinctElim old value =\n  let rec find_res l1 l2 =\n    match l1,l2 with\n    | t1::q1,t2::q2 -> if t1 == t2 then find_res q1 q2 else t2\n    | _, _ -> assert false in\n  let l1 = match old.value with\n    | Some l -> l\n    | None -> assert false in\n  Other (SplDistinctElim (old,find_res l1 value))\n\n\n(* Clause difference (wrt to their sets of literals) *)\n\n(* let clause_diff c1 c2 =\n *   let r =\n *     List.filter (fun t1 -> not (List.exists (SmtAtom.Form.equal t1) c2)) c1\n *   in\n *   Format.eprintf \"[\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c1;\n *   Format.eprintf \"] -- [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) c2;\n *   Format.eprintf \"] ==\\n [\";\n *   List.iter (Format.eprintf \" %a ,\\n\" SmtAtom.(Form.to_smt Atom.to_smt)) r;\n *   Format.eprintf \"] @.\";\n *   r *)\n\n\n\n(* Generating clauses *)\n\nlet clauses : (int,Form.t clause) Hashtbl.t = Hashtbl.create 17\nlet get_clause id =\n  try Hashtbl.find clauses id\n  with | Not_found -> failwith (\"VeritSyntax.get_clause : clause number \"^(string_of_int id)^\" not found\\n\")\nlet add_clause id cl = Hashtbl.add clauses id cl\nlet clear_clauses () = Hashtbl.clear clauses\n\n\n(* <ref_cl> maps solver integers to id integers. *)\nlet ref_cl : (int, int) Hashtbl.t = Hashtbl.create 17\nlet get_ref i = Hashtbl.find ref_cl i\nlet add_ref i j = Hashtbl.add ref_cl i j\nlet clear_ref () = Hashtbl.clear ref_cl\n\n(* Recognizing and modifying clauses depending on a forall_inst clause. *)\n\nlet rec fins_lemma ids_params =\n  match ids_params with\n    [] -> raise Not_found\n  | h :: t -> let cl_target = repr (get_clause h) in\n              match cl_target.kind with\n                Other (Forall_inst (lemma, _)) -> lemma\n              | _ -> fins_lemma t\n\nlet find_remove_lemma lemma ids_params =\n  let eq_lemma h = eq_clause lemma (get_clause h) in\n  list_find_remove eq_lemma ids_params\n\n(* Removes the lemma in a list of ids containing an instance of this lemma *)\nlet rec merge ids_params =\n  let rest_opt = try let lemma = fins_lemma ids_params in\n                     let _, rest = find_remove_lemma lemma ids_params in\n                     Some rest\n                 with Not_found -> None in\n  match rest_opt with\n    None -> ids_params\n  | Some r -> merge r\n\nlet to_add = ref []\n\nlet mk_clause (id,typ,value,ids_params) =\n  let kind =\n    match typ with\n      (* Roots *)\n      | Inpu -> Root\n      (* Cnf conversion *)\n      | True -> Other SmtCertif.True\n      | Fals -> Other False\n      | Andn | Orp | Impp | Xorp1 | Xorn1 | Equp1 | Equn1 | Itep1 | Iten1 ->\n        (match value with\n          | l::_ -> Other (BuildDef l)\n          | _ -> assert false)\n      | Xorp2 | Xorn2 | Equp2 | Equn2 | Itep2 | Iten2 ->\n        (match value with\n          | l::_ -> Other (BuildDef2 l)\n          | _ -> assert false)\n      | Orn | Andp ->\n        (match value,ids_params with\n          | l::_, [p] -> Other (BuildProj (l,p))\n          | _ -> assert false)\n      | Impn1 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,0))\n          | _ -> assert false)\n      | Impn2 ->\n        (match value with\n          | l::_ -> Other (BuildProj (l,1))\n          | _ -> assert false)\n      | Nand | Imp | Xor1 | Nxor1 | Equ2 | Nequ2 | Ite1 | Nite1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef (get_clause id))\n          | _ -> assert false)\n      | Or ->\n         (match ids_params with\n            | [id_target] ->\n               let cl_target = get_clause id_target in\n               begin match cl_target.kind with\n                 | Other (Forall_inst _) -> Same cl_target\n                 | _ -> Other (ImmBuildDef cl_target) end\n            | _ -> assert false)\n      | Xor2 | Nxor2 | Equ1 | Nequ1 | Ite2 | Nite2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildDef2 (get_clause id))\n          | _ -> assert false)\n      | And | Nor ->\n        (match ids_params with\n          | [id;p] -> Other (ImmBuildProj (get_clause id,p))\n          | _ -> assert false)\n      | Nimp1 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,0))\n          | _ -> assert false)\n      | Nimp2 ->\n        (match ids_params with\n          | [id] -> Other (ImmBuildProj (get_clause id,1))\n          | _ -> assert false)\n      (* Equality *)\n      | Eqre -> mkTrans value\n      | Eqtr -> mkTrans value\n      | Eqco -> mkCongr value\n      | Eqcp -> mkCongrPred value\n      (* Linear integer arithmetic *)\n      | Dlge | Lage | Lata -> mkMicromega value\n      | Lade               -> mkMicromega value (* TODO: utiliser un solveur plus simple *)\n      | Dlde ->\n        (match value with\n          | l::_ -> Other (LiaDiseq l)\n          | _ -> assert false)\n      (* Resolution *)\n      | Reso ->\n         let ids_params = merge ids_params in\n         (match ids_params with\n            | cl1::cl2::q ->\n               let res = {rc1 = get_clause cl1; rc2 = get_clause cl2; rtail = List.map get_clause q} in\n               Res res\n            | [fins_id] -> Same (get_clause fins_id)\n            | [] -> assert false)\n      (* Clause weakening *)\n      | Weak ->\n        (match ids_params with\n         | [id] -> (* Other (Weaken (get_clause id, value)) *)\n           let cid = get_clause id in\n           (match cid.value with\n           | None -> Other (Weaken (cid, value))\n           | Some c -> Other (Weaken (cid, value))\n            (* need to add c, otherwise dosen't terminate or returns false,\n               we would like instead: clause_diff value c *)\n           )\n          | _ -> assert false)\n      (* Simplifications *)\n      | Tpal ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tple ->\n        (match ids_params with\n          | id::_ -> Same (get_clause id)\n          | _ -> assert false)\n      | Tpde ->\n        (match ids_params with\n          | id::_ -> mkDistinctElim (get_clause id) value\n          | _ -> assert false)\n      | Tpsa | Tlap ->\n        (match ids_params with\n          | id::_ -> mkSplArith (get_clause id) value\n          | _ -> assert false)\n      | Flat ->\n        (match ids_params, value with\n         | id::_, f :: _ -> Other (ImmFlatten(get_clause id, f))\n         | _ -> assert false)\n      (* Bit blasting *)\n      | Bbva ->\n         (match value with\n           | [f] -> Other (BBVar f)\n           | _ -> assert false)\n      | Bbconst ->\n         (match value with\n           | [f] -> Other (BBConst f)\n           | _ -> assert false)\n      | Bbeq ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBEq (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbdis ->\n         (match value with\n           | [f] -> Other (BBDiseq f)\n           | __ -> assert false)\n      | Bbop ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBOp (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbadd ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBAdd (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbmul ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBMul (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbult ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBUlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbslt ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBSlt (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbconc ->\n         (match ids_params, value with\n           | [id1;id2], [f] ->\n             Other (BBConc (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbextr ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBExtr (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbzext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBZextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbsext ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBSextn (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbshl ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShl (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbshr ->\n         (match ids_params, value with\n           | [id1;id2], [f] -> Other (BBShr (get_clause id1, get_clause id2, f))\n           | _, _ -> assert false)\n      | Bbnot ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNot (get_clause id, f))\n           | _, _ -> assert false)\n      | Bbneg ->\n         (match ids_params, value with\n           | [id], [f] -> Other (BBNeg (get_clause id, f))\n           | _, _ -> assert false)\n\n      | Row1 ->\n         (match value with\n           | [f] -> Other (RowEq f)\n           | _ -> assert false)\n\n      | Exte ->\n         (match value with\n           | [f] -> Other (Ext f)\n           | _ -> assert false)\n\n      | Row2 -> Other (RowNeq value)\n\n      (* Holes in proofs *)\n      | Hole -> Other (SmtCertif.Hole (List.map get_clause ids_params, value))\n\n      (* Quantifier instanciation *)\n      | Fins ->\n         begin match value, ids_params with\n           | [inst], [ref_th] ->\n              let cl_th = get_clause ref_th in\n              Other (Forall_inst (repr cl_th, inst))\n           | _ -> failwith \"unexpected form of forall_inst\" end\n      | Tpbr ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_betared\" end\n      | Tpqt ->\n         begin match ids_params with\n           | [id] ->\n              Same (get_clause id)\n           | _ -> failwith \"unexpected form of tmp_qnt_tidy\" end\n\n      (* Not implemented *)\n      | Deep -> failwith \"VeritSyntax.ml: rule deep_res not implemented yet\"\n      | Eins -> failwith \"VeritSyntax.ml: rule exists_inst not implemented yet\"\n      | Skea -> failwith \"VeritSyntax.ml: rule skolem_ex_ax not implemented yet\"\n      | Skaa -> failwith \"VeritSyntax.ml: rule skolem_all_ax not implemented yet\"\n      | Qnts -> failwith \"VeritSyntax.ml: rule qnt_simplify_ax not implemented yet\"\n      | Qntm -> failwith \"VeritSyntax.ml: rule qnt_merge_ax not implemented yet\"\n      | Tpne -> failwith \"VeritSyntax.ml: rule tmp_nary_elim not implemented yet\"\n      | Tpie -> failwith \"VeritSyntax.ml: rule tmp_ite_elim not implemented yet\"\n      | Tpma -> failwith \"VeritSyntax.ml: rule tmp_macrosubst not implemented yet\"\n      | Tpbe -> failwith \"VeritSyntax.ml: rule tmp_bfun_elim not implemented yet\"\n      | Tpsc -> failwith \"VeritSyntax.ml: rule tmp_sk_connector not implemented yet\"\n      | Tppp -> failwith \"VeritSyntax.ml: rule tmp_pm_process not implemented yet\"\n      | Tpqs -> failwith \"VeritSyntax.ml: rule tmp_qnt_simplify not implemented yet\"\n      | Tpsk -> failwith \"VeritSyntax.ml: rule tmp_skolemize not implemented yet\"\n      | Subp -> failwith \"VeritSyntax.ml: rule subproof not implemented yet\"\n  in\n  let cl =\n    (* TODO: change this into flatten when necessary *)\n    if SmtTrace.isRoot kind then SmtTrace.mkRootV value\n    else SmtTrace.mk_scertif kind (Some value) in\n  add_clause id cl;\n  if id > 1 then SmtTrace.link (get_clause (id-1)) cl;\n  id\n\n\nlet mk_clause cl =\n  try mk_clause cl\n  with Failure f ->\n    Structures.error (\"SMTCoq was not able to check the certificate \\\n                       for the following reason.\\n\"^f)\n\nlet apply_dec f (decl, a) = decl, f a\n\nlet rec list_dec = function\n  | [] -> true, []\n  | (decl_h, h) :: t ->\n     let decl_t, l_t = list_dec t in\n     decl_h && decl_t, h :: l_t\n\nlet apply_dec_atom (f:?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) = function\n  | decl, Form.Atom h -> decl, Form.Atom (f ~declare:decl h)\n  | _ -> assert false\n\nlet apply_bdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 =\n  match o1, o2 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2) ->\n     let decl = decl1 && decl2 in\n     decl, Form.Atom (f ~declare:decl h1 h2)\n  | _ -> assert false\n\nlet apply_tdec_atom (f:?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) o1 o2 o3 =\n  match o1, o2, o3 with\n  | (decl1, Form.Atom h1), (decl2, Form.Atom h2), (decl3, Form.Atom h3) ->\n     let decl = decl1 && decl2 && decl3 in\n     decl, Form.Atom (f ~declare:decl h1 h2 h3)\n  | _ -> assert false\n\n\nlet solver : (int, (bool * Form.atom_form_lit)) Hashtbl.t = Hashtbl.create 17\nlet get_solver id =\n  try Hashtbl.find solver id\n  with | Not_found -> failwith (\"VeritSyntax.get_solver : solver variable number \"^(string_of_int id)^\" not found\\n\")\nlet add_solver id cl = Hashtbl.add solver id cl\nlet clear_solver () = Hashtbl.clear solver\n\nlet qvar_tbl : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 10\nlet find_opt_qvar s = try Some (Hashtbl.find qvar_tbl s)\n                      with Not_found -> None\nlet add_qvar s bt = Hashtbl.add qvar_tbl s bt\nlet clear_qvar () = Hashtbl.clear qvar_tbl\n\n(* Finding the index of a root in <lsmt> modulo the <re_hash> function.\n   This function is used by SmtTrace.order_roots *)\nlet init_index lsmt re_hash =\n  let form_index_init_rank : (int, int) Hashtbl.t = Hashtbl.create 20 in\n  let add = Hashtbl.add form_index_init_rank in\n  let find = Hashtbl.find form_index_init_rank in\n  let rec walk rank = function\n    | [] -> ()\n    | h::t -> add (Form.to_lit (re_hash h)) rank;\n              walk (rank+1) t in\n  walk 1 lsmt;\n  fun hf -> let re_hf = re_hash hf in\n            try find (Form.to_lit re_hf)\n            with Not_found ->\n              let oc = open_out \"/tmp/input_not_found.log\" in\n              let fmt = Format.formatter_of_out_channel oc in\n              List.iter (fun h -> Format.fprintf fmt \"%a\\n\" (Form.to_smt ~debug:true) (re_hash h)) lsmt;\n              Format.fprintf fmt \"\\n%a\\n@.\" (Form.to_smt ~debug:true) re_hf;\n              flush oc; close_out oc;\n              failwith \"Input not found: log available in /tmp/input_not_found.log\"\n\nlet qf_to_add lr =\n  let is_forall l = match Form.pform l with\n    | Fapp (Fforall _, _) -> true\n    | _ -> false in\n  let rec qf_lemmas = function\n    | [] -> []\n    | ({value = Some [l]} as r)::t when not (is_forall l) ->\n       (Other (Qf_lemma (r, l)), r.value, r) :: qf_lemmas t\n    | _::t -> qf_lemmas t in\n  qf_lemmas lr\n\nlet ra = Atom.create ()\nlet rf = Form.create ()\nlet ra_quant = Atom.create ()\nlet rf_quant = Form.create ()\n\nlet hlets : (string, Form.atom_form_lit) Hashtbl.t = Hashtbl.create 17\n\nlet clear_mk_clause () =\n  to_add := [];\n  clear_ref ()\n\nlet clear () =\n  clear_qvar ();\n  clear_mk_clause ();\n  clear_clauses ();\n  clear_solver ();\n  Atom.clear ra;\n  Form.clear rf;\n  Atom.clear ra_quant;\n  Form.clear rf_quant;\n  Hashtbl.clear hlets\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1270,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1270, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1271,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1271, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1272,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1272, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1273,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"},"range":{"start":{"line":119,"character":23},"end":{"line":119,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1273, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1273}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.ml"}}}
Read message 
{"jsonrpc":"2.0","id":1274,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0879764556885ms
Sending response {"id": 1274, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1275,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1275, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1276,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1276, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1277,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":79,"character":26},"end":{"line":79,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1277, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml","languageId":"ocaml","version":1,"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"z3/z3Parser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open VeritSyntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"z3/z3Parser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"z3/z3Parser.mly\"\n                                                           ( raise Sat )\n# 815 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"z3/z3Parser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"z3/z3Parser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"z3/z3Parser.mly\"\n                                                           ( Tpbr  )\n# 860 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"z3/z3Parser.mly\"\n                                                           ( Inpu  )\n# 866 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"z3/z3Parser.mly\"\n                                                           ( Deep  )\n# 872 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"z3/z3Parser.mly\"\n                                                           ( True  )\n# 878 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"z3/z3Parser.mly\"\n                                                           ( Fals  )\n# 884 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"z3/z3Parser.mly\"\n                                                           ( Andp  )\n# 890 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"z3/z3Parser.mly\"\n                                                           ( Andn  )\n# 896 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"z3/z3Parser.mly\"\n                                                           ( Orp   )\n# 902 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"z3/z3Parser.mly\"\n                                                           ( Orn   )\n# 908 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"z3/z3Parser.mly\"\n                                                           ( Xorp1 )\n# 914 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"z3/z3Parser.mly\"\n                                                           ( Xorp2 )\n# 920 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"z3/z3Parser.mly\"\n                                                           ( Xorn1 )\n# 926 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"z3/z3Parser.mly\"\n                                                           ( Xorn2 )\n# 932 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"z3/z3Parser.mly\"\n                                                           ( Impp  )\n# 938 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"z3/z3Parser.mly\"\n                                                           ( Impn1 )\n# 944 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"z3/z3Parser.mly\"\n                                                           ( Impn2 )\n# 950 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"z3/z3Parser.mly\"\n                                                           ( Equp1 )\n# 956 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"z3/z3Parser.mly\"\n                                                           ( Equp2 )\n# 962 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"z3/z3Parser.mly\"\n                                                           ( Equn1 )\n# 968 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"z3/z3Parser.mly\"\n                                                           ( Equn2 )\n# 974 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"z3/z3Parser.mly\"\n                                                           ( Itep1 )\n# 980 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"z3/z3Parser.mly\"\n                                                           ( Itep2 )\n# 986 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"z3/z3Parser.mly\"\n                                                           ( Iten1 )\n# 992 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"z3/z3Parser.mly\"\n                                                           ( Iten2 )\n# 998 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"z3/z3Parser.mly\"\n                                                           ( Eqre  )\n# 1004 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"z3/z3Parser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"z3/z3Parser.mly\"\n                                                           ( Eqco  )\n# 1016 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"z3/z3Parser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"z3/z3Parser.mly\"\n                                                           ( Dlge  )\n# 1028 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"z3/z3Parser.mly\"\n                                                           ( Lage  )\n# 1034 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"z3/z3Parser.mly\"\n                                                           ( Lata  )\n# 1040 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"z3/z3Parser.mly\"\n                                                           ( Dlde  )\n# 1046 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"z3/z3Parser.mly\"\n                                                           ( Lade  )\n# 1052 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"z3/z3Parser.mly\"\n                                                           ( Eins  )\n# 1058 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"z3/z3Parser.mly\"\n                                                           ( Skea  )\n# 1064 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"z3/z3Parser.mly\"\n                                                           ( Skaa  )\n# 1070 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"z3/z3Parser.mly\"\n                                                           ( Qnts  )\n# 1076 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"z3/z3Parser.mly\"\n                                                           ( Qntm  )\n# 1082 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"z3/z3Parser.mly\"\n                                                           ( Reso  )\n# 1088 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"z3/z3Parser.mly\"\n                                                           ( Weak  )\n# 1094 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"z3/z3Parser.mly\"\n                                                           ( And   )\n# 1100 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"z3/z3Parser.mly\"\n                                                           ( Nor   )\n# 1106 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"z3/z3Parser.mly\"\n                                                           ( Or    )\n# 1112 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"z3/z3Parser.mly\"\n                                                           ( Nand  )\n# 1118 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"z3/z3Parser.mly\"\n                                                           ( Xor1  )\n# 1124 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"z3/z3Parser.mly\"\n                                                           ( Xor2  )\n# 1130 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"z3/z3Parser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"z3/z3Parser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"z3/z3Parser.mly\"\n                                                           ( Imp   )\n# 1148 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"z3/z3Parser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"z3/z3Parser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"z3/z3Parser.mly\"\n                                                           ( Equ1  )\n# 1166 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"z3/z3Parser.mly\"\n                                                           ( Equ2  )\n# 1172 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"z3/z3Parser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"z3/z3Parser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"z3/z3Parser.mly\"\n                                                           ( Ite1  )\n# 1190 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"z3/z3Parser.mly\"\n                                                           ( Ite2  )\n# 1196 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"z3/z3Parser.mly\"\n                                                           ( Nite1 )\n# 1202 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"z3/z3Parser.mly\"\n                                                           ( Nite2 )\n# 1208 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"z3/z3Parser.mly\"\n                                                           ( Tpal  )\n# 1214 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"z3/z3Parser.mly\"\n                                                           ( Tlap  )\n# 1220 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"z3/z3Parser.mly\"\n                                                           ( Tple  )\n# 1226 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"z3/z3Parser.mly\"\n                                                           ( Tpne  )\n# 1232 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"z3/z3Parser.mly\"\n                                                           ( Tpde  )\n# 1238 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"z3/z3Parser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"z3/z3Parser.mly\"\n                                                           ( Tpie  )\n# 1250 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"z3/z3Parser.mly\"\n                                                           ( Tpma  )\n# 1256 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"z3/z3Parser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"z3/z3Parser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"z3/z3Parser.mly\"\n                                                           ( Tppp  )\n# 1274 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"z3/z3Parser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"z3/z3Parser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"z3/z3Parser.mly\"\n                                                           ( Subp  )\n# 1292 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"z3/z3Parser.mly\"\n                                                           ( Flat  )\n# 1298 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"z3/z3Parser.mly\"\n                                                           ( Hole  )\n# 1304 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"z3/z3Parser.mly\"\n                                                           ( Bbva  )\n# 1310 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"z3/z3Parser.mly\"\n                                                           ( Bbconst )\n# 1316 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"z3/z3Parser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"z3/z3Parser.mly\"\n                                                           ( Bbdis )\n# 1328 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"z3/z3Parser.mly\"\n                                                           ( Bbop  )\n# 1334 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"z3/z3Parser.mly\"\n                                                           ( Bbadd )\n# 1340 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"z3/z3Parser.mly\"\n                                                           ( Bbmul )\n# 1346 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"z3/z3Parser.mly\"\n                                                           ( Bbult )\n# 1352 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"z3/z3Parser.mly\"\n                                                           ( Bbslt )\n# 1358 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"z3/z3Parser.mly\"\n                                                           ( Bbnot )\n# 1364 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"z3/z3Parser.mly\"\n                                                           ( Bbneg )\n# 1370 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"z3/z3Parser.mly\"\n                                                           ( Bbconc )\n# 1376 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"z3/z3Parser.mly\"\n                                                           ( Bbextr )\n# 1382 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"z3/z3Parser.mly\"\n                                                           ( Bbzext )\n# 1388 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"z3/z3Parser.mly\"\n                                                           ( Bbsext )\n# 1394 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"z3/z3Parser.mly\"\n                                                           ( Bbshl )\n# 1400 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"z3/z3Parser.mly\"\n                                                           ( Bbshr )\n# 1406 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"z3/z3Parser.mly\"\n                                                           ( Row1  )\n# 1412 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"z3/z3Parser.mly\"\n                                                           ( Row2  )\n# 1418 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"z3/z3Parser.mly\"\n                                                           ( Exte  )\n# 1424 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"z3/z3Parser.mly\"\n                                                           ( [] )\n# 1430 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"z3/z3Parser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 1444 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"z3/z3Parser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"z3/z3Parser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"z3/z3Parser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"z3/z3Parser.mly\"\n                                             ( _1 )\n# 1480 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"z3/z3Parser.mly\"\n                                       ( _1 )\n# 1487 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"z3/z3Parser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"z3/z3Parser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"z3/z3Parser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"z3/z3Parser.mly\"\n                 ( TZ )\n# 1557 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"z3/z3Parser.mly\"\n                  ( Tbool )\n# 1563 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"z3/z3Parser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"z3/z3Parser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"z3/z3Parser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"z3/z3Parser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"z3/z3Parser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"z3/z3Parser.mly\"\n                                                           ( _2 )\n# 1602 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1656 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"z3/z3Parser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"z3/z3Parser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"z3/z3Parser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"z3/z3Parser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"z3/z3Parser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"z3/z3Parser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"z3/z3Parser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"z3/z3Parser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1993 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"z3/z3Parser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"z3/z3Parser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 2039 \"z3/z3Parser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 2046 \"z3/z3Parser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"z3/z3Parser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"z3/z3Parser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1278,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1278, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1279,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1279, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1280,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1280, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1281,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":171,"character":12},"end":{"line":171,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1281, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1282,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":161,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Sending response {"id": 1282, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1283,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":163,"character":4}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 1283, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1284,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":165,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.569105148315ms
Sending response {"id": 1284, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1285,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":171,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 1285, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1286,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":171,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0319480895996ms
Sending response {"id": 1286, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1287,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":171,"character":11}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 1287, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1288,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 1288, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1289,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":171,"character":12}}}
[server] Got a method textDocument/hover
[server] processing took 0.00786781311035ms
Sending response {"id": 1289, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1290,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":171,"character":12}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00786781311035ms
Sending response {"id": 1290, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1291,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":171,"character":12},"end":{"line":171,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1291, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml","version":6},"contentChanges":[{"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"z3/z3Parser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open Syntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"z3/z3Parser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"z3/z3Parser.mly\"\n                                                           ( raise Sat )\n# 815 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"z3/z3Parser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"z3/z3Parser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"z3/z3Parser.mly\"\n                                                           ( Tpbr  )\n# 860 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"z3/z3Parser.mly\"\n                                                           ( Inpu  )\n# 866 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"z3/z3Parser.mly\"\n                                                           ( Deep  )\n# 872 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"z3/z3Parser.mly\"\n                                                           ( True  )\n# 878 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"z3/z3Parser.mly\"\n                                                           ( Fals  )\n# 884 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"z3/z3Parser.mly\"\n                                                           ( Andp  )\n# 890 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"z3/z3Parser.mly\"\n                                                           ( Andn  )\n# 896 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"z3/z3Parser.mly\"\n                                                           ( Orp   )\n# 902 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"z3/z3Parser.mly\"\n                                                           ( Orn   )\n# 908 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"z3/z3Parser.mly\"\n                                                           ( Xorp1 )\n# 914 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"z3/z3Parser.mly\"\n                                                           ( Xorp2 )\n# 920 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"z3/z3Parser.mly\"\n                                                           ( Xorn1 )\n# 926 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"z3/z3Parser.mly\"\n                                                           ( Xorn2 )\n# 932 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"z3/z3Parser.mly\"\n                                                           ( Impp  )\n# 938 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"z3/z3Parser.mly\"\n                                                           ( Impn1 )\n# 944 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"z3/z3Parser.mly\"\n                                                           ( Impn2 )\n# 950 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"z3/z3Parser.mly\"\n                                                           ( Equp1 )\n# 956 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"z3/z3Parser.mly\"\n                                                           ( Equp2 )\n# 962 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"z3/z3Parser.mly\"\n                                                           ( Equn1 )\n# 968 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"z3/z3Parser.mly\"\n                                                           ( Equn2 )\n# 974 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"z3/z3Parser.mly\"\n                                                           ( Itep1 )\n# 980 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"z3/z3Parser.mly\"\n                                                           ( Itep2 )\n# 986 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"z3/z3Parser.mly\"\n                                                           ( Iten1 )\n# 992 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"z3/z3Parser.mly\"\n                                                           ( Iten2 )\n# 998 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"z3/z3Parser.mly\"\n                                                           ( Eqre  )\n# 1004 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"z3/z3Parser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"z3/z3Parser.mly\"\n                                                           ( Eqco  )\n# 1016 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"z3/z3Parser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"z3/z3Parser.mly\"\n                                                           ( Dlge  )\n# 1028 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"z3/z3Parser.mly\"\n                                                           ( Lage  )\n# 1034 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"z3/z3Parser.mly\"\n                                                           ( Lata  )\n# 1040 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"z3/z3Parser.mly\"\n                                                           ( Dlde  )\n# 1046 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"z3/z3Parser.mly\"\n                                                           ( Lade  )\n# 1052 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"z3/z3Parser.mly\"\n                                                           ( Eins  )\n# 1058 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"z3/z3Parser.mly\"\n                                                           ( Skea  )\n# 1064 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"z3/z3Parser.mly\"\n                                                           ( Skaa  )\n# 1070 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"z3/z3Parser.mly\"\n                                                           ( Qnts  )\n# 1076 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"z3/z3Parser.mly\"\n                                                           ( Qntm  )\n# 1082 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"z3/z3Parser.mly\"\n                                                           ( Reso  )\n# 1088 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"z3/z3Parser.mly\"\n                                                           ( Weak  )\n# 1094 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"z3/z3Parser.mly\"\n                                                           ( And   )\n# 1100 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"z3/z3Parser.mly\"\n                                                           ( Nor   )\n# 1106 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"z3/z3Parser.mly\"\n                                                           ( Or    )\n# 1112 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"z3/z3Parser.mly\"\n                                                           ( Nand  )\n# 1118 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"z3/z3Parser.mly\"\n                                                           ( Xor1  )\n# 1124 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"z3/z3Parser.mly\"\n                                                           ( Xor2  )\n# 1130 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"z3/z3Parser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"z3/z3Parser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"z3/z3Parser.mly\"\n                                                           ( Imp   )\n# 1148 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"z3/z3Parser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"z3/z3Parser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"z3/z3Parser.mly\"\n                                                           ( Equ1  )\n# 1166 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"z3/z3Parser.mly\"\n                                                           ( Equ2  )\n# 1172 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"z3/z3Parser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"z3/z3Parser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"z3/z3Parser.mly\"\n                                                           ( Ite1  )\n# 1190 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"z3/z3Parser.mly\"\n                                                           ( Ite2  )\n# 1196 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"z3/z3Parser.mly\"\n                                                           ( Nite1 )\n# 1202 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"z3/z3Parser.mly\"\n                                                           ( Nite2 )\n# 1208 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"z3/z3Parser.mly\"\n                                                           ( Tpal  )\n# 1214 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"z3/z3Parser.mly\"\n                                                           ( Tlap  )\n# 1220 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"z3/z3Parser.mly\"\n                                                           ( Tple  )\n# 1226 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"z3/z3Parser.mly\"\n                                                           ( Tpne  )\n# 1232 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"z3/z3Parser.mly\"\n                                                           ( Tpde  )\n# 1238 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"z3/z3Parser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"z3/z3Parser.mly\"\n                                                           ( Tpie  )\n# 1250 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"z3/z3Parser.mly\"\n                                                           ( Tpma  )\n# 1256 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"z3/z3Parser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"z3/z3Parser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"z3/z3Parser.mly\"\n                                                           ( Tppp  )\n# 1274 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"z3/z3Parser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"z3/z3Parser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"z3/z3Parser.mly\"\n                                                           ( Subp  )\n# 1292 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"z3/z3Parser.mly\"\n                                                           ( Flat  )\n# 1298 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"z3/z3Parser.mly\"\n                                                           ( Hole  )\n# 1304 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"z3/z3Parser.mly\"\n                                                           ( Bbva  )\n# 1310 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"z3/z3Parser.mly\"\n                                                           ( Bbconst )\n# 1316 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"z3/z3Parser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"z3/z3Parser.mly\"\n                                                           ( Bbdis )\n# 1328 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"z3/z3Parser.mly\"\n                                                           ( Bbop  )\n# 1334 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"z3/z3Parser.mly\"\n                                                           ( Bbadd )\n# 1340 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"z3/z3Parser.mly\"\n                                                           ( Bbmul )\n# 1346 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"z3/z3Parser.mly\"\n                                                           ( Bbult )\n# 1352 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"z3/z3Parser.mly\"\n                                                           ( Bbslt )\n# 1358 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"z3/z3Parser.mly\"\n                                                           ( Bbnot )\n# 1364 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"z3/z3Parser.mly\"\n                                                           ( Bbneg )\n# 1370 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"z3/z3Parser.mly\"\n                                                           ( Bbconc )\n# 1376 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"z3/z3Parser.mly\"\n                                                           ( Bbextr )\n# 1382 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"z3/z3Parser.mly\"\n                                                           ( Bbzext )\n# 1388 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"z3/z3Parser.mly\"\n                                                           ( Bbsext )\n# 1394 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"z3/z3Parser.mly\"\n                                                           ( Bbshl )\n# 1400 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"z3/z3Parser.mly\"\n                                                           ( Bbshr )\n# 1406 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"z3/z3Parser.mly\"\n                                                           ( Row1  )\n# 1412 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"z3/z3Parser.mly\"\n                                                           ( Row2  )\n# 1418 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"z3/z3Parser.mly\"\n                                                           ( Exte  )\n# 1424 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"z3/z3Parser.mly\"\n                                                           ( [] )\n# 1430 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"z3/z3Parser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 1444 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"z3/z3Parser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"z3/z3Parser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"z3/z3Parser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"z3/z3Parser.mly\"\n                                             ( _1 )\n# 1480 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"z3/z3Parser.mly\"\n                                       ( _1 )\n# 1487 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"z3/z3Parser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"z3/z3Parser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"z3/z3Parser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"z3/z3Parser.mly\"\n                 ( TZ )\n# 1557 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"z3/z3Parser.mly\"\n                  ( Tbool )\n# 1563 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"z3/z3Parser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"z3/z3Parser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"z3/z3Parser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"z3/z3Parser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"z3/z3Parser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"z3/z3Parser.mly\"\n                                                           ( _2 )\n# 1602 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1656 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"z3/z3Parser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"z3/z3Parser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"z3/z3Parser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"z3/z3Parser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"z3/z3Parser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"z3/z3Parser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"z3/z3Parser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"z3/z3Parser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1993 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"z3/z3Parser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"z3/z3Parser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 2039 \"z3/z3Parser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 2046 \"z3/z3Parser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"z3/z3Parser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"z3/z3Parser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml","version":7},"contentChanges":[{"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"z3/z3Parser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open ZSyntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"z3/z3Parser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"z3/z3Parser.mly\"\n                                                           ( raise Sat )\n# 815 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"z3/z3Parser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"z3/z3Parser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"z3/z3Parser.mly\"\n                                                           ( Tpbr  )\n# 860 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"z3/z3Parser.mly\"\n                                                           ( Inpu  )\n# 866 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"z3/z3Parser.mly\"\n                                                           ( Deep  )\n# 872 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"z3/z3Parser.mly\"\n                                                           ( True  )\n# 878 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"z3/z3Parser.mly\"\n                                                           ( Fals  )\n# 884 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"z3/z3Parser.mly\"\n                                                           ( Andp  )\n# 890 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"z3/z3Parser.mly\"\n                                                           ( Andn  )\n# 896 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"z3/z3Parser.mly\"\n                                                           ( Orp   )\n# 902 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"z3/z3Parser.mly\"\n                                                           ( Orn   )\n# 908 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"z3/z3Parser.mly\"\n                                                           ( Xorp1 )\n# 914 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"z3/z3Parser.mly\"\n                                                           ( Xorp2 )\n# 920 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"z3/z3Parser.mly\"\n                                                           ( Xorn1 )\n# 926 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"z3/z3Parser.mly\"\n                                                           ( Xorn2 )\n# 932 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"z3/z3Parser.mly\"\n                                                           ( Impp  )\n# 938 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"z3/z3Parser.mly\"\n                                                           ( Impn1 )\n# 944 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"z3/z3Parser.mly\"\n                                                           ( Impn2 )\n# 950 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"z3/z3Parser.mly\"\n                                                           ( Equp1 )\n# 956 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"z3/z3Parser.mly\"\n                                                           ( Equp2 )\n# 962 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"z3/z3Parser.mly\"\n                                                           ( Equn1 )\n# 968 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"z3/z3Parser.mly\"\n                                                           ( Equn2 )\n# 974 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"z3/z3Parser.mly\"\n                                                           ( Itep1 )\n# 980 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"z3/z3Parser.mly\"\n                                                           ( Itep2 )\n# 986 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"z3/z3Parser.mly\"\n                                                           ( Iten1 )\n# 992 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"z3/z3Parser.mly\"\n                                                           ( Iten2 )\n# 998 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"z3/z3Parser.mly\"\n                                                           ( Eqre  )\n# 1004 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"z3/z3Parser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"z3/z3Parser.mly\"\n                                                           ( Eqco  )\n# 1016 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"z3/z3Parser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"z3/z3Parser.mly\"\n                                                           ( Dlge  )\n# 1028 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"z3/z3Parser.mly\"\n                                                           ( Lage  )\n# 1034 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"z3/z3Parser.mly\"\n                                                           ( Lata  )\n# 1040 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"z3/z3Parser.mly\"\n                                                           ( Dlde  )\n# 1046 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"z3/z3Parser.mly\"\n                                                           ( Lade  )\n# 1052 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"z3/z3Parser.mly\"\n                                                           ( Eins  )\n# 1058 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"z3/z3Parser.mly\"\n                                                           ( Skea  )\n# 1064 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"z3/z3Parser.mly\"\n                                                           ( Skaa  )\n# 1070 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"z3/z3Parser.mly\"\n                                                           ( Qnts  )\n# 1076 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"z3/z3Parser.mly\"\n                                                           ( Qntm  )\n# 1082 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"z3/z3Parser.mly\"\n                                                           ( Reso  )\n# 1088 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"z3/z3Parser.mly\"\n                                                           ( Weak  )\n# 1094 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"z3/z3Parser.mly\"\n                                                           ( And   )\n# 1100 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"z3/z3Parser.mly\"\n                                                           ( Nor   )\n# 1106 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"z3/z3Parser.mly\"\n                                                           ( Or    )\n# 1112 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"z3/z3Parser.mly\"\n                                                           ( Nand  )\n# 1118 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"z3/z3Parser.mly\"\n                                                           ( Xor1  )\n# 1124 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"z3/z3Parser.mly\"\n                                                           ( Xor2  )\n# 1130 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"z3/z3Parser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"z3/z3Parser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"z3/z3Parser.mly\"\n                                                           ( Imp   )\n# 1148 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"z3/z3Parser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"z3/z3Parser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"z3/z3Parser.mly\"\n                                                           ( Equ1  )\n# 1166 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"z3/z3Parser.mly\"\n                                                           ( Equ2  )\n# 1172 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"z3/z3Parser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"z3/z3Parser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"z3/z3Parser.mly\"\n                                                           ( Ite1  )\n# 1190 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"z3/z3Parser.mly\"\n                                                           ( Ite2  )\n# 1196 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"z3/z3Parser.mly\"\n                                                           ( Nite1 )\n# 1202 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"z3/z3Parser.mly\"\n                                                           ( Nite2 )\n# 1208 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"z3/z3Parser.mly\"\n                                                           ( Tpal  )\n# 1214 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"z3/z3Parser.mly\"\n                                                           ( Tlap  )\n# 1220 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"z3/z3Parser.mly\"\n                                                           ( Tple  )\n# 1226 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"z3/z3Parser.mly\"\n                                                           ( Tpne  )\n# 1232 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"z3/z3Parser.mly\"\n                                                           ( Tpde  )\n# 1238 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"z3/z3Parser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"z3/z3Parser.mly\"\n                                                           ( Tpie  )\n# 1250 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"z3/z3Parser.mly\"\n                                                           ( Tpma  )\n# 1256 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"z3/z3Parser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"z3/z3Parser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"z3/z3Parser.mly\"\n                                                           ( Tppp  )\n# 1274 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"z3/z3Parser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"z3/z3Parser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"z3/z3Parser.mly\"\n                                                           ( Subp  )\n# 1292 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"z3/z3Parser.mly\"\n                                                           ( Flat  )\n# 1298 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"z3/z3Parser.mly\"\n                                                           ( Hole  )\n# 1304 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"z3/z3Parser.mly\"\n                                                           ( Bbva  )\n# 1310 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"z3/z3Parser.mly\"\n                                                           ( Bbconst )\n# 1316 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"z3/z3Parser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"z3/z3Parser.mly\"\n                                                           ( Bbdis )\n# 1328 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"z3/z3Parser.mly\"\n                                                           ( Bbop  )\n# 1334 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"z3/z3Parser.mly\"\n                                                           ( Bbadd )\n# 1340 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"z3/z3Parser.mly\"\n                                                           ( Bbmul )\n# 1346 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"z3/z3Parser.mly\"\n                                                           ( Bbult )\n# 1352 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"z3/z3Parser.mly\"\n                                                           ( Bbslt )\n# 1358 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"z3/z3Parser.mly\"\n                                                           ( Bbnot )\n# 1364 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"z3/z3Parser.mly\"\n                                                           ( Bbneg )\n# 1370 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"z3/z3Parser.mly\"\n                                                           ( Bbconc )\n# 1376 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"z3/z3Parser.mly\"\n                                                           ( Bbextr )\n# 1382 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"z3/z3Parser.mly\"\n                                                           ( Bbzext )\n# 1388 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"z3/z3Parser.mly\"\n                                                           ( Bbsext )\n# 1394 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"z3/z3Parser.mly\"\n                                                           ( Bbshl )\n# 1400 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"z3/z3Parser.mly\"\n                                                           ( Bbshr )\n# 1406 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"z3/z3Parser.mly\"\n                                                           ( Row1  )\n# 1412 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"z3/z3Parser.mly\"\n                                                           ( Row2  )\n# 1418 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"z3/z3Parser.mly\"\n                                                           ( Exte  )\n# 1424 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"z3/z3Parser.mly\"\n                                                           ( [] )\n# 1430 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"z3/z3Parser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 1444 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"z3/z3Parser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"z3/z3Parser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"z3/z3Parser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"z3/z3Parser.mly\"\n                                             ( _1 )\n# 1480 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"z3/z3Parser.mly\"\n                                       ( _1 )\n# 1487 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"z3/z3Parser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"z3/z3Parser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"z3/z3Parser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"z3/z3Parser.mly\"\n                 ( TZ )\n# 1557 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"z3/z3Parser.mly\"\n                  ( Tbool )\n# 1563 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"z3/z3Parser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"z3/z3Parser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"z3/z3Parser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"z3/z3Parser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"z3/z3Parser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"z3/z3Parser.mly\"\n                                                           ( _2 )\n# 1602 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1656 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"z3/z3Parser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"z3/z3Parser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"z3/z3Parser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"z3/z3Parser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"z3/z3Parser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"z3/z3Parser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"z3/z3Parser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"z3/z3Parser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1993 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"z3/z3Parser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"z3/z3Parser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 2039 \"z3/z3Parser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 2046 \"z3/z3Parser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"z3/z3Parser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"z3/z3Parser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1292,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1292, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1293,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":171,"character":8},"end":{"line":171,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1293, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1294,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1294, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml","version":8},"contentChanges":[{"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"z3/z3Parser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open Z3Syntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"z3/z3Parser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"z3/z3Parser.mly\"\n                                                           ( raise Sat )\n# 815 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"z3/z3Parser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"z3/z3Parser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"z3/z3Parser.mly\"\n                                                           ( Tpbr  )\n# 860 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"z3/z3Parser.mly\"\n                                                           ( Inpu  )\n# 866 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"z3/z3Parser.mly\"\n                                                           ( Deep  )\n# 872 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"z3/z3Parser.mly\"\n                                                           ( True  )\n# 878 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"z3/z3Parser.mly\"\n                                                           ( Fals  )\n# 884 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"z3/z3Parser.mly\"\n                                                           ( Andp  )\n# 890 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"z3/z3Parser.mly\"\n                                                           ( Andn  )\n# 896 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"z3/z3Parser.mly\"\n                                                           ( Orp   )\n# 902 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"z3/z3Parser.mly\"\n                                                           ( Orn   )\n# 908 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"z3/z3Parser.mly\"\n                                                           ( Xorp1 )\n# 914 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"z3/z3Parser.mly\"\n                                                           ( Xorp2 )\n# 920 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"z3/z3Parser.mly\"\n                                                           ( Xorn1 )\n# 926 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"z3/z3Parser.mly\"\n                                                           ( Xorn2 )\n# 932 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"z3/z3Parser.mly\"\n                                                           ( Impp  )\n# 938 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"z3/z3Parser.mly\"\n                                                           ( Impn1 )\n# 944 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"z3/z3Parser.mly\"\n                                                           ( Impn2 )\n# 950 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"z3/z3Parser.mly\"\n                                                           ( Equp1 )\n# 956 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"z3/z3Parser.mly\"\n                                                           ( Equp2 )\n# 962 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"z3/z3Parser.mly\"\n                                                           ( Equn1 )\n# 968 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"z3/z3Parser.mly\"\n                                                           ( Equn2 )\n# 974 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"z3/z3Parser.mly\"\n                                                           ( Itep1 )\n# 980 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"z3/z3Parser.mly\"\n                                                           ( Itep2 )\n# 986 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"z3/z3Parser.mly\"\n                                                           ( Iten1 )\n# 992 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"z3/z3Parser.mly\"\n                                                           ( Iten2 )\n# 998 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"z3/z3Parser.mly\"\n                                                           ( Eqre  )\n# 1004 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"z3/z3Parser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"z3/z3Parser.mly\"\n                                                           ( Eqco  )\n# 1016 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"z3/z3Parser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"z3/z3Parser.mly\"\n                                                           ( Dlge  )\n# 1028 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"z3/z3Parser.mly\"\n                                                           ( Lage  )\n# 1034 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"z3/z3Parser.mly\"\n                                                           ( Lata  )\n# 1040 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"z3/z3Parser.mly\"\n                                                           ( Dlde  )\n# 1046 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"z3/z3Parser.mly\"\n                                                           ( Lade  )\n# 1052 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"z3/z3Parser.mly\"\n                                                           ( Eins  )\n# 1058 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"z3/z3Parser.mly\"\n                                                           ( Skea  )\n# 1064 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"z3/z3Parser.mly\"\n                                                           ( Skaa  )\n# 1070 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"z3/z3Parser.mly\"\n                                                           ( Qnts  )\n# 1076 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"z3/z3Parser.mly\"\n                                                           ( Qntm  )\n# 1082 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"z3/z3Parser.mly\"\n                                                           ( Reso  )\n# 1088 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"z3/z3Parser.mly\"\n                                                           ( Weak  )\n# 1094 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"z3/z3Parser.mly\"\n                                                           ( And   )\n# 1100 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"z3/z3Parser.mly\"\n                                                           ( Nor   )\n# 1106 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"z3/z3Parser.mly\"\n                                                           ( Or    )\n# 1112 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"z3/z3Parser.mly\"\n                                                           ( Nand  )\n# 1118 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"z3/z3Parser.mly\"\n                                                           ( Xor1  )\n# 1124 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"z3/z3Parser.mly\"\n                                                           ( Xor2  )\n# 1130 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"z3/z3Parser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"z3/z3Parser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"z3/z3Parser.mly\"\n                                                           ( Imp   )\n# 1148 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"z3/z3Parser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"z3/z3Parser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"z3/z3Parser.mly\"\n                                                           ( Equ1  )\n# 1166 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"z3/z3Parser.mly\"\n                                                           ( Equ2  )\n# 1172 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"z3/z3Parser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"z3/z3Parser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"z3/z3Parser.mly\"\n                                                           ( Ite1  )\n# 1190 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"z3/z3Parser.mly\"\n                                                           ( Ite2  )\n# 1196 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"z3/z3Parser.mly\"\n                                                           ( Nite1 )\n# 1202 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"z3/z3Parser.mly\"\n                                                           ( Nite2 )\n# 1208 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"z3/z3Parser.mly\"\n                                                           ( Tpal  )\n# 1214 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"z3/z3Parser.mly\"\n                                                           ( Tlap  )\n# 1220 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"z3/z3Parser.mly\"\n                                                           ( Tple  )\n# 1226 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"z3/z3Parser.mly\"\n                                                           ( Tpne  )\n# 1232 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"z3/z3Parser.mly\"\n                                                           ( Tpde  )\n# 1238 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"z3/z3Parser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"z3/z3Parser.mly\"\n                                                           ( Tpie  )\n# 1250 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"z3/z3Parser.mly\"\n                                                           ( Tpma  )\n# 1256 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"z3/z3Parser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"z3/z3Parser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"z3/z3Parser.mly\"\n                                                           ( Tppp  )\n# 1274 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"z3/z3Parser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"z3/z3Parser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"z3/z3Parser.mly\"\n                                                           ( Subp  )\n# 1292 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"z3/z3Parser.mly\"\n                                                           ( Flat  )\n# 1298 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"z3/z3Parser.mly\"\n                                                           ( Hole  )\n# 1304 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"z3/z3Parser.mly\"\n                                                           ( Bbva  )\n# 1310 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"z3/z3Parser.mly\"\n                                                           ( Bbconst )\n# 1316 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"z3/z3Parser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"z3/z3Parser.mly\"\n                                                           ( Bbdis )\n# 1328 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"z3/z3Parser.mly\"\n                                                           ( Bbop  )\n# 1334 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"z3/z3Parser.mly\"\n                                                           ( Bbadd )\n# 1340 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"z3/z3Parser.mly\"\n                                                           ( Bbmul )\n# 1346 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"z3/z3Parser.mly\"\n                                                           ( Bbult )\n# 1352 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"z3/z3Parser.mly\"\n                                                           ( Bbslt )\n# 1358 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"z3/z3Parser.mly\"\n                                                           ( Bbnot )\n# 1364 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"z3/z3Parser.mly\"\n                                                           ( Bbneg )\n# 1370 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"z3/z3Parser.mly\"\n                                                           ( Bbconc )\n# 1376 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"z3/z3Parser.mly\"\n                                                           ( Bbextr )\n# 1382 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"z3/z3Parser.mly\"\n                                                           ( Bbzext )\n# 1388 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"z3/z3Parser.mly\"\n                                                           ( Bbsext )\n# 1394 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"z3/z3Parser.mly\"\n                                                           ( Bbshl )\n# 1400 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"z3/z3Parser.mly\"\n                                                           ( Bbshr )\n# 1406 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"z3/z3Parser.mly\"\n                                                           ( Row1  )\n# 1412 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"z3/z3Parser.mly\"\n                                                           ( Row2  )\n# 1418 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"z3/z3Parser.mly\"\n                                                           ( Exte  )\n# 1424 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"z3/z3Parser.mly\"\n                                                           ( [] )\n# 1430 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"z3/z3Parser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 1444 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"z3/z3Parser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"z3/z3Parser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"z3/z3Parser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"z3/z3Parser.mly\"\n                                             ( _1 )\n# 1480 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"z3/z3Parser.mly\"\n                                       ( _1 )\n# 1487 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"z3/z3Parser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"z3/z3Parser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"z3/z3Parser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"z3/z3Parser.mly\"\n                 ( TZ )\n# 1557 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"z3/z3Parser.mly\"\n                  ( Tbool )\n# 1563 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"z3/z3Parser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"z3/z3Parser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"z3/z3Parser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"z3/z3Parser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"z3/z3Parser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"z3/z3Parser.mly\"\n                                                           ( _2 )\n# 1602 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1656 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"z3/z3Parser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"z3/z3Parser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"z3/z3Parser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"z3/z3Parser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"z3/z3Parser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"z3/z3Parser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"z3/z3Parser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"z3/z3Parser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1993 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"z3/z3Parser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"z3/z3Parser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 2039 \"z3/z3Parser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 2046 \"z3/z3Parser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"z3/z3Parser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"z3/z3Parser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1295,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1295, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1296,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":171,"character":9},"end":{"line":171,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1296, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1297,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1297, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml","version":8},"contentChanges":[{"text":"type token =\n  | EOL\n  | SAT\n  | COLON\n  | LPAR\n  | RPAR\n  | LBRACKET\n  | RBRACKET\n  | NOT\n  | XOR\n  | ITE\n  | EQ\n  | LT\n  | LEQ\n  | GT\n  | GEQ\n  | PLUS\n  | MINUS\n  | MULT\n  | OPP\n  | LET\n  | DIST\n  | BBT\n  | BITOF\n  | BVAND\n  | BVOR\n  | BVXOR\n  | BVADD\n  | BVMUL\n  | BVULT\n  | BVSLT\n  | BVULE\n  | BVSLE\n  | BVCONC\n  | BVEXTR\n  | BVZEXT\n  | BVSEXT\n  | BVNOT\n  | BVNEG\n  | SELECT\n  | STORE\n  | DIFF\n  | BVSHL\n  | BVSHR\n  | TBOOL\n  | TINT\n  | TINDEX of (int)\n  | INPU\n  | DEEP\n  | TRUE\n  | FALS\n  | ANDP\n  | ANDN\n  | ORP\n  | ORN\n  | XORP1\n  | XORP2\n  | XORN1\n  | XORN2\n  | IMPP\n  | IMPN1\n  | IMPN2\n  | EQUP1\n  | EQUP2\n  | EQUN1\n  | EQUN2\n  | ITEP1\n  | ITEP2\n  | ITEN1\n  | ITEN2\n  | EQRE\n  | EQTR\n  | EQCO\n  | EQCP\n  | DLGE\n  | LAGE\n  | LATA\n  | DLDE\n  | LADE\n  | FINS\n  | EINS\n  | SKEA\n  | SKAA\n  | QNTS\n  | QNTM\n  | RESO\n  | WEAK\n  | AND\n  | NOR\n  | OR\n  | NAND\n  | XOR1\n  | XOR2\n  | NXOR1\n  | NXOR2\n  | IMP\n  | NIMP1\n  | NIMP2\n  | EQU1\n  | EQU2\n  | NEQU1\n  | NEQU2\n  | ITE1\n  | ITE2\n  | NITE1\n  | NITE2\n  | TPAL\n  | TLAP\n  | TPLE\n  | TPNE\n  | TPDE\n  | TPSA\n  | TPIE\n  | TPMA\n  | TPBR\n  | TPBE\n  | TPSC\n  | TPPP\n  | TPQT\n  | TPQS\n  | TPSK\n  | SUBP\n  | FLAT\n  | HOLE\n  | FORALL\n  | BBVA\n  | BBCONST\n  | BBEXTR\n  | BBZEXT\n  | BBSEXT\n  | BBEQ\n  | BBDIS\n  | BBOP\n  | BBADD\n  | BBMUL\n  | BBULT\n  | BBSLT\n  | BBNOT\n  | BBNEG\n  | BBCONC\n  | ROW1\n  | ROW2\n  | EXTE\n  | BBSHL\n  | BBSHR\n  | INT of (int)\n  | SHARPINT of (int)\n  | BIGINT of (Big_int.big_int)\n  | VAR of (string)\n  | BINDVAR of (string)\n  | ATVAR of (string)\n  | BITV of (string)\n\nopen Parsing;;\nlet _ = parse_error;;\n# 2 \"z3/z3Parser.mly\"\n(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n  open SmtBtype\n  open SmtAtom\n  open SmtForm\n  open Z3Syntax\n\n\n\n  let parse_bv s =\n    let l = ref [] in\n    for i = 2 to String.length s - 1 do\n      match s.[i] with\n      | '0' -> l := false :: !l\n      | '1' -> l := true :: !l\n      | _ -> assert false\n    done;\n    !l\n\n# 187 \"z3/z3Parser.ml\"\nlet yytransl_const = [|\n  257 (* EOL *);\n  258 (* SAT *);\n  259 (* COLON *);\n  260 (* LPAR *);\n  261 (* RPAR *);\n  262 (* LBRACKET *);\n  263 (* RBRACKET *);\n  264 (* NOT *);\n  265 (* XOR *);\n  266 (* ITE *);\n  267 (* EQ *);\n  268 (* LT *);\n  269 (* LEQ *);\n  270 (* GT *);\n  271 (* GEQ *);\n  272 (* PLUS *);\n  273 (* MINUS *);\n  274 (* MULT *);\n  275 (* OPP *);\n  276 (* LET *);\n  277 (* DIST *);\n  278 (* BBT *);\n  279 (* BITOF *);\n  280 (* BVAND *);\n  281 (* BVOR *);\n  282 (* BVXOR *);\n  283 (* BVADD *);\n  284 (* BVMUL *);\n  285 (* BVULT *);\n  286 (* BVSLT *);\n  287 (* BVULE *);\n  288 (* BVSLE *);\n  289 (* BVCONC *);\n  290 (* BVEXTR *);\n  291 (* BVZEXT *);\n  292 (* BVSEXT *);\n  293 (* BVNOT *);\n  294 (* BVNEG *);\n  295 (* SELECT *);\n  296 (* STORE *);\n  297 (* DIFF *);\n  298 (* BVSHL *);\n  299 (* BVSHR *);\n  300 (* TBOOL *);\n  301 (* TINT *);\n  303 (* INPU *);\n  304 (* DEEP *);\n  305 (* TRUE *);\n  306 (* FALS *);\n  307 (* ANDP *);\n  308 (* ANDN *);\n  309 (* ORP *);\n  310 (* ORN *);\n  311 (* XORP1 *);\n  312 (* XORP2 *);\n  313 (* XORN1 *);\n  314 (* XORN2 *);\n  315 (* IMPP *);\n  316 (* IMPN1 *);\n  317 (* IMPN2 *);\n  318 (* EQUP1 *);\n  319 (* EQUP2 *);\n  320 (* EQUN1 *);\n  321 (* EQUN2 *);\n  322 (* ITEP1 *);\n  323 (* ITEP2 *);\n  324 (* ITEN1 *);\n  325 (* ITEN2 *);\n  326 (* EQRE *);\n  327 (* EQTR *);\n  328 (* EQCO *);\n  329 (* EQCP *);\n  330 (* DLGE *);\n  331 (* LAGE *);\n  332 (* LATA *);\n  333 (* DLDE *);\n  334 (* LADE *);\n  335 (* FINS *);\n  336 (* EINS *);\n  337 (* SKEA *);\n  338 (* SKAA *);\n  339 (* QNTS *);\n  340 (* QNTM *);\n  341 (* RESO *);\n  342 (* WEAK *);\n  343 (* AND *);\n  344 (* NOR *);\n  345 (* OR *);\n  346 (* NAND *);\n  347 (* XOR1 *);\n  348 (* XOR2 *);\n  349 (* NXOR1 *);\n  350 (* NXOR2 *);\n  351 (* IMP *);\n  352 (* NIMP1 *);\n  353 (* NIMP2 *);\n  354 (* EQU1 *);\n  355 (* EQU2 *);\n  356 (* NEQU1 *);\n  357 (* NEQU2 *);\n  358 (* ITE1 *);\n  359 (* ITE2 *);\n  360 (* NITE1 *);\n  361 (* NITE2 *);\n  362 (* TPAL *);\n  363 (* TLAP *);\n  364 (* TPLE *);\n  365 (* TPNE *);\n  366 (* TPDE *);\n  367 (* TPSA *);\n  368 (* TPIE *);\n  369 (* TPMA *);\n  370 (* TPBR *);\n  371 (* TPBE *);\n  372 (* TPSC *);\n  373 (* TPPP *);\n  374 (* TPQT *);\n  375 (* TPQS *);\n  376 (* TPSK *);\n  377 (* SUBP *);\n  378 (* FLAT *);\n  379 (* HOLE *);\n  380 (* FORALL *);\n  381 (* BBVA *);\n  382 (* BBCONST *);\n  383 (* BBEXTR *);\n  384 (* BBZEXT *);\n  385 (* BBSEXT *);\n  386 (* BBEQ *);\n  387 (* BBDIS *);\n  388 (* BBOP *);\n  389 (* BBADD *);\n  390 (* BBMUL *);\n  391 (* BBULT *);\n  392 (* BBSLT *);\n  393 (* BBNOT *);\n  394 (* BBNEG *);\n  395 (* BBCONC *);\n  396 (* ROW1 *);\n  397 (* ROW2 *);\n  398 (* EXTE *);\n  399 (* BBSHL *);\n  400 (* BBSHR *);\n    0|]\n\nlet yytransl_block = [|\n  302 (* TINDEX *);\n  401 (* INT *);\n  402 (* SHARPINT *);\n  403 (* BIGINT *);\n  404 (* VAR *);\n  405 (* BINDVAR *);\n  406 (* ATVAR *);\n  407 (* BITV *);\n    0|]\n\nlet yylhs = \"\\255\\255\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\003\\000\\003\\000\\007\\000\\007\\000\\\n\\006\\000\\006\\000\\009\\000\\010\\000\\010\\000\\008\\000\\008\\000\\008\\000\\\n\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\008\\000\\012\\000\\012\\000\\\n\\012\\000\\013\\000\\013\\000\\005\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\014\\000\\\n\\014\\000\\016\\000\\016\\000\\015\\000\\015\\000\\004\\000\\017\\000\\017\\000\\\n\\000\\000\"\n\nlet yylen = \"\\002\\000\\\n\\001\\000\\007\\000\\008\\000\\014\\000\\018\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\002\\000\\003\\000\\001\\000\\002\\000\\\n\\001\\000\\004\\000\\004\\000\\001\\000\\001\\000\\001\\000\\005\\000\\001\\000\\\n\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\001\\000\\\n\\001\\000\\004\\000\\005\\000\\005\\000\\003\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\\002\\000\\002\\000\\002\\000\\001\\000\\005\\000\\001\\000\\001\\000\\\n\\001\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\002\\000\\002\\000\\003\\000\\002\\000\\003\\000\\003\\000\\003\\000\\\n\\002\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\003\\000\\\n\\003\\000\\003\\000\\004\\000\\003\\000\\003\\000\\003\\000\\003\\000\\004\\000\\\n\\001\\000\\002\\000\\003\\000\\003\\000\\003\\000\\005\\000\\001\\000\\001\\000\\\n\\004\\000\\004\\000\\005\\000\\001\\000\\002\\000\\001\\000\\001\\000\\002\\000\\\n\\002\\000\"\n\nlet yydefred = \"\\000\\000\\\n\\000\\000\\000\\000\\001\\000\\000\\000\\185\\000\\000\\000\\000\\000\\007\\000\\\n\\008\\000\\009\\000\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\\n\\016\\000\\017\\000\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\\n\\024\\000\\025\\000\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\\n\\032\\000\\033\\000\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\000\\000\\\n\\039\\000\\040\\000\\041\\000\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\\n\\047\\000\\048\\000\\049\\000\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\\n\\055\\000\\056\\000\\057\\000\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\\n\\063\\000\\064\\000\\065\\000\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\\n\\071\\000\\072\\000\\006\\000\\073\\000\\074\\000\\075\\000\\000\\000\\076\\000\\\n\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\082\\000\\093\\000\\094\\000\\\n\\095\\000\\083\\000\\084\\000\\085\\000\\086\\000\\087\\000\\088\\000\\089\\000\\\n\\090\\000\\091\\000\\092\\000\\098\\000\\099\\000\\100\\000\\096\\000\\097\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\101\\000\\113\\000\\114\\000\\117\\000\\000\\000\\118\\000\\108\\000\\116\\000\\\n\\109\\000\\112\\000\\000\\000\\000\\000\\105\\000\\115\\000\\000\\000\\000\\000\\\n\\000\\000\\182\\000\\000\\000\\000\\000\\000\\000\\000\\000\\104\\000\\102\\000\\\n\\002\\000\\184\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\003\\000\\\n\\000\\000\\000\\000\\000\\000\\106\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\126\\000\\127\\000\\000\\000\\000\\000\\000\\000\\135\\000\\136\\000\\000\\000\\\n\\175\\000\\137\\000\\133\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\131\\000\\132\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\146\\000\\000\\000\\000\\000\\147\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\149\\000\\\n\\153\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\128\\000\\129\\000\\\n\\130\\000\\170\\000\\111\\000\\000\\000\\000\\000\\000\\000\\000\\000\\125\\000\\\n\\000\\000\\171\\000\\173\\000\\172\\000\\138\\000\\139\\000\\140\\000\\141\\000\\\n\\142\\000\\144\\000\\143\\000\\000\\000\\000\\000\\181\\000\\000\\000\\148\\000\\\n\\150\\000\\151\\000\\152\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\\n\\159\\000\\162\\000\\000\\000\\164\\000\\165\\000\\166\\000\\000\\000\\167\\000\\\n\\160\\000\\161\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\163\\000\\168\\000\\000\\000\\120\\000\\119\\000\\121\\000\\\n\\000\\000\\000\\000\\176\\000\\124\\000\\000\\000\\107\\000\\000\\000\\174\\000\\\n\\134\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\123\\000\\\n\\000\\000\\179\\000\\000\\000\\177\\000\\000\\000\\005\\000\"\n\nlet yydgoto = \"\\002\\000\\\n\\005\\000\\105\\000\\109\\000\\129\\000\\195\\000\\123\\000\\124\\000\\125\\000\\\n\\205\\000\\126\\000\\196\\000\\041\\001\\246\\000\\044\\001\\216\\000\\005\\001\\\n\\130\\000\"\n\nlet yysindex = \"\\001\\000\\\n\\002\\255\\000\\000\\000\\000\\048\\255\\000\\000\\001\\255\\056\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\051\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\057\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\062\\255\\162\\254\\174\\254\\045\\255\\254\\254\\067\\255\\071\\255\\068\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\072\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\052\\255\\073\\255\\000\\000\\000\\000\\076\\255\\190\\254\\\n\\075\\255\\000\\000\\077\\255\\078\\255\\052\\255\\079\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\084\\255\\000\\255\\222\\254\\086\\255\\253\\254\\000\\000\\\n\\089\\255\\092\\255\\093\\255\\000\\000\\253\\254\\052\\255\\052\\255\\059\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\095\\255\\004\\255\\004\\255\\208\\254\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\211\\254\\214\\254\\\n\\215\\254\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\000\\000\\000\\000\\052\\255\\052\\255\\052\\255\\000\\000\\000\\000\\004\\255\\\n\\000\\000\\000\\000\\000\\000\\105\\255\\103\\255\\108\\255\\109\\255\\110\\255\\\n\\000\\000\\000\\000\\114\\255\\059\\255\\052\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\113\\255\\004\\255\\000\\000\\\n\\107\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\\n\\004\\255\\004\\255\\004\\255\\004\\255\\231\\254\\004\\255\\004\\255\\000\\000\\\n\\000\\000\\004\\255\\004\\255\\004\\255\\004\\255\\004\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\233\\254\\168\\254\\119\\255\\236\\254\\000\\000\\\n\\052\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\234\\254\\121\\255\\000\\000\\052\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\004\\255\\000\\000\\000\\000\\000\\000\\004\\255\\000\\000\\\n\\000\\000\\000\\000\\124\\255\\013\\255\\069\\255\\125\\255\\126\\255\\069\\255\\\n\\004\\255\\127\\255\\000\\000\\000\\000\\052\\255\\000\\000\\000\\000\\000\\000\\\n\\128\\255\\120\\255\\000\\000\\000\\000\\131\\255\\000\\000\\130\\255\\000\\000\\\n\\000\\000\\132\\255\\108\\255\\052\\255\\000\\000\\113\\255\\133\\255\\000\\000\\\n\\134\\255\\000\\000\\135\\255\\000\\000\\140\\255\\000\\000\"\n\nlet yyrindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\038\\255\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\060\\255\\000\\000\\000\\000\\000\\000\\000\\000\\151\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\152\\255\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\153\\255\\000\\000\\000\\000\\000\\000\\154\\255\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\156\\255\\000\\000\\000\\000\\157\\255\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"\n\nlet yygindex = \"\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\251\\255\\123\\255\\174\\255\\069\\000\\\n\\215\\255\\175\\255\\016\\000\\000\\000\\115\\255\\136\\255\\112\\255\\116\\255\\\n\\039\\000\"\n\nlet yytablesize = 456\nlet yytable = \"\\142\\000\\\n\\149\\000\\001\\000\\127\\000\\003\\000\\007\\000\\150\\000\\151\\000\\152\\000\\\n\\153\\000\\154\\000\\155\\000\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\\n\\161\\000\\162\\000\\163\\000\\164\\000\\165\\000\\166\\000\\167\\000\\168\\000\\\n\\169\\000\\170\\000\\171\\000\\172\\000\\173\\000\\174\\000\\175\\000\\176\\000\\\n\\177\\000\\178\\000\\179\\000\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\\n\\135\\000\\110\\000\\110\\000\\110\\000\\110\\000\\185\\000\\186\\000\\242\\000\\\n\\112\\000\\113\\000\\006\\000\\110\\000\\114\\000\\115\\000\\106\\000\\112\\000\\\n\\038\\001\\039\\001\\040\\001\\119\\000\\107\\000\\121\\000\\203\\000\\111\\000\\\n\\103\\000\\108\\000\\103\\000\\201\\000\\202\\000\\131\\000\\006\\001\\252\\000\\\n\\042\\001\\132\\000\\134\\000\\133\\000\\137\\000\\136\\000\\128\\000\\139\\000\\\n\\140\\000\\141\\000\\143\\000\\187\\000\\144\\000\\188\\000\\110\\000\\110\\000\\\n\\145\\000\\146\\000\\148\\000\\189\\000\\197\\000\\114\\000\\115\\000\\198\\000\\\n\\218\\000\\199\\000\\214\\000\\229\\000\\114\\000\\115\\000\\230\\000\\231\\000\\\n\\239\\000\\240\\000\\241\\000\\114\\000\\115\\000\\243\\000\\244\\000\\245\\000\\\n\\007\\001\\247\\000\\248\\000\\031\\001\\004\\001\\114\\000\\115\\000\\019\\001\\\n\\146\\000\\249\\000\\027\\001\\029\\001\\030\\001\\033\\001\\032\\001\\052\\001\\\n\\037\\001\\045\\001\\046\\001\\053\\001\\051\\001\\049\\001\\054\\001\\147\\000\\\n\\055\\001\\059\\001\\060\\001\\061\\001\\062\\001\\190\\000\\128\\000\\191\\000\\\n\\192\\000\\193\\000\\004\\000\\194\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\183\\000\\169\\000\\145\\000\\180\\000\\050\\001\\\n\\122\\000\\178\\000\\251\\000\\028\\001\\200\\000\\056\\001\\138\\000\\047\\001\\\n\\000\\000\\058\\001\\000\\000\\000\\000\\000\\000\\000\\000\\057\\001\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\034\\001\\000\\000\\110\\000\\110\\000\\\n\\110\\000\\110\\000\\110\\000\\110\\000\\110\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\\n\\120\\000\\121\\000\\122\\000\\116\\000\\117\\000\\118\\000\\119\\000\\120\\000\\\n\\121\\000\\122\\000\\000\\000\\000\\000\\000\\000\\116\\000\\117\\000\\118\\000\\\n\\119\\000\\120\\000\\121\\000\\122\\000\\204\\000\\206\\000\\207\\000\\208\\000\\\n\\209\\000\\210\\000\\211\\000\\212\\000\\213\\000\\000\\000\\215\\000\\217\\000\\\n\\000\\000\\219\\000\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\\n\\226\\000\\227\\000\\228\\000\\000\\000\\000\\000\\000\\000\\232\\000\\233\\000\\\n\\234\\000\\235\\000\\236\\000\\237\\000\\238\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\250\\000\\000\\000\\253\\000\\254\\000\\255\\000\\000\\001\\001\\001\\002\\001\\\n\\003\\001\\000\\000\\000\\000\\215\\000\\000\\000\\000\\000\\008\\001\\009\\001\\\n\\010\\001\\011\\001\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\\n\\018\\001\\000\\000\\020\\001\\021\\001\\000\\000\\000\\000\\022\\001\\023\\001\\\n\\024\\001\\025\\001\\026\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\035\\001\\\n\\000\\000\\000\\000\\000\\000\\036\\001\\000\\000\\000\\000\\000\\000\\000\\000\\\n\\000\\000\\043\\001\\000\\000\\000\\000\\043\\001\\048\\001\\008\\000\\009\\000\\\n\\010\\000\\011\\000\\012\\000\\013\\000\\014\\000\\015\\000\\016\\000\\017\\000\\\n\\018\\000\\019\\000\\020\\000\\021\\000\\022\\000\\023\\000\\024\\000\\025\\000\\\n\\026\\000\\027\\000\\028\\000\\029\\000\\030\\000\\031\\000\\032\\000\\033\\000\\\n\\034\\000\\035\\000\\036\\000\\037\\000\\038\\000\\039\\000\\040\\000\\041\\000\\\n\\042\\000\\043\\000\\044\\000\\045\\000\\046\\000\\047\\000\\048\\000\\049\\000\\\n\\050\\000\\051\\000\\052\\000\\053\\000\\054\\000\\055\\000\\056\\000\\057\\000\\\n\\058\\000\\059\\000\\060\\000\\061\\000\\062\\000\\063\\000\\064\\000\\065\\000\\\n\\066\\000\\067\\000\\068\\000\\069\\000\\070\\000\\071\\000\\072\\000\\073\\000\\\n\\074\\000\\075\\000\\076\\000\\077\\000\\078\\000\\079\\000\\080\\000\\081\\000\\\n\\082\\000\\083\\000\\084\\000\\000\\000\\085\\000\\086\\000\\087\\000\\088\\000\\\n\\089\\000\\090\\000\\091\\000\\092\\000\\093\\000\\094\\000\\095\\000\\096\\000\\\n\\097\\000\\098\\000\\099\\000\\100\\000\\101\\000\\102\\000\\103\\000\\104\\000\"\n\nlet yycheck = \"\\133\\000\\\n\\004\\001\\001\\000\\005\\001\\002\\001\\004\\001\\009\\001\\010\\001\\011\\001\\\n\\012\\001\\013\\001\\014\\001\\015\\001\\016\\001\\017\\001\\018\\001\\019\\001\\\n\\020\\001\\021\\001\\022\\001\\023\\001\\024\\001\\025\\001\\026\\001\\027\\001\\\n\\028\\001\\029\\001\\030\\001\\031\\001\\032\\001\\033\\001\\034\\001\\035\\001\\\n\\036\\001\\037\\001\\038\\001\\039\\001\\040\\001\\041\\001\\042\\001\\043\\001\\\n\\123\\000\\004\\001\\005\\001\\006\\001\\007\\001\\049\\001\\050\\001\\192\\000\\\n\\004\\001\\005\\001\\003\\001\\146\\001\\049\\001\\050\\001\\004\\001\\004\\001\\\n\\044\\001\\045\\001\\046\\001\\148\\001\\004\\001\\150\\001\\004\\001\\146\\001\\\n\\005\\001\\004\\001\\007\\001\\150\\000\\151\\000\\003\\001\\215\\000\\205\\000\\\n\\004\\001\\003\\001\\003\\001\\008\\001\\001\\001\\005\\001\\145\\001\\005\\001\\\n\\004\\001\\004\\001\\004\\001\\087\\001\\001\\001\\089\\001\\049\\001\\050\\001\\\n\\089\\001\\124\\001\\005\\001\\095\\001\\004\\001\\049\\001\\050\\001\\004\\001\\\n\\145\\001\\005\\001\\004\\001\\145\\001\\049\\001\\050\\001\\145\\001\\145\\001\\\n\\187\\000\\188\\000\\189\\000\\049\\001\\050\\001\\005\\001\\008\\001\\004\\001\\\n\\006\\001\\005\\001\\005\\001\\249\\000\\004\\001\\049\\001\\050\\001\\145\\001\\\n\\124\\001\\008\\001\\146\\001\\005\\001\\145\\001\\005\\001\\149\\001\\008\\001\\\n\\005\\001\\005\\001\\005\\001\\001\\001\\005\\001\\007\\001\\005\\001\\141\\000\\\n\\005\\001\\005\\001\\005\\001\\005\\001\\001\\001\\145\\001\\145\\001\\147\\001\\\n\\148\\001\\149\\001\\145\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\005\\001\\005\\001\\005\\001\\005\\001\\037\\001\\\n\\005\\001\\005\\001\\204\\000\\245\\000\\149\\000\\051\\001\\128\\000\\032\\001\\\n\\255\\255\\054\\001\\255\\255\\255\\255\\255\\255\\255\\255\\052\\001\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\007\\001\\255\\255\\145\\001\\146\\001\\\n\\147\\001\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\\n\\149\\001\\150\\001\\151\\001\\145\\001\\146\\001\\147\\001\\148\\001\\149\\001\\\n\\150\\001\\151\\001\\255\\255\\255\\255\\255\\255\\145\\001\\146\\001\\147\\001\\\n\\148\\001\\149\\001\\150\\001\\151\\001\\152\\000\\153\\000\\154\\000\\155\\000\\\n\\156\\000\\157\\000\\158\\000\\159\\000\\160\\000\\255\\255\\162\\000\\163\\000\\\n\\255\\255\\165\\000\\166\\000\\167\\000\\168\\000\\169\\000\\170\\000\\171\\000\\\n\\172\\000\\173\\000\\174\\000\\255\\255\\255\\255\\255\\255\\178\\000\\179\\000\\\n\\180\\000\\181\\000\\182\\000\\183\\000\\184\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\192\\000\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\204\\000\\255\\255\\206\\000\\207\\000\\208\\000\\209\\000\\210\\000\\211\\000\\\n\\212\\000\\255\\255\\255\\255\\215\\000\\255\\255\\255\\255\\218\\000\\219\\000\\\n\\220\\000\\221\\000\\222\\000\\223\\000\\224\\000\\225\\000\\226\\000\\227\\000\\\n\\228\\000\\255\\255\\230\\000\\231\\000\\255\\255\\255\\255\\234\\000\\235\\000\\\n\\236\\000\\237\\000\\238\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\019\\001\\\n\\255\\255\\255\\255\\255\\255\\023\\001\\255\\255\\255\\255\\255\\255\\255\\255\\\n\\255\\255\\029\\001\\255\\255\\255\\255\\032\\001\\033\\001\\047\\001\\048\\001\\\n\\049\\001\\050\\001\\051\\001\\052\\001\\053\\001\\054\\001\\055\\001\\056\\001\\\n\\057\\001\\058\\001\\059\\001\\060\\001\\061\\001\\062\\001\\063\\001\\064\\001\\\n\\065\\001\\066\\001\\067\\001\\068\\001\\069\\001\\070\\001\\071\\001\\072\\001\\\n\\073\\001\\074\\001\\075\\001\\076\\001\\077\\001\\078\\001\\079\\001\\080\\001\\\n\\081\\001\\082\\001\\083\\001\\084\\001\\085\\001\\086\\001\\087\\001\\088\\001\\\n\\089\\001\\090\\001\\091\\001\\092\\001\\093\\001\\094\\001\\095\\001\\096\\001\\\n\\097\\001\\098\\001\\099\\001\\100\\001\\101\\001\\102\\001\\103\\001\\104\\001\\\n\\105\\001\\106\\001\\107\\001\\108\\001\\109\\001\\110\\001\\111\\001\\112\\001\\\n\\113\\001\\114\\001\\115\\001\\116\\001\\117\\001\\118\\001\\119\\001\\120\\001\\\n\\121\\001\\122\\001\\123\\001\\255\\255\\125\\001\\126\\001\\127\\001\\128\\001\\\n\\129\\001\\130\\001\\131\\001\\132\\001\\133\\001\\134\\001\\135\\001\\136\\001\\\n\\137\\001\\138\\001\\139\\001\\140\\001\\141\\001\\142\\001\\143\\001\\144\\001\"\n\nlet yynames_const = \"\\\n  EOL\\000\\\n  SAT\\000\\\n  COLON\\000\\\n  LPAR\\000\\\n  RPAR\\000\\\n  LBRACKET\\000\\\n  RBRACKET\\000\\\n  NOT\\000\\\n  XOR\\000\\\n  ITE\\000\\\n  EQ\\000\\\n  LT\\000\\\n  LEQ\\000\\\n  GT\\000\\\n  GEQ\\000\\\n  PLUS\\000\\\n  MINUS\\000\\\n  MULT\\000\\\n  OPP\\000\\\n  LET\\000\\\n  DIST\\000\\\n  BBT\\000\\\n  BITOF\\000\\\n  BVAND\\000\\\n  BVOR\\000\\\n  BVXOR\\000\\\n  BVADD\\000\\\n  BVMUL\\000\\\n  BVULT\\000\\\n  BVSLT\\000\\\n  BVULE\\000\\\n  BVSLE\\000\\\n  BVCONC\\000\\\n  BVEXTR\\000\\\n  BVZEXT\\000\\\n  BVSEXT\\000\\\n  BVNOT\\000\\\n  BVNEG\\000\\\n  SELECT\\000\\\n  STORE\\000\\\n  DIFF\\000\\\n  BVSHL\\000\\\n  BVSHR\\000\\\n  TBOOL\\000\\\n  TINT\\000\\\n  INPU\\000\\\n  DEEP\\000\\\n  TRUE\\000\\\n  FALS\\000\\\n  ANDP\\000\\\n  ANDN\\000\\\n  ORP\\000\\\n  ORN\\000\\\n  XORP1\\000\\\n  XORP2\\000\\\n  XORN1\\000\\\n  XORN2\\000\\\n  IMPP\\000\\\n  IMPN1\\000\\\n  IMPN2\\000\\\n  EQUP1\\000\\\n  EQUP2\\000\\\n  EQUN1\\000\\\n  EQUN2\\000\\\n  ITEP1\\000\\\n  ITEP2\\000\\\n  ITEN1\\000\\\n  ITEN2\\000\\\n  EQRE\\000\\\n  EQTR\\000\\\n  EQCO\\000\\\n  EQCP\\000\\\n  DLGE\\000\\\n  LAGE\\000\\\n  LATA\\000\\\n  DLDE\\000\\\n  LADE\\000\\\n  FINS\\000\\\n  EINS\\000\\\n  SKEA\\000\\\n  SKAA\\000\\\n  QNTS\\000\\\n  QNTM\\000\\\n  RESO\\000\\\n  WEAK\\000\\\n  AND\\000\\\n  NOR\\000\\\n  OR\\000\\\n  NAND\\000\\\n  XOR1\\000\\\n  XOR2\\000\\\n  NXOR1\\000\\\n  NXOR2\\000\\\n  IMP\\000\\\n  NIMP1\\000\\\n  NIMP2\\000\\\n  EQU1\\000\\\n  EQU2\\000\\\n  NEQU1\\000\\\n  NEQU2\\000\\\n  ITE1\\000\\\n  ITE2\\000\\\n  NITE1\\000\\\n  NITE2\\000\\\n  TPAL\\000\\\n  TLAP\\000\\\n  TPLE\\000\\\n  TPNE\\000\\\n  TPDE\\000\\\n  TPSA\\000\\\n  TPIE\\000\\\n  TPMA\\000\\\n  TPBR\\000\\\n  TPBE\\000\\\n  TPSC\\000\\\n  TPPP\\000\\\n  TPQT\\000\\\n  TPQS\\000\\\n  TPSK\\000\\\n  SUBP\\000\\\n  FLAT\\000\\\n  HOLE\\000\\\n  FORALL\\000\\\n  BBVA\\000\\\n  BBCONST\\000\\\n  BBEXTR\\000\\\n  BBZEXT\\000\\\n  BBSEXT\\000\\\n  BBEQ\\000\\\n  BBDIS\\000\\\n  BBOP\\000\\\n  BBADD\\000\\\n  BBMUL\\000\\\n  BBULT\\000\\\n  BBSLT\\000\\\n  BBNOT\\000\\\n  BBNEG\\000\\\n  BBCONC\\000\\\n  ROW1\\000\\\n  ROW2\\000\\\n  EXTE\\000\\\n  BBSHL\\000\\\n  BBSHR\\000\\\n  \"\n\nlet yynames_block = \"\\\n  TINDEX\\000\\\n  INT\\000\\\n  SHARPINT\\000\\\n  BIGINT\\000\\\n  VAR\\000\\\n  BINDVAR\\000\\\n  ATVAR\\000\\\n  BITV\\000\\\n  \"\n\nlet yyact = [|\n  (fun _ -> failwith \"parser\")\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 61 \"z3/z3Parser.mly\"\n                                                           ( raise Sat )\n# 815 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'clause) in\n    Obj.repr(\n# 62 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,[]) )\n# 824 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 7 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'typ) in\n    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'clause) in\n    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'clause_ids_params) in\n    Obj.repr(\n# 63 \"z3/z3Parser.mly\"\n                                                           ( mk_clause (_1,_4,_5,_6) )\n# 834 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 13 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 8 : int) in\n    let _9 = (Parsing.peek_val __caml_parser_env 5 : 'forall_decl) in\n    let _12 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    Obj.repr(\n# 64 \"z3/z3Parser.mly\"\n                                                                                    ( add_solver _6 _9; add_ref _6 _1; mk_clause (_1, Tpqt, [], [_12]) )\n# 844 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 17 : int) in\n    let _6 = (Parsing.peek_val __caml_parser_env 12 : int) in\n    let _12 = (Parsing.peek_val __caml_parser_env 6 : int) in\n    let _14 = (Parsing.peek_val __caml_parser_env 4 : 'lit) in\n    Obj.repr(\n# 66 \"z3/z3Parser.mly\"\n  ( mk_clause (_1, Fins, [snd _14], [get_ref _12]) )\n# 854 \"z3/z3Parser.ml\"\n               : int))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 70 \"z3/z3Parser.mly\"\n                                                           ( Tpbr  )\n# 860 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 71 \"z3/z3Parser.mly\"\n                                                           ( Inpu  )\n# 866 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 72 \"z3/z3Parser.mly\"\n                                                           ( Deep  )\n# 872 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 73 \"z3/z3Parser.mly\"\n                                                           ( True  )\n# 878 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 74 \"z3/z3Parser.mly\"\n                                                           ( Fals  )\n# 884 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 75 \"z3/z3Parser.mly\"\n                                                           ( Andp  )\n# 890 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 76 \"z3/z3Parser.mly\"\n                                                           ( Andn  )\n# 896 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 77 \"z3/z3Parser.mly\"\n                                                           ( Orp   )\n# 902 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 78 \"z3/z3Parser.mly\"\n                                                           ( Orn   )\n# 908 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 79 \"z3/z3Parser.mly\"\n                                                           ( Xorp1 )\n# 914 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 80 \"z3/z3Parser.mly\"\n                                                           ( Xorp2 )\n# 920 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 81 \"z3/z3Parser.mly\"\n                                                           ( Xorn1 )\n# 926 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 82 \"z3/z3Parser.mly\"\n                                                           ( Xorn2 )\n# 932 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 83 \"z3/z3Parser.mly\"\n                                                           ( Impp  )\n# 938 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 84 \"z3/z3Parser.mly\"\n                                                           ( Impn1 )\n# 944 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 85 \"z3/z3Parser.mly\"\n                                                           ( Impn2 )\n# 950 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 86 \"z3/z3Parser.mly\"\n                                                           ( Equp1 )\n# 956 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 87 \"z3/z3Parser.mly\"\n                                                           ( Equp2 )\n# 962 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 88 \"z3/z3Parser.mly\"\n                                                           ( Equn1 )\n# 968 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 89 \"z3/z3Parser.mly\"\n                                                           ( Equn2 )\n# 974 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 90 \"z3/z3Parser.mly\"\n                                                           ( Itep1 )\n# 980 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 91 \"z3/z3Parser.mly\"\n                                                           ( Itep2 )\n# 986 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 92 \"z3/z3Parser.mly\"\n                                                           ( Iten1 )\n# 992 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 93 \"z3/z3Parser.mly\"\n                                                           ( Iten2 )\n# 998 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 94 \"z3/z3Parser.mly\"\n                                                           ( Eqre  )\n# 1004 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 95 \"z3/z3Parser.mly\"\n                                                           ( Eqtr  )\n# 1010 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 96 \"z3/z3Parser.mly\"\n                                                           ( Eqco  )\n# 1016 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 97 \"z3/z3Parser.mly\"\n                                                           ( Eqcp  )\n# 1022 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 98 \"z3/z3Parser.mly\"\n                                                           ( Dlge  )\n# 1028 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 99 \"z3/z3Parser.mly\"\n                                                           ( Lage  )\n# 1034 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 100 \"z3/z3Parser.mly\"\n                                                           ( Lata  )\n# 1040 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 101 \"z3/z3Parser.mly\"\n                                                           ( Dlde  )\n# 1046 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 102 \"z3/z3Parser.mly\"\n                                                           ( Lade  )\n# 1052 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 103 \"z3/z3Parser.mly\"\n                                                           ( Eins  )\n# 1058 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 104 \"z3/z3Parser.mly\"\n                                                           ( Skea  )\n# 1064 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 105 \"z3/z3Parser.mly\"\n                                                           ( Skaa  )\n# 1070 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 106 \"z3/z3Parser.mly\"\n                                                           ( Qnts  )\n# 1076 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 107 \"z3/z3Parser.mly\"\n                                                           ( Qntm  )\n# 1082 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 108 \"z3/z3Parser.mly\"\n                                                           ( Reso  )\n# 1088 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 109 \"z3/z3Parser.mly\"\n                                                           ( Weak  )\n# 1094 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 110 \"z3/z3Parser.mly\"\n                                                           ( And   )\n# 1100 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 111 \"z3/z3Parser.mly\"\n                                                           ( Nor   )\n# 1106 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 112 \"z3/z3Parser.mly\"\n                                                           ( Or    )\n# 1112 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 113 \"z3/z3Parser.mly\"\n                                                           ( Nand  )\n# 1118 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 114 \"z3/z3Parser.mly\"\n                                                           ( Xor1  )\n# 1124 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 115 \"z3/z3Parser.mly\"\n                                                           ( Xor2  )\n# 1130 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 116 \"z3/z3Parser.mly\"\n                                                           ( Nxor1 )\n# 1136 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 117 \"z3/z3Parser.mly\"\n                                                           ( Nxor2 )\n# 1142 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 118 \"z3/z3Parser.mly\"\n                                                           ( Imp   )\n# 1148 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 119 \"z3/z3Parser.mly\"\n                                                           ( Nimp1 )\n# 1154 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 120 \"z3/z3Parser.mly\"\n                                                           ( Nimp2 )\n# 1160 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 121 \"z3/z3Parser.mly\"\n                                                           ( Equ1  )\n# 1166 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 122 \"z3/z3Parser.mly\"\n                                                           ( Equ2  )\n# 1172 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 123 \"z3/z3Parser.mly\"\n                                                           ( Nequ1 )\n# 1178 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 124 \"z3/z3Parser.mly\"\n                                                           ( Nequ2 )\n# 1184 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 125 \"z3/z3Parser.mly\"\n                                                           ( Ite1  )\n# 1190 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 126 \"z3/z3Parser.mly\"\n                                                           ( Ite2  )\n# 1196 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 127 \"z3/z3Parser.mly\"\n                                                           ( Nite1 )\n# 1202 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 128 \"z3/z3Parser.mly\"\n                                                           ( Nite2 )\n# 1208 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 129 \"z3/z3Parser.mly\"\n                                                           ( Tpal  )\n# 1214 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 130 \"z3/z3Parser.mly\"\n                                                           ( Tlap  )\n# 1220 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 131 \"z3/z3Parser.mly\"\n                                                           ( Tple  )\n# 1226 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 132 \"z3/z3Parser.mly\"\n                                                           ( Tpne  )\n# 1232 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 133 \"z3/z3Parser.mly\"\n                                                           ( Tpde  )\n# 1238 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 134 \"z3/z3Parser.mly\"\n                                                           ( Tpsa  )\n# 1244 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 135 \"z3/z3Parser.mly\"\n                                                           ( Tpie  )\n# 1250 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 136 \"z3/z3Parser.mly\"\n                                                           ( Tpma  )\n# 1256 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 137 \"z3/z3Parser.mly\"\n                                                           ( Tpbe  )\n# 1262 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 138 \"z3/z3Parser.mly\"\n                                                           ( Tpsc  )\n# 1268 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 139 \"z3/z3Parser.mly\"\n                                                           ( Tppp  )\n# 1274 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 140 \"z3/z3Parser.mly\"\n                                                           ( Tpqs  )\n# 1280 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 141 \"z3/z3Parser.mly\"\n                                                           ( Tpsk  )\n# 1286 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 142 \"z3/z3Parser.mly\"\n                                                           ( Subp  )\n# 1292 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 143 \"z3/z3Parser.mly\"\n                                                           ( Flat  )\n# 1298 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 144 \"z3/z3Parser.mly\"\n                                                           ( Hole  )\n# 1304 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 145 \"z3/z3Parser.mly\"\n                                                           ( Bbva  )\n# 1310 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 146 \"z3/z3Parser.mly\"\n                                                           ( Bbconst )\n# 1316 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 147 \"z3/z3Parser.mly\"\n                                                           ( Bbeq  )\n# 1322 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 148 \"z3/z3Parser.mly\"\n                                                           ( Bbdis )\n# 1328 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 149 \"z3/z3Parser.mly\"\n                                                           ( Bbop  )\n# 1334 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 150 \"z3/z3Parser.mly\"\n                                                           ( Bbadd )\n# 1340 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 151 \"z3/z3Parser.mly\"\n                                                           ( Bbmul )\n# 1346 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 152 \"z3/z3Parser.mly\"\n                                                           ( Bbult )\n# 1352 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 153 \"z3/z3Parser.mly\"\n                                                           ( Bbslt )\n# 1358 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 154 \"z3/z3Parser.mly\"\n                                                           ( Bbnot )\n# 1364 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 155 \"z3/z3Parser.mly\"\n                                                           ( Bbneg )\n# 1370 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 156 \"z3/z3Parser.mly\"\n                                                           ( Bbconc )\n# 1376 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 157 \"z3/z3Parser.mly\"\n                                                           ( Bbextr )\n# 1382 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 158 \"z3/z3Parser.mly\"\n                                                           ( Bbzext )\n# 1388 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 159 \"z3/z3Parser.mly\"\n                                                           ( Bbsext )\n# 1394 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 160 \"z3/z3Parser.mly\"\n                                                           ( Bbshl )\n# 1400 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 161 \"z3/z3Parser.mly\"\n                                                           ( Bbshr )\n# 1406 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 162 \"z3/z3Parser.mly\"\n                                                           ( Row1  )\n# 1412 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 163 \"z3/z3Parser.mly\"\n                                                           ( Row2  )\n# 1418 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 164 \"z3/z3Parser.mly\"\n                                                           ( Exte  )\n# 1424 \"z3/z3Parser.ml\"\n               : 'typ))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 168 \"z3/z3Parser.mly\"\n                                                           ( [] )\n# 1430 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 169 \"z3/z3Parser.mly\"\n                                                           ( let _, l = list_dec _2 in l )\n# 1437 \"z3/z3Parser.ml\"\n               : 'clause))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 173 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 1444 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 174 \"z3/z3Parser.mly\"\n                                                           ( _1::_2 )\n# 1452 \"z3/z3Parser.ml\"\n               : 'lit_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 178 \"z3/z3Parser.mly\"\n                                                           ( let decl, t = _1 in decl, Form.lit_of_atom_form_lit rf (decl, t) )\n# 1459 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 179 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1466 \"z3/z3Parser.ml\"\n               : 'lit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 183 \"z3/z3Parser.mly\"\n                                                           ( apply_dec Form.neg _3 )\n# 1473 \"z3/z3Parser.ml\"\n               : 'nlit))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 187 \"z3/z3Parser.mly\"\n                                             ( _1 )\n# 1480 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 188 \"z3/z3Parser.mly\"\n                                       ( _1 )\n# 1487 \"z3/z3Parser.ml\"\n               : 'var_atvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 192 \"z3/z3Parser.mly\"\n                                                          ( get_solver _1 )\n# 1494 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 4 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 193 \"z3/z3Parser.mly\"\n                                                          ( let res = _4 in add_solver _1 res; res )\n# 1502 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 194 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1509 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 195 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1515 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 196 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1521 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'var_atvar) in\n    Obj.repr(\n# 197 \"z3/z3Parser.mly\"\n                      ( let x = _1 in match find_opt_qvar x with\n    \t\t\t\t\t                   | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||])))\n\t\t\t\t\t\t\t   | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1530 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 200 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1537 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 201 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1544 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 202 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1551 \"z3/z3Parser.ml\"\n               : 'name_term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 206 \"z3/z3Parser.mly\"\n                 ( TZ )\n# 1557 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 207 \"z3/z3Parser.mly\"\n                  ( Tbool )\n# 1563 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 208 \"z3/z3Parser.mly\"\n                                                           ( Tindex (indexed_type_of_int _1) )\n# 1570 \"z3/z3Parser.ml\"\n               : 'tvar))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'tvar) in\n    Obj.repr(\n# 212 \"z3/z3Parser.mly\"\n                                   ( add_qvar _2 _3; [_2, _3] )\n# 1578 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'var_atvar) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'tvar) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'var_decl_list) in\n    Obj.repr(\n# 213 \"z3/z3Parser.mly\"\n                                               ( add_qvar _2 _3; (_2, _3)::_5 )\n# 1587 \"z3/z3Parser.ml\"\n               : 'var_decl_list))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'var_decl_list) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'blit) in\n    Obj.repr(\n# 217 \"z3/z3Parser.mly\"\n                                            ( clear_qvar (); false, Form.Form (Fapp (Fforall _3, [|Form.lit_of_atom_form_lit rf _5|])) )\n# 1595 \"z3/z3Parser.ml\"\n               : 'forall_decl))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'term) in\n    Obj.repr(\n# 221 \"z3/z3Parser.mly\"\n                                                           ( _2 )\n# 1602 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 224 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_true )\n# 1608 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    Obj.repr(\n# 225 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Form Form.pform_false )\n# 1614 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 226 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fand, Array.of_list x))) (list_dec _2) )\n# 1621 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 227 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (For, Array.of_list x))) (list_dec _2) )\n# 1628 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 228 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fimp, Array.of_list x))) (list_dec _2) )\n# 1635 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 229 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fxor, Array.of_list x))) (list_dec _2) )\n# 1642 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lit_list) in\n    Obj.repr(\n# 230 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun x -> Form.Form (Fapp (Fite, Array.of_list x))) (list_dec _2) )\n# 1649 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'forall_decl) in\n    Obj.repr(\n# 231 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1656 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'lit_list) in\n    Obj.repr(\n# 232 \"z3/z3Parser.mly\"\n                                                           ( let (decl, t) = _2 in let (decll, l) = list_dec _4 in (decl && decll, match t with | Form.Atom a -> Form.Form (FbbT (a, l)) | _ -> assert false) )\n# 1664 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 235 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_int ra _1) )\n# 1671 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : Big_int.big_int) in\n    Obj.repr(\n# 236 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.hatom_Z_of_bigint ra _1) )\n# 1678 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 237 \"z3/z3Parser.mly\"\n                                                           ( true, Form.Atom (Atom.mk_bvconst ra (parse_bv _1)) )\n# 1685 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 238 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_lt ra) _2 _3 )\n# 1693 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 239 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_le ra) _2 _3 )\n# 1701 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 240 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_gt ra) _2 _3 )\n# 1709 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 241 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_ge ra) _2 _3 )\n# 1717 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 242 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_plus ra) _2 _3 )\n# 1725 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 243 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_mult ra) _2 _3 )\n# 1733 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 244 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (Atom.mk_minus ra) _2 _3)\n# 1741 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 245 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:d a -> Atom.mk_neg ra a) _2 )\n# 1748 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 246 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (Atom.mk_opp ra) _2 )\n# 1755 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 247 \"z3/z3Parser.mly\"\n                                                           ( let da, la = list_dec _2 in\n    \t \t\t\t\t\t\t     let a = Array.of_list la in\n                                                             da, Form.Atom (Atom.mk_distinct ra ~declare:da (Atom.type_of a.(0)) a) )\n# 1764 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 250 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bitof ra ~declare:d s _2 h | _ -> assert false) _3 )\n# 1772 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 251 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvnot ra ~declare:d s h | _ -> assert false) _2 )\n# 1779 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 252 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvand ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1787 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 253 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1795 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 254 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvxor ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1803 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 255 \"z3/z3Parser.mly\"\n                                                           ( apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvneg ra ~declare:d s h | _ -> assert false) _2 )\n# 1810 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 256 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvadd ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1818 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 257 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvmult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1826 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 258 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1834 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 259 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1842 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 260 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvult ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1850 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 261 \"z3/z3Parser.mly\"\n                                                           ( let (decl,_) as a = apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvslt ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 in (decl, Form.Lit (Form.neg (Form.lit_of_atom_form_lit rf a))) )\n# 1858 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 262 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshl ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1866 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 263 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TBV s -> Atom.mk_bvshr ra ~declare:d s h1 h2 | _ -> assert false) _2 _3 )\n# 1874 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 264 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1, Atom.type_of h2 with TBV s1, TBV s2 -> Atom.mk_bvconcat ra ~declare:d s1 s2 h1 h2 | _, _ -> assert false) _2 _3 )\n# 1882 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 265 \"z3/z3Parser.mly\"\n                                                           ( let j, i = _2, _3 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvextr ra ~declare:d ~s ~i ~n:(j-i+1) h | _ -> assert false) _4 )\n# 1891 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 266 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvzextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1899 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 267 \"z3/z3Parser.mly\"\n                                                           ( let n = _2 in apply_dec_atom (fun ?declare:(d=true) h -> match Atom.type_of h with TBV s -> Atom.mk_bvsextn ra ~declare:d ~s ~n h | _ -> assert false) _3 )\n# 1907 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 268 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_select ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1915 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 269 \"z3/z3Parser.mly\"\n                                                           ( apply_bdec_atom (fun ?declare:(d=true) h1 h2 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_diffarray ra ~declare:d ti te h1 h2 | _ -> assert false) _2 _3 )\n# 1923 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 270 \"z3/z3Parser.mly\"\n                                                           ( apply_tdec_atom (fun ?declare:(d=true) h1 h2 h3 -> match Atom.type_of h1 with TFArray (ti, te) -> Atom.mk_store ra ~declare:d ti te h1 h2 h3 | _ -> assert false) _2 _3 _4 )\n# 1932 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 271 \"z3/z3Parser.mly\"\n                                                           ( let x = _1 in match find_opt_qvar x with | Some bt -> false, Form.Atom (Atom.get ~declare:false ra (Aapp (dummy_indexed_op (Rel_name x) [||] bt, [||]))) | None -> true, Form.Atom (Atom.get ra (Aapp (SmtMaps.get_fun _1, [||]))) )\n# 1939 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 272 \"z3/z3Parser.mly\"\n                                                           ( let f = _1 in let a = _2 in match find_opt_qvar f with | Some bt -> let op = dummy_indexed_op (Rel_name f) [||] bt in false, Form.Atom (Atom.get ~declare:false ra (Aapp (op, Array.of_list (snd (list_dec a))))) | None -> let dl, l = list_dec _2 in dl, Form.Atom (Atom.get ra ~declare:dl (Aapp (SmtMaps.get_fun f, Array.of_list l))) )\n# 1947 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 275 \"z3/z3Parser.mly\"\n                                                           ( let t1 = _2 in let t2 = _3 in match t1,t2 with | (decl1, Form.Atom h1), (decl2, Form.Atom h2) when (match Atom.type_of h1 with | SmtBtype.Tbool -> false | _ -> true) -> let decl = decl1 && decl2 in decl, Form.Atom (Atom.mk_eq_sym ra ~declare:decl (Atom.type_of h1) h1 h2) | (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); Form.lit_of_atom_form_lit rf (decl2, t2)|])) )\n# 1955 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'nlit) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lit) in\n    Obj.repr(\n# 276 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|t1; t2|])) )\n# 1963 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'nlit) in\n    Obj.repr(\n# 277 \"z3/z3Parser.mly\"\n                                                           ( match _2, _3 with (decl1, t1), (decl2, t2) -> decl1 && decl2, Form.Form (Fapp (Fiff, [|Form.lit_of_atom_form_lit rf (decl1, t1); t2|])) )\n# 1971 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'bindlist) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 278 \"z3/z3Parser.mly\"\n                                                           ( _3; _5 )\n# 1979 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in\n    Obj.repr(\n# 279 \"z3/z3Parser.mly\"\n                                                           ( true, Hashtbl.find hlets _1 )\n# 1986 \"z3/z3Parser.ml\"\n               : 'term))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 283 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 1993 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'lit) in\n    Obj.repr(\n# 284 \"z3/z3Parser.mly\"\n                                                           ( apply_dec (fun l -> Form.Lit (Form.neg l)) _3 )\n# 2000 \"z3/z3Parser.ml\"\n               : 'blit))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'blit) in\n    Obj.repr(\n# 288 \"z3/z3Parser.mly\"\n                                                      ( Hashtbl.add hlets _2 (snd _3) )\n# 2008 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in\n    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'blit) in\n    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'bindlist) in\n    Obj.repr(\n# 289 \"z3/z3Parser.mly\"\n                                                           ( Hashtbl.add hlets _2 (snd _3); _5 )\n# 2017 \"z3/z3Parser.ml\"\n               : 'bindlist))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_term) in\n    Obj.repr(\n# 292 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> [decl, h] | _ -> assert false )\n# 2024 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_term) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'args) in\n    Obj.repr(\n# 293 \"z3/z3Parser.mly\"\n                                                           ( match _1 with decl, Form.Atom h -> (decl, h)::_2 | _ -> assert false )\n# 2032 \"z3/z3Parser.ml\"\n               : 'args))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 297 \"z3/z3Parser.mly\"\n                                                           ( _1 )\n# 2039 \"z3/z3Parser.ml\"\n               : 'clause_ids_params))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in\n    Obj.repr(\n# 301 \"z3/z3Parser.mly\"\n                                                           ( [_1] )\n# 2046 \"z3/z3Parser.ml\"\n               : 'int_list))\n; (fun __caml_parser_env ->\n    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in\n    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'int_list) in\n    Obj.repr(\n# 302 \"z3/z3Parser.mly\"\n                                                           ( let x1 = _1 in let x2 = _2 in x1::x2 )\n# 2054 \"z3/z3Parser.ml\"\n               : 'int_list))\n(* Entry line *)\n; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))\n|]\nlet yytables =\n  { Parsing.actions=yyact;\n    Parsing.transl_const=yytransl_const;\n    Parsing.transl_block=yytransl_block;\n    Parsing.lhs=yylhs;\n    Parsing.len=yylen;\n    Parsing.defred=yydefred;\n    Parsing.dgoto=yydgoto;\n    Parsing.sindex=yysindex;\n    Parsing.rindex=yyrindex;\n    Parsing.gindex=yygindex;\n    Parsing.tablesize=yytablesize;\n    Parsing.table=yytable;\n    Parsing.check=yycheck;\n    Parsing.error_function=parse_error;\n    Parsing.names_const=yynames_const;\n    Parsing.names_block=yynames_block }\nlet line (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =\n   (Parsing.yyparse yytables 1 lexfun lexbuf : int)\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml","version":8}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1298,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":169,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00286102294922ms
Sending response {"id": 1298, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1299,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":169,"character":14},"end":{"line":169,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1299, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1300,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0638961791992ms
Sending response {"id": 1300, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1301,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 1301, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1302,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 1302, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1303,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":175,"character":17},"end":{"line":175,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 1303, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1304,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0321865081787ms
Sending response {"id": 1304, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1305,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1305, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1306,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1306, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1307,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":117,"character":17},"end":{"line":117,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1307, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1308,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1308, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1309,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1309, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1310,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1310, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1311,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"},"range":{"start":{"line":20,"character":8},"end":{"line":20,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1311, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1312,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 1312, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1313,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1313, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1314,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1314, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/verit.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1315,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1315, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1316,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1316, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1317,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 1317, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1318,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1318, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1319,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1319, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1320,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1320, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1321,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":79,"character":26},"end":{"line":79,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1321, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1322,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":45}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Sending response {"id": 1322, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1323,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":67,"character":45}}}
[server] Got a method textDocument/definition
[server] processing took 0.00405311584473ms
Sending response {"id": 1323, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1324,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1324, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1325,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":67,"character":45},"end":{"line":67,"character":45}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Sending response {"id": 1325, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1326,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1326, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1327,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1327, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1328,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1328, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1329,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1329, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1330,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"range":{"start":{"line":17,"character":17},"end":{"line":17,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1330, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1331,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1331, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1332,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"position":{"line":8,"character":50}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 1332, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli","version":1},"contentChanges":[{"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id -> Structures.id -> Structures.id -> string -> string -> unit\nval checker : string -> string -> unit\nval checker_debug : string -> string -> unit\nval theorem : Structures.id -> string -> string -> unit\nval tactic : EConstr.t -> Structures.constr_expr list -> Structures.tactic\nval tactic_no_check : EConstr.t -> Structures.constr_expr list -> Structures.tactic\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1333,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1333, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1334,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"position":{"line":19,"character":26}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 1334, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1335,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 1335, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1336,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.mli"},"position":{"line":22,"character":3}}}
[server] Got a method textDocument/hover
[server] processing took 0.0171661376953ms
Sending response {"id": 1336, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nval parse_certif :\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  Structures.id ->\n  SmtBtype.reify_tbl * SmtAtom.Op.reify_tbl *\n  SmtAtom.Atom.reify_tbl * SmtAtom.Form.reify *\n  SmtAtom.Form.t list * int * SmtAtom.Form.t SmtCertif.clause ->\n  unit\n\nval checker_debug :\n  SmtBtype.reify_tbl * SmtAtom.Op.reify_tbl *\n  SmtAtom.Atom.reify_tbl * SmtAtom.Form.reify *\n  SmtAtom.Form.t list * int * SmtAtom.Form.t SmtCertif.clause -> 'a\n\nval theorem :\n  Structures.id ->\n  SmtBtype.reify_tbl * SmtAtom.Op.reify_tbl *\n  SmtAtom.Atom.reify_tbl * SmtAtom.Form.reify *\n  SmtAtom.Form.t list * int * SmtAtom.Form.t SmtCertif.clause ->\n  unit\n\nval checker :\n  SmtBtype.reify_tbl * SmtAtom.Op.reify_tbl *\n  SmtAtom.Atom.reify_tbl * SmtAtom.Form.reify *\n  SmtAtom.Form.t list * int * SmtAtom.Form.t SmtCertif.clause ->\n  unit\n\nval tactic :\n  (Environ.env ->\n   SmtBtype.reify_tbl ->\n   SmtAtom.Op.reify_tbl ->\n   SmtAtom.Atom.reify_tbl ->\n   SmtAtom.Form.reify ->\n   (SmtAtom.Form.t SmtCertif.clause * SmtAtom.Form.t) ->\n   SmtAtom.Form.t list -> int * SmtAtom.Form.t SmtCertif.clause) ->\n  SmtMisc.logic ->\n  SmtBtype.reify_tbl ->\n  SmtAtom.Op.reify_tbl ->\n  SmtAtom.Atom.reify_tbl ->\n  SmtAtom.Form.reify ->\n  SmtAtom.Atom.reify_tbl ->\n  SmtAtom.Form.reify ->\n  (Environ.env -> Structures.constr -> Structures.constr) ->\n  Structures.constr list ->\n  Structures.constr_expr list -> Structures.tactic\n\nval model_string : Environ.env -> SmtBtype.reify_tbl -> 'a -> 'b -> 'c -> SExpr.t -> string\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1337,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1337, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1338,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1338, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1339,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1339, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1340,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.mli"},"range":{"start":{"line":20,"character":23},"end":{"line":20,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1340, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1337}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtCommands.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.ml","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n(** Maps that store SMT objects **)\n\n(* SMT types *)\nlet btypes : (string, SmtBtype.btype) Hashtbl.t = Hashtbl.create 17\nlet get_btype id =\n  try Hashtbl.find btypes id\n  with | Not_found -> failwith (\"SmtMaps.get_btype : sort symbol \\\"\"^id^\"\\\" not found\\n\")\nlet add_btype id cl = Hashtbl.add btypes id cl\nlet clear_btypes () = Hashtbl.clear btypes\n\n(* SMT function symbols *)\nlet funs : (string, SmtAtom.indexed_op) Hashtbl.t = Hashtbl.create 17\nlet get_fun id =\n  try Hashtbl.find funs id\n  with | Not_found -> failwith (\"SmtMaps.get_fun : function symbol \\\"\"^id^\"\\\" not found\\n\")\nlet add_fun id cl = Hashtbl.add funs id cl\nlet remove_fun id = Hashtbl.remove funs id\nlet clear_funs () = Hashtbl.clear funs\n\n(* Clean-up of all the maps *)\nlet clear () =\n  clear_btypes ();\n  clear_funs ()\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1341,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1341, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1342,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 1342, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1343,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1343, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1344,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.ml"},"range":{"start":{"line":23,"character":20},"end":{"line":23,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1344, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n(** Maps that store SMT objects **)\n\n(* SMT types *)\nval get_btype : string -> SmtBtype.btype\nval add_btype : string -> SmtBtype.btype -> unit\n\n(* SMT function symbols *)\nval get_fun : string -> SmtAtom.indexed_op\nval add_fun : string -> SmtAtom.indexed_op -> unit\nval remove_fun : string -> unit\n\n(* Clean-up of all the maps *)\nval clear : unit -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1345,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1345, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1346,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1346, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1347,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1347, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1348,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.mli"},"range":{"start":{"line":20,"character":24},"end":{"line":20,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1348, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1349,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1349, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1350,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1350, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1351,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1351, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1352,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/verit.ml"},"range":{"start":{"line":15,"character":5},"end":{"line":15,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1352, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/trace/smtMaps.mli"}}}
Read message 
{"jsonrpc":"2.0","id":1353,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 1353, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1354,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 1354, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1355,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 1355, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1356,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":15,"character":5},"end":{"line":15,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1356, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1357,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1357, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1358,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1358, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1359,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":195,"character":44},"end":{"line":195,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1359, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1360,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":197,"character":44},"end":{"line":197,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1360, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1361,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":172,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.00596046447754ms
Sending response {"id": 1361, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1362,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":199,"character":29},"end":{"line":199,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1362, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1363,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1363, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1364,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":212,"character":43},"end":{"line":212,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1364, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1365,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":213,"character":48},"end":{"line":213,"character":53}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1365, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1366,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"position":{"line":185,"character":28}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 1366, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1367,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":185,"character":28},"end":{"line":185,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0910758972168ms
Sending response {"id": 1367, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1368,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":197,"character":44},"end":{"line":197,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1368, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1369,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1369, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1370,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":212,"character":43},"end":{"line":212,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1370, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1371,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":213,"character":48},"end":{"line":213,"character":53}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 1371, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1372,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1372, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1373,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":195,"character":44},"end":{"line":195,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1373, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1374,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":197,"character":44},"end":{"line":197,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1374, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1375,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":199,"character":29},"end":{"line":199,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1375, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1376,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":201,"character":29},"end":{"line":201,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1376, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1377,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":212,"character":43},"end":{"line":212,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1377, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1378,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":213,"character":48},"end":{"line":213,"character":53}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1378, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1379,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":178,"character":17},"end":{"line":178,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 1379, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1380,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3.ml"},"range":{"start":{"line":212,"character":43},"end":{"line":212,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1380, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1381,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1381, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1382,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1382, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1383,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 1383, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1384,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"range":{"start":{"line":169,"character":7},"end":{"line":169,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1384, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1385,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"},"position":{"line":164,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.0112056732178ms
Sending response {"id": 1385, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1386,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Parser.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 1386, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1387,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 1387, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1388,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1388, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1389,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1389, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1390,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":197,"character":48},"end":{"line":197,"character":55}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1390, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1391,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"position":{"line":193,"character":29}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Sending response {"id": 1391, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1392,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1392, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1393,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":193,"character":29},"end":{"line":193,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1393, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1394,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.ml"},"range":{"start":{"line":193,"character":29},"end":{"line":193,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1394, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1395,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1395, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1396,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1396, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1397,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1397, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1398,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":27,"character":56},"end":{"line":27,"character":63}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1398, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1399,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":18,"character":24},"end":{"line":18,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 1399, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1400,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1400, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1401,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":11},"end":{"line":40,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1401, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\nopen SmtAtom\n\nexception Sat\n\ntype typ = | Inpu | Deep | True | Fals | Andp | Andn | Orp | Orn | Xorp1 | Xorp2 | Xorn1 | Xorn2 | Impp | Impn1 | Impn2 | Equp1 | Equp2 | Equn1 | Equn2 | Itep1 | Itep2 | Iten1 | Iten2 | Eqre | Eqtr | Eqco | Eqcp | Dlge | Lage | Lata | Dlde | Lade | Fins | Eins | Skea | Skaa | Qnts | Qntm | Reso | Weak | And | Nor | Or | Nand | Xor1 | Xor2 | Nxor1 | Nxor2 | Imp | Nimp1 | Nimp2 | Equ1 | Equ2 | Nequ1 | Nequ2 | Ite1 | Ite2 | Nite1 | Nite2 | Tpal | Tlap | Tple | Tpne | Tpde | Tpsa | Tpie | Tpma | Tpbr | Tpbe | Tpsc | Tppp | Tpqt | Tpqs | Tpsk | Subp | Flat | Hole | Bbva | Bbconst | Bbeq | Bbdis | Bbop | Bbadd | Bbmul | Bbult | Bbslt | Bbnot | Bbneg | Bbconc | Bbextr | Bbzext | Bbsext | Bbshl | Bbshr | Row1 | Row2 | Exte\n\nval get_clause : int -> SmtAtom.Form.t SmtCertif.clause\nval add_clause : int -> SmtAtom.Form.t SmtCertif.clause -> unit\n\nval add_ref : int -> int -> unit\nval get_ref : int -> int\nval to_add : (int * SmtAtom.Form.t list) list ref\n\nval mk_clause : SmtCertif.clause_id * typ * SmtAtom.Form.t list * SmtCertif.clause_id list -> SmtCertif.clause_id\n\nval apply_dec_atom : (?declare:bool -> SmtAtom.hatom -> SmtAtom.hatom) ->\n                     bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_bdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\nval apply_tdec_atom :\n  (?declare:bool -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t -> SmtAtom.Atom.t) ->\n  bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit -> bool * Form.atom_form_lit\n\nval apply_dec : ('a -> 'b) -> bool * 'a -> bool * 'b\nval list_dec : (bool * 'a) list -> bool * 'a list\n\n\nval get_solver : int -> bool * Form.atom_form_lit\nval add_solver : int -> bool * Form.atom_form_lit -> unit\n\nval find_opt_qvar : string -> SmtBtype.btype option \nval add_qvar : string -> SmtBtype.btype -> unit\nval clear_qvar : unit -> unit\n\nval init_index : SmtAtom.Form.t list -> (SmtAtom.Form.t -> SmtAtom.Form.t) ->\n                 SmtAtom.Form.t -> int\n\nval qf_to_add : SmtAtom.Form.t SmtCertif.clause list -> (SmtAtom.Form.t SmtCertif.clause_kind * SmtAtom.Form.t list option * SmtAtom.Form.t SmtCertif.clause) list\n\nval ra : SmtAtom.Atom.reify_tbl\nval rf : SmtAtom.Form.reify\nval ra_quant : SmtAtom.Atom.reify_tbl\nval rf_quant : SmtAtom.Form.reify\n\nval hlets : (string, Form.atom_form_lit) Hashtbl.t\n\nval clear : unit -> unit\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1402,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 1402, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1403,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1403, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1404,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1404, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1405,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":60,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1405, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1402}}
Read message 
{"jsonrpc":"2.0","id":1406,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1406, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1407,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1407, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1408,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1408, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1409,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/z3/z3Syntax.mli"},"range":{"start":{"line":40,"character":11},"end":{"line":40,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1409, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/verit/veritSyntax.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.mli","languageId":"ocaml","version":1,"text":"(**************************************************************************)\n(*                                                                        *)\n(*     SMTCoq                                                             *)\n(*     Copyright (C) 2011 - 2021                                          *)\n(*                                                                        *)\n(*     See file \"AUTHORS\" for the list of authors                         *)\n(*                                                                        *)\n(*   This file is distributed under the terms of the CeCILL-C licence     *)\n(*                                                                        *)\n(**************************************************************************)\n\n\n(* Constr generation and manipulation *)\ntype id = Names.variable\nval mkId : string -> id\n\ntype name\nval name_of_id : id -> name\nval mkName : string -> name\nval string_of_name : name -> string\n\ntype constr = Term.constr\ntype types = constr\nval eq_constr : constr -> constr -> bool\nval hash_constr : constr -> int\nval mkProp : types\nval mkConst : Names.constant -> constr\nval mkVar : id -> constr\nval mkRel : int -> constr\nval isRel : constr -> bool\nval destRel : constr -> int\nval lift : int -> constr -> constr\nval mkApp : constr * constr array -> constr\nval decompose_app : constr -> constr * constr list\nval mkLambda : name * types * constr -> constr\nval mkProd : name * types * types -> types\nval mkLetIn : name * constr * types * constr -> constr\n\nval pr_constr_env : Environ.env -> constr -> Pp.std_ppcmds\nval pr_constr : constr -> Pp.std_ppcmds\n\nval mkUConst : constr -> Entries.definition_entry\nval mkTConst : constr -> 'a -> types -> Entries.definition_entry\nval declare_new_type : id -> types\nval declare_new_variable : id -> types -> constr\nval declare_constant : id -> Entries.definition_entry -> Names.constant\n\ntype cast_kind\nval vmcast : cast_kind\nval mkCast : constr * cast_kind * constr -> constr\n\n\n(* EConstr *)\ntype econstr = constr\nval econstr_of_constr : constr -> econstr\n\n\n(* Modules *)\nval gen_constant : string list list -> string -> constr lazy_t\n\n\n(* Int63 *)\nval int63_modules : string list list\nval mkInt : int -> constr\nval cint : constr lazy_t\n\n\n(* PArray *)\nval parray_modules : string list list\nval max_array_size : int\nval mkArray : types * constr array -> constr\n\n\n(* Traces *)\nval mkTrace :\n  ('a -> constr) ->\n  ('a -> 'a) ->\n  constr Lazy.t ->\n  'b ->\n  'c -> 'd -> 'e -> int -> types -> constr -> 'a ref -> constr\n\n\n(* Micromega *)\nmodule Micromega_plugin_Micromega = Micromega\nmodule Micromega_plugin_Mutils = Mutils\nmodule Micromega_plugin_Certificate = Certificate\nmodule Micromega_plugin_Coq_micromega = Coq_micromega\n\nval micromega_coq_proofTerm : constr lazy_t\nval micromega_dump_proof_term : Micromega_plugin_Certificate.Mc.zArithProof -> constr\n\n\n(* Tactics *)\ntype tactic = Proof_type.tactic\nval tclTHEN : Proof_type.tactic -> Proof_type.tactic -> Proof_type.tactic\nval tclTHENLAST : Proof_type.tactic -> Proof_type.tactic -> Proof_type.tactic\nval assert_before : name -> types -> Proof_type.tactic\nval vm_cast_no_check : constr -> Proof_type.tactic\nval mk_tactic :\n  (Environ.env ->\n   Evd.evar_map -> types -> Proof_type.goal Tacmach.sigma -> 'a) ->\n  Proof_type.goal Tacmach.sigma -> 'a\nval set_evars_tac : 'a -> Proof_type.tactic\n\n\n(* Other differences between the two versions of Coq *)\ntype constr_expr = Topconstr.constr_expr\nval error : string -> 'a\nval warning : string -> string -> unit\nval extern_constr : constr -> Topconstr.constr_expr\nval destruct_rel_decl : Term.rel_declaration -> name * types\nval interp_constr : Environ.env -> Evd.evar_map -> Topconstr.constr_expr -> constr\nval ppconstr_lsimpleconstr : Ppconstr.precedence\nval constrextern_extern_constr : constr -> Topconstr.constr_expr\nval get_rel_dec_name : 'a -> name\nval retyping_get_type_of : Environ.env -> Evd.evar_map -> constr -> constr\n\nval vm_conv : Reduction.conv_pb -> types Reduction.conversion_function\nval cbv_vm : Environ.env -> constr -> types -> constr\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1410,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.mli"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1410, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1411,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.mli"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1411, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1412,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.mli"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1412, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/native/structures.mli"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml","languageId":"ocaml","version":1,"text":"(*** This file is taken from Coq-8.9.0 to solve a compilation issue due\n   to a wrong order in dependencies.\n   See https://github.com/coq/coq/issues/9768 . ***)\n\n\n(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n(*                                                                      *)\n(* Micromega: A reflexive tactic using the Positivstellensatz           *)\n(*                                                                      *)\n(* ** Utility functions **                                              *)\n(*                                                                      *)\n(* - Modules CoqToCaml, CamlToCoq                                       *)\n(* - Modules Cmp, Tag, TagSet                                           *)\n(*                                                                      *)\n(*  Frdric Besson (Irisa/Inria) 2006-2008                             *)\n(*                                                                      *)\n(************************************************************************)\n\nmodule Micromega = Micromega_plugin.Micromega\n\nlet rec pp_list f o l =\n  match l with\n    | [] -> ()\n    | e::l -> f o e ; output_string o \";\" ; pp_list f o l\n\n\nlet finally f rst =\n  try\n    let res = f () in\n      rst () ; res\n  with reraise ->\n    (try rst ()\n    with any -> raise reraise\n    ); raise reraise\n\nlet rec try_any l x =\n match l with\n  | [] -> None\n  | (f,s)::l -> match f x with\n     | None -> try_any l x\n     | x -> x\n\nlet all_sym_pairs f l = \n  let pair_with acc e l = List.fold_left (fun acc x -> (f e x) ::acc) acc l in\n\n  let rec xpairs acc l = \n    match l with\n      | [] -> acc\n      | e::l -> xpairs (pair_with acc e l) l in\n    xpairs [] l\n\nlet all_pairs f l = \n  let pair_with acc e l = List.fold_left (fun acc x -> (f e x) ::acc) acc l in\n\n  let rec xpairs acc l = \n    match l with\n      | [] -> acc\n      | e::lx -> xpairs (pair_with acc e l) lx in\n    xpairs [] l\n\nlet rec is_sublist f l1 l2 =\n  match l1 ,l2 with\n    | [] ,_ -> true\n    | e::l1', [] -> false\n    | e::l1' , e'::l2' ->\n\tif f e e' then is_sublist f l1' l2'\n\telse is_sublist f l1 l2'\n\nlet extract pred l = \n  List.fold_left (fun (fd,sys) e -> \n\t\t    match fd with\n\t\t    | None -> \n\t\t\tbegin\n\t\t\t  match pred e with\n\t\t\t  | None -> fd, e::sys\n\t\t\t  | Some v -> Some(v,e) , sys\n\t\t\tend\n\t\t    |  _   -> (fd, e::sys)\n\t\t ) (None,[]) l\n\nopen Num\nopen Big_int\n\nlet ppcm x y =\n let g = gcd_big_int x y in\n let x' = div_big_int x g in\n let y' = div_big_int y g in\n  mult_big_int g (mult_big_int x' y')\n\nlet denominator = function\n | Int _ | Big_int _ -> unit_big_int\n | Ratio r -> Ratio.denominator_ratio r\n\nlet numerator = function\n | Ratio r -> Ratio.numerator_ratio r\n | Int i -> Big_int.big_int_of_int i\n | Big_int i -> i\n\nlet rec ppcm_list c l =\n match l with\n  | [] -> c\n  | e::l -> ppcm_list (ppcm c (denominator e)) l\n\nlet rec rec_gcd_list c l  =\n match l with\n  | [] -> c\n  | e::l -> rec_gcd_list (gcd_big_int  c (numerator e)) l\n\nlet gcd_list l =\n let res = rec_gcd_list zero_big_int l in\n  if Int.equal (compare_big_int res zero_big_int) 0\n  then unit_big_int else res\n\nlet rats_to_ints l =\n let c = ppcm_list unit_big_int l in\n  List.map (fun x ->  (div_big_int (mult_big_int (numerator x) c)\n\t\t\t(denominator x))) l\n\n(* assoc_pos j [a0...an] = [j,a0....an,j+n],j+n+1 *)\n(**\n  * MODULE: Coq to Caml data-structure mappings\n  *)\n\nmodule CoqToCaml =\nstruct\n open Micromega\n\n let rec nat = function\n  | O -> 0\n  | S n -> (nat n) + 1\n\n\n let rec positive p =\n  match p with\n   | XH -> 1\n   | XI p -> 1+ 2*(positive p)\n   | XO p -> 2*(positive p)\n\n let n nt =\n  match nt with\n   | N0 -> 0\n   | Npos p -> positive p\n\n let rec index i = (* Swap left-right ? *)\n  match i with\n   | XH -> 1\n   | XI i -> 1+(2*(index i))\n   | XO i -> 2*(index i)\n\n open Big_int\n\n let rec positive_big_int p =\n  match p with\n   | XH -> unit_big_int\n   | XI p -> add_int_big_int 1 (mult_int_big_int 2 (positive_big_int p))\n   | XO p -> (mult_int_big_int 2 (positive_big_int p))\n\n let z_big_int x =\n  match x with\n   | Z0 -> zero_big_int\n   | Zpos p -> (positive_big_int p)\n   | Zneg p -> minus_big_int (positive_big_int p)\n\n let q_to_num {qnum = x ; qden = y} =\n  Big_int (z_big_int x) // (Big_int (z_big_int (Zpos y)))\n\nend\n\n\n(**\n  * MODULE: Caml to Coq data-structure mappings\n  *)\n\nmodule CamlToCoq =\nstruct\n open Micromega\n\n let rec nat = function\n  | 0 -> O\n  | n -> S (nat (n-1))\n\n\n let rec positive n =\n  if Int.equal n 1 then XH\n  else if Int.equal (n land 1) 1 then XI (positive (n lsr 1))\n  else  XO (positive (n lsr 1))\n\n let n nt =\n  if nt < 0\n  then assert false\n  else if Int.equal nt 0 then N0\n  else Npos (positive nt)\n\n let rec index  n =\n  if Int.equal n 1 then XH\n  else if Int.equal (n land 1) 1 then XI (index (n lsr 1))\n  else  XO (index (n lsr 1))\n\n\n let z x =\n  match compare x 0 with\n   | 0 -> Z0\n   | 1 -> Zpos (positive x)\n   | _ -> (* this should be -1 *)\n      Zneg (positive (-x))\n\n open Big_int\n\n let positive_big_int n =\n  let two = big_int_of_int 2 in\n  let rec _pos n =\n   if eq_big_int n unit_big_int then XH\n   else\n    let (q,m) = quomod_big_int n two  in\n     if eq_big_int unit_big_int m\n     then XI (_pos q)\n     else XO (_pos q) in\n   _pos n\n\n let bigint x =\n  match sign_big_int x with\n   | 0 -> Z0\n   | 1 -> Zpos (positive_big_int x)\n   | _ -> Zneg (positive_big_int (minus_big_int x))\n\n let q n =\n  {Micromega.qnum = bigint (numerator n) ;\n   Micromega.qden = positive_big_int (denominator n)}\n\nend\n\n(**\n  * MODULE: Comparisons on lists: by evaluating the elements in a single list,\n  * between two lists given an ordering, and using a hash computation\n  *)\n\nmodule Cmp =\nstruct\n\n let rec compare_lexical l =\n  match l with\n   | [] -> 0 (* Equal *)\n   | f::l ->\n      let cmp = f () in\n       if Int.equal cmp 0 then compare_lexical l else cmp\n\n let rec compare_list cmp l1 l2 =\n  match l1 , l2 with\n   | []  , [] -> 0\n   | []  , _  -> -1\n   | _   , [] -> 1\n   | e1::l1 , e2::l2 ->\n      let c = cmp e1 e2 in\n       if Int.equal c 0 then compare_list cmp l1 l2 else c\n\nend\n\n(**\n  * MODULE: Labels for atoms in propositional formulas. \n  * Tags are used to identify unused atoms in CNFs, and propagate them back to\n  * the original formula. The translation back to Coq then ignores these\n  * superfluous items, which speeds the translation up a bit.\n  *)\n\nmodule type Tag =\nsig\n\n  type t\n\n  val from : int -> t\n  val next : t -> t\n  val pp : out_channel -> t -> unit\n  val compare : t -> t -> int\n\nend\n\nmodule Tag : Tag =\nstruct\n\n  type t = int\n\n  let from i = i\n  let next i = i + 1\n  let pp o i = output_string o (string_of_int i)\n  let compare : int -> int -> int = Int.compare\n\nend\n\n(**\n  * MODULE: Ordered sets of tags.\n  *)\n\nmodule TagSet = Set.Make(Tag)\n\n(** As for Unix.close_process, our Unix.waipid will ignore all EINTR *)\n\nlet rec waitpid_non_intr pid =\n  try snd (Unix.waitpid [] pid)\n  with Unix.Unix_error (Unix.EINTR, _, _) -> waitpid_non_intr pid\n\n(**\n  * Forking routine, plumbing the appropriate pipes where needed.\n  *)\n\nlet command exe_path args vl =\n  (* creating pipes for stdin, stdout, stderr *)\n  let (stdin_read,stdin_write) = Unix.pipe ()\n  and (stdout_read,stdout_write) = Unix.pipe ()\n  and (stderr_read,stderr_write) = Unix.pipe () in\n\n  (* Create the process *)\n  let pid = Unix.create_process exe_path args stdin_read stdout_write stderr_write in\n\n  (* Write the data on the stdin of the created process *)\n  let outch = Unix.out_channel_of_descr stdin_write in\n    output_value outch vl ;\n    flush outch ;\n\n  (* Wait for its completion *)\n    let status = waitpid_non_intr pid in\n\n      finally\n        (* Recover the result *)\n\t(fun () ->\n\t  match status with\n\t    | Unix.WEXITED 0 ->\n\t\tlet inch = Unix.in_channel_of_descr stdout_read in\n\t\tbegin\n                  try Marshal.from_channel inch\n                  with any ->\n                    failwith\n                      (Printf.sprintf \"command \\\"%s\\\" exited %s\" exe_path\n                         (Printexc.to_string any))\n                end\n\t    | Unix.WEXITED i   ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" exited %i\" exe_path i)\n\t    | Unix.WSIGNALED i ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" killed %i\" exe_path i)\n\t    | Unix.WSTOPPED i  ->\n                failwith (Printf.sprintf \"command \\\"%s\\\" stopped %i\" exe_path i))\n        (* Cleanup  *)\n\t(fun () ->\n\t  List.iter (fun x -> try Unix.close x with any -> ())\n            [stdin_read; stdin_write;\n             stdout_read; stdout_write;\n             stderr_read; stderr_write])\n\n(* Local Variables: *)\n(* coding: utf-8 *)\n(* End: *)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1413,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 1413, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1414,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1414, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1415,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1415, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1416,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"},"range":{"start":{"line":11,"character":51},"end":{"line":11,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1416, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ricardociriacodagraca/Documents/smtcoq/src/versions/standard/mutils_full.ml"}}}
